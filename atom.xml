<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光的博客</title>
  
  <subtitle>php后端工程师，兼职前端和go开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yzdzh.github.io/"/>
  <updated>2021-12-03T19:28:37.865Z</updated>
  <id>https://yzdzh.github.io/</id>
  
  <author>
    <name>xingguang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux中root账号也无法修改文件权限解决方法</title>
    <link href="https://yzdzh.github.io/post/1494107583.html"/>
    <id>https://yzdzh.github.io/post/1494107583.html</id>
    <published>2021-12-03T19:21:00.000Z</published>
    <updated>2021-12-03T19:28:37.865Z</updated>
    
    <content type="html"><![CDATA[<p>一般是被用chattr命令锁住文件</p><h3 id="1、lsattr命令查看文件的属性"><a href="#1、lsattr命令查看文件的属性" class="headerlink" title="1、lsattr命令查看文件的属性"></a>1、lsattr命令查看文件的属性</h3><p>执行命令lsattr authorized_keys查看当前文件属性，可以发现有i和a两个属性。<br><img src="/resource/images/pasted2-11.png" alt="upload successful"></p><h3 id="2、去掉锁住的权限"><a href="#2、去掉锁住的权限" class="headerlink" title="2、去掉锁住的权限"></a>2、去掉锁住的权限</h3><p>去掉lsattr命令查看到的i和a两个属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr -ia authorized_keys</span><br></pre></td></tr></table></figure><h3 id="3、还原权限"><a href="#3、还原权限" class="headerlink" title="3、还原权限"></a>3、还原权限</h3><p>修改完后还原文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +ia authorized_keys</span><br></pre></td></tr></table></figure><p>借鉴于原文：<br><a href="https://www.cnblogs.com/cpl9412290130/p/11592803.html" target="_blank" rel="noopener">https://www.cnblogs.com/cpl9412290130/p/11592803.html</a><br><a href="https://www.runoob.com/linux/linux-comm-chattr.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-chattr.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般是被用chattr命令锁住文件&lt;/p&gt;
&lt;h3 id=&quot;1、lsattr命令查看文件的属性&quot;&gt;&lt;a href=&quot;#1、lsattr命令查看文件的属性&quot; class=&quot;headerlink&quot; title=&quot;1、lsattr命令查看文件的属性&quot;&gt;&lt;/a&gt;1、lsattr命令
      
    
    </summary>
    
    
      <category term="linux" scheme="https://yzdzh.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb容器的数据导入和导出</title>
    <link href="https://yzdzh.github.io/post/381300251.html"/>
    <id>https://yzdzh.github.io/post/381300251.html</id>
    <published>2021-12-03T19:01:00.000Z</published>
    <updated>2021-12-03T19:12:16.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、mongodump导出备份"><a href="#1、mongodump导出备份" class="headerlink" title="1、mongodump导出备份"></a>1、mongodump导出备份</h3><h4 id="1-、执行mongodump命令"><a href="#1-、执行mongodump命令" class="headerlink" title="1)、执行mongodump命令"></a>1)、执行mongodump命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u root com_mongo mongodump -h 127.0.0.1:27017 -d ag_mongo -u root -p 123456 --authenticationDatabase admin -o /mongo_sql_back</span><br></pre></td></tr></table></figure><p>注：<br>-h 地址<br>-d 数据库名称<br>-u 用户名<br>-p 密码<br>-o 输出地址<br>–authenticationDatabase admin 验证账户的数据库  </p><h4 id="2-、将备份文件从里面cp出来（如果已经容器目录映射，则忽略此步骤）"><a href="#2-、将备份文件从里面cp出来（如果已经容器目录映射，则忽略此步骤）" class="headerlink" title="2)、将备份文件从里面cp出来（如果已经容器目录映射，则忽略此步骤）"></a>2)、将备份文件从里面cp出来（如果已经容器目录映射，则忽略此步骤）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp com_mongo:mongo_sql_back /mongo_sql_back</span><br><span class="line"></span><br><span class="line">docker cp 容器名:容器内导出数据库文件夹 宿主机保存文件夹</span><br></pre></td></tr></table></figure><h3 id="2、mongorestore恢复数据库"><a href="#2、mongorestore恢复数据库" class="headerlink" title="2、mongorestore恢复数据库"></a>2、mongorestore恢复数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u root com_mongo mongorestore -h 127.0.0.1:27017 -d ag_mongo --dir /mongo_sql_back/ag_mongo -u root -p 123456 --authenticationDatabase admin</span><br></pre></td></tr></table></figure><p>注：<br>-h 地址<br>-d 数据库名称<br>-u 用户名<br>-p 密码<br>–dir 导入的数据库文件夹<br>–authenticationDatabase admin 验证账户的数据库  </p><p>借鉴于原文：<a href="https://www.jianshu.com/p/398bcccd7981" target="_blank" rel="noopener">https://www.jianshu.com/p/398bcccd7981</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、mongodump导出备份&quot;&gt;&lt;a href=&quot;#1、mongodump导出备份&quot; class=&quot;headerlink&quot; title=&quot;1、mongodump导出备份&quot;&gt;&lt;/a&gt;1、mongodump导出备份&lt;/h3&gt;&lt;h4 id=&quot;1-、执行mongodum
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql容器的数据导入和导出</title>
    <link href="https://yzdzh.github.io/post/1607203207.html"/>
    <id>https://yzdzh.github.io/post/1607203207.html</id>
    <published>2021-12-03T18:30:00.000Z</published>
    <updated>2021-12-03T19:10:46.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、mysqldump导出备份"><a href="#1、mysqldump导出备份" class="headerlink" title="1、mysqldump导出备份"></a>1、mysqldump导出备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it  com_mysql mysqldump -c -uroot -p123456    app_agent  &gt;  app_agent.sql</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it  com_mysql【docker容器名称/ID】 mysqldump -uroot -p123456【数据库密码】 test_db【数据库名称】 &gt; /opt/sql_bak/test_db.sql【导出表格路径】</span><br></pre></td></tr></table></figure><p> 选项说明</p><table><thead><tr><th>参数名</th><th>缩写</th><th>含义</th></tr></thead><tbody><tr><td>–host</td><td>-h</td><td>服务器IP地址</td></tr><tr><td>–port</td><td>-P</td><td>服务器端口号</td></tr><tr><td>–user</td><td>-u</td><td>MySQL 用户名</td></tr><tr><td>–pasword</td><td>-p</td><td>MySQL 密码</td></tr><tr><td>–databases</td><td></td><td>指定要备份的数据库</td></tr><tr><td>–all-databases</td><td></td><td>备份mysql服务器上的所有数据库</td></tr><tr><td>–compact</td><td>-c</td><td>压缩模式，产生更少的输出</td></tr><tr><td>–comments</td><td></td><td>添加注释信息</td></tr><tr><td>–complete-insert</td><td></td><td>输出完成的插入语句</td></tr><tr><td>–lock-tables</td><td></td><td>备份前，锁定所有数据库表</td></tr><tr><td>–no-create-db/–no-create-info</td><td></td><td>禁止生成创建数据库语句</td></tr><tr><td>–force</td><td></td><td>当出现错误时仍然继续备份操作</td></tr><tr><td>–default-character-set</td><td></td><td>指定默认字符集</td></tr><tr><td>–add-locks</td><td></td><td>备份数据库表时锁定数据库表</td></tr></tbody></table><h3 id="2、导入数据库"><a href="#2、导入数据库" class="headerlink" title="2、导入数据库"></a>2、导入数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i  com_mysql mysqldump -c -uroot -p123456    app_agent  &lt;  app_agent.sql</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -i  com_mysql【docker容器名称/ID】 mysqltest_db_copy【数据库名称】 &lt; /opt/sql_bak/test_db.sql【本地数据表路径】</span><br></pre></td></tr></table></figure><p>注意：这里需要将参数 -it 更换为 -i ，<br>否则会报错：”the input device is not a TTY”</p><p>借鉴于原文：<a href="https://blog.csdn.net/qq_27565769/article/details/80731271" target="_blank" rel="noopener">https://blog.csdn.net/qq_27565769/article/details/80731271</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、mysqldump导出备份&quot;&gt;&lt;a href=&quot;#1、mysqldump导出备份&quot; class=&quot;headerlink&quot; title=&quot;1、mysqldump导出备份&quot;&gt;&lt;/a&gt;1、mysqldump导出备份&lt;/h3&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker容器以ROOT账号登录（获取ROOT权限/ROOT密码）</title>
    <link href="https://yzdzh.github.io/post/3568385113.html"/>
    <id>https://yzdzh.github.io/post/3568385113.html</id>
    <published>2021-12-03T18:27:00.000Z</published>
    <updated>2021-12-03T18:28:29.228Z</updated>
    
    <content type="html"><![CDATA[<h6 id="第一步：查看容器的CONTAINER-ID"><a href="#第一步：查看容器的CONTAINER-ID" class="headerlink" title="第一步：查看容器的CONTAINER ID"></a>第一步：查看容器的CONTAINER ID</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h6 id="第二步：获取root权限，例如需要进入的CONTAINER-ID为4650e8d1bcca"><a href="#第二步：获取root权限，例如需要进入的CONTAINER-ID为4650e8d1bcca" class="headerlink" title="第二步：获取root权限，例如需要进入的CONTAINER ID为4650e8d1bcca"></a>第二步：获取root权限，例如需要进入的CONTAINER ID为4650e8d1bcca</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u root 4650e8d1bcca bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;第一步：查看容器的CONTAINER-ID&quot;&gt;&lt;a href=&quot;#第一步：查看容器的CONTAINER-ID&quot; class=&quot;headerlink&quot; title=&quot;第一步：查看容器的CONTAINER ID&quot;&gt;&lt;/a&gt;第一步：查看容器的CONTAINER ID&lt;/
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>ssh生成公钥私钥对和远程免密登录</title>
    <link href="https://yzdzh.github.io/post/588796899.html"/>
    <id>https://yzdzh.github.io/post/588796899.html</id>
    <published>2021-11-07T19:38:00.000Z</published>
    <updated>2021-11-07T19:41:39.458Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、在本地机器上使用ssh-keygen产生公钥私钥对"><a href="#1、在本地机器上使用ssh-keygen产生公钥私钥对" class="headerlink" title="1、在本地机器上使用ssh-keygen产生公钥私钥对"></a>1、在本地机器上使用ssh-keygen产生公钥私钥对</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本地先安装git客户端，终端执行</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"yourname"</span></span><br><span class="line">一路回车</span><br><span class="line"></span><br><span class="line">全局设置git 用户信息</span><br><span class="line">git config --global user.email yourname</span><br><span class="line">git config --global user.name yourname</span><br><span class="line"></span><br><span class="line">chmod 600 ~/.ssh/id_rsa  ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h5 id="2、用ssh-copy-id将公钥复制到远程机器中"><a href="#2、用ssh-copy-id将公钥复制到远程机器中" class="headerlink" title="2、用ssh-copy-id将公钥复制到远程机器中"></a>2、用ssh-copy-id将公钥复制到远程机器中</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_rsa.pub  用户名字@192.168.x.xxx</span><br><span class="line"></span><br><span class="line">注意: ssh-copy-id 将key写到远程机器的 ~/ .ssh/authorized_key.文件中</span><br></pre></td></tr></table></figure><h5 id="3、登录到远程机器不用输入密码"><a href="#3、登录到远程机器不用输入密码" class="headerlink" title="3、登录到远程机器不用输入密码"></a>3、登录到远程机器不用输入密码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名字@192.168.x.xxx</span><br><span class="line">Last login: Sun Nov 16 17:22:33 2008 from 192.168.1.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1、在本地机器上使用ssh-keygen产生公钥私钥对&quot;&gt;&lt;a href=&quot;#1、在本地机器上使用ssh-keygen产生公钥私钥对&quot; class=&quot;headerlink&quot; title=&quot;1、在本地机器上使用ssh-keygen产生公钥私钥对&quot;&gt;&lt;/a&gt;1、在本地
      
    
    </summary>
    
    
      <category term="linux" scheme="https://yzdzh.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下清除docker容器终端输出的全部日志</title>
    <link href="https://yzdzh.github.io/post/3848110738.html"/>
    <id>https://yzdzh.github.io/post/3848110738.html</id>
    <published>2021-11-07T12:33:00.000Z</published>
    <updated>2021-11-07T12:43:11.240Z</updated>
    
    <content type="html"><![CDATA[<p>查询当前目录下所有文件大小  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure><p>查询当前目录下所有文件大小  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh</span><br></pre></td></tr></table></figure><p>清除docker容器终端输出的全部日志  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate -s 0 /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查询当前目录下所有文件大小  &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="linux" scheme="https://yzdzh.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>win10开机设置wsl子系统固定内网ip</title>
    <link href="https://yzdzh.github.io/post/3748404520.html"/>
    <id>https://yzdzh.github.io/post/3748404520.html</id>
    <published>2021-10-27T18:54:00.000Z</published>
    <updated>2021-10-27T19:14:41.564Z</updated>
    
    <content type="html"><![CDATA[<p>wsl的liunx子系统虽然很优秀，但是每次重启都会重新分配内网ip，但实际开发中，本地环境还是需要固定内网ip比较方便，但是wsl不支持设置固定内网ip，折中办法就是每次开机或重启是将内网ip设置为指定ip。</p><h3 id="1、自制bat脚本"><a href="#1、自制bat脚本" class="headerlink" title="1、自制bat脚本"></a>1、自制bat脚本</h3><p>将下面的命令复制到.bat后缀的文件中，如fix_wsl_ip.bat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">:: 获取管理员权限</span><br><span class="line">setlocal</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> uac=~uac_permission_tmp_%random%</span><br><span class="line"></span><br><span class="line">md <span class="string">"%SystemRoot%\system32\%uac%"</span> 2&gt;nul</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> %errorlevel%==0 ( rd <span class="string">"%SystemRoot%\system32\%uac%"</span> &gt;nul 2&gt;nul ) <span class="keyword">else</span> (</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="built_in">set</span> uac = CreateObject^(<span class="string">"Shell.Application"</span>^)&gt;<span class="string">"%temp%\%uac%.vbs"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> uac.ShellExecute <span class="string">"%~s0"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">"runas"</span>,1 &gt;&gt;<span class="string">"%temp%\%uac%.vbs"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> WScript.Quit &gt;&gt;<span class="string">"%temp%\%uac%.vbs"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"%temp%\%uac%.vbs"</span> /f</span><br><span class="line"></span><br><span class="line">    del /f /q <span class="string">"%temp%\%uac%.vbs"</span> &amp; <span class="built_in">exit</span> )</span><br><span class="line"></span><br><span class="line">endlocal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给wsl 中的ubuntu 设置ipv4 的ip 192.168.33.10，要在windows中访问wsl就用此ip</span></span><br><span class="line">wsl -d Ubuntu-20.04 -u root ip addr add 192.168.33.10/24 broadcast 192.168.33.255 dev eth0 label eth0:1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给windows 设置ipv4 的ip 192.168.33.11，要在wsl中访问宿主机就用此ip</span></span><br><span class="line">netsh interface ip add address <span class="string">"vEthernet (WSL)"</span> 192.168.33.11 255.255.255.0</span><br></pre></td></tr></table></figure><p>注意的是bat中的给wsl中的ubuntu设置固定ip中的Ubuntu-20.04为ubuntu的版本名称，具体版本名可以直接wsl -l命令查询，如图：</p><p><img src="/resource/images/pasted2-6.png" alt="upload successful"></p><h3 id="2、查看win10宿主机和子系统是否ip设置成功"><a href="#2、查看win10宿主机和子系统是否ip设置成功" class="headerlink" title="2、查看win10宿主机和子系统是否ip设置成功"></a>2、查看win10宿主机和子系统是否ip设置成功</h3><p>右键管理员运行bat文件（一定要管理员权限运行！），然后查看是否设置成功。</p><p><img src="/resource/images/pasted2-9.png" alt="upload successful"></p><p><img src="/resource/images/pasted2-10.png" alt="upload successful"></p><h3 id="3、设置bat脚本开机自动启动"><a href="#3、设置bat脚本开机自动启动" class="headerlink" title="3、设置bat脚本开机自动启动"></a>3、设置bat脚本开机自动启动</h3><p>1、设置bat脚本开机自动启动”窗口+R”打开命令窗口，并且输入命令<strong>Shell:startup</strong>，点击确定按钮运行该命令<br>2、将自制的bat启动脚本快捷方式放入文件夹中</p><p><img src="/resource/images/pasted2-7.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;wsl的liunx子系统虽然很优秀，但是每次重启都会重新分配内网ip，但实际开发中，本地环境还是需要固定内网ip比较方便，但是wsl不支持设置固定内网ip，折中办法就是每次开机或重启是将内网ip设置为指定ip。&lt;/p&gt;
&lt;h3 id=&quot;1、自制bat脚本&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="wsl" scheme="https://yzdzh.github.io/categories/wsl/"/>
    
    
  </entry>
  
  <entry>
    <title>WSL子系统修改默认root登入</title>
    <link href="https://yzdzh.github.io/post/2798337741.html"/>
    <id>https://yzdzh.github.io/post/2798337741.html</id>
    <published>2021-10-21T19:13:00.000Z</published>
    <updated>2021-10-21T19:15:25.243Z</updated>
    
    <content type="html"><![CDATA[<p>一般子系统就是自己用，每次启动还要人工切到root权限，很是麻烦，如何让Win10的WSL子系统默认root登入呢？</p><h5 id="命令行操作方法如下："><a href="#命令行操作方法如下：" class="headerlink" title="命令行操作方法如下："></a>命令行操作方法如下：</h5><p>1、Windows进入cmd命令行，执行指令进入Apps目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> %HOMEPATH%\AppData\Local\Microsoft\WindowsApps</span><br></pre></td></tr></table></figure><p>2、执行指令列出文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>3、进入定位的子系统文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>4、执行指令列出文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2004.exe</span><br></pre></td></tr></table></figure><p>5、执行指令修改默认用户为root：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure><p>6、重启WSL子系统即可看到效果，默认登入的就是root账户了。</p><p>原文链接：<a href="https://shipengliang.com/software-exp/win10-wsl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%85%A5.html" target="_blank" rel="noopener">https://shipengliang.com/software-exp/win10-wsl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%85%A5.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般子系统就是自己用，每次启动还要人工切到root权限，很是麻烦，如何让Win10的WSL子系统默认root登入呢？&lt;/p&gt;
&lt;h5 id=&quot;命令行操作方法如下：&quot;&gt;&lt;a href=&quot;#命令行操作方法如下：&quot; class=&quot;headerlink&quot; title=&quot;命令行操作方
      
    
    </summary>
    
    
      <category term="wsl" scheme="https://yzdzh.github.io/categories/wsl/"/>
    
    
  </entry>
  
  <entry>
    <title>基于win10 + wsl + ubuntu + terminal的本地开发环境</title>
    <link href="https://yzdzh.github.io/post/2270783465.html"/>
    <id>https://yzdzh.github.io/post/2270783465.html</id>
    <published>2021-10-19T20:13:00.000Z</published>
    <updated>2021-10-27T19:09:50.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先来一堆废话背景介绍："><a href="#先来一堆废话背景介绍：" class="headerlink" title="先来一堆废话背景介绍："></a><strong>先来一堆废话背景介绍：</strong></h3><p>之前都是使用vagrant+VirtualBox做为本地开发环境，一直也都是挺不错的，后来在新公司认识到win10 + wsl + ubuntu + terminal的开发环境，相较起vagrant+VirtualBox，优势和劣势如下：<br><strong>优势：</strong><br>1、可以直接将项目代码放入linux环境，而不是通过目录映射的方式。目录映射一方面代码编译速度慢，另一方面有可能会出现因为window和linux环境文件编码不同而导致的编译失败问题（这点本人在执行compose等操作时曾经吃过亏）。<br>2、hosts文件和.ssh文件夹可实现自动共享，不用本地定义个域名要window写一次，虚拟机里面的hosts文件也写一份。</p><p><strong>劣势：</strong><br>1、代码是放在子系统虚拟机中的，如果子系统突然奔溃修复不了的话很可能会导致代码没及时上传git而丢失白写的情况。所以需要养成每天下班前上传代码的好习惯。<br>2、占用内存大，本人实际开发中实际占内存10GB多点，加上其它开发软件，占了19GB左右（幸亏公司电脑内存是32GB）。</p><h3 id="环境搭建流程："><a href="#环境搭建流程：" class="headerlink" title="环境搭建流程："></a><strong>环境搭建流程：</strong></h3><h4 id="1-打开“Linux-子系统”与“虚拟机平台”"><a href="#1-打开“Linux-子系统”与“虚拟机平台”" class="headerlink" title="1. 打开“Linux 子系统”与“虚拟机平台”"></a>1. 打开“Linux 子系统”与“虚拟机平台”</h4><p><img src="/resource/images/pasted2-5.png" alt="upload successful"><br>选中上图圈出的两个项目，点击“确定”。</p><p>或者，也可以通过命令行操作。以管理员身份执行 CMD 或 PowerShell，执行如下两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable</span>-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable</span>-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><h4 id="2-安装-WSL-内核"><a href="#2-安装-WSL-内核" class="headerlink" title="2. 安装 WSL 内核"></a>2. 安装 WSL 内核</h4><p>点击下面的按钮从微软下载最新的 x64 或 arm64 WSL 内核：<br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" target="_blank" rel="noopener">最新版 x64 WSL 2 内核</a><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi" target="_blank" rel="noopener">最新版 arm64 wsl 2 内核</a></p><p>下载并安装 MSI 包即可。</p><h4 id="3-设置-WSL-默认版本为-2"><a href="#3-设置-WSL-默认版本为-2" class="headerlink" title="3. 设置 WSL 默认版本为 2"></a>3. 设置 WSL 默认版本为 2</h4><p>打开 CMD 或 PowerShell，执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version 2</span><br></pre></td></tr></table></figure><h4 id="4-安装ubuntu-和-terminal"><a href="#4-安装ubuntu-和-terminal" class="headerlink" title="4.安装ubuntu 和 terminal"></a>4.安装ubuntu 和 terminal</h4><p>直接从Microsoft store商店直接搜索下载即可，建议ubuntu版本为20.04或以上。</p><h4 id="5-安装docker"><a href="#5-安装docker" class="headerlink" title="5.安装docker"></a>5.安装docker</h4><p>直接下载安装即可（建议版本为4.1）<br><a href="https://docs.docker.com/docker-for-windows/release-notes/#docker-desktop-310" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/release-notes/#docker-desktop-310</a></p><p>至此，虚拟机环境搭建完毕。  </p><p><strong>注意必看：</strong><br>1、ubuntu默认是安装时创建的账号，非root账号，这给开发带来不便，如何设置默认root登入可以看我另一篇文章： <a href="/post/2798337741.html" target="_blank">WSL子系统修改默认root登入</a></p><p>2、wsl内子系统的ip每次启动都会重置，这给开发带来不便，如何解决这个问题可以看我另一篇文章： <a href="/post/3748404520.html" target="_blank">win10开机设置wsl子系统固定内网ip</a></p><p>3、鄙人本地的lnmp环境是使用的是docker-compose.yaml一键安装及配置文件和目录挂载，git地址为(私人仓库不对外开放)：<a href="https://github.com/yzdzh/docker_php_dev" target="_blank" rel="noopener">https://github.com/yzdzh/docker_php_dev</a></p><p>4.安装docker-compose命令如下:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1). 下载docker-compose</span><br><span class="line">curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.28.3/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose  </span><br><span class="line">(2). 修改执行权限</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先来一堆废话背景介绍：&quot;&gt;&lt;a href=&quot;#先来一堆废话背景介绍：&quot; class=&quot;headerlink&quot; title=&quot;先来一堆废话背景介绍：&quot;&gt;&lt;/a&gt;&lt;strong&gt;先来一堆废话背景介绍：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;之前都是使用vagrant+Vir
      
    
    </summary>
    
    
      <category term="wsl" scheme="https://yzdzh.github.io/categories/wsl/"/>
    
    
  </entry>
  
  <entry>
    <title>docker安装软件环境集合</title>
    <link href="https://yzdzh.github.io/post/527254571.html"/>
    <id>https://yzdzh.github.io/post/527254571.html</id>
    <published>2021-04-26T16:15:00.000Z</published>
    <updated>2021-07-17T03:30:36.282Z</updated>
    
    <content type="html"><![CDATA[<p>有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。</p><h3 id="1、hexo（私有仓库，不提供开放）"><a href="#1、hexo（私有仓库，不提供开放）" class="headerlink" title="1、hexo（私有仓库，不提供开放）"></a>1、hexo（私有仓库，不提供开放）</h3><p>本人私有博客打包，仅做个人笔记记录，不提供开放</p><p>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>2、创建启动容器<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hexo -it  -p 4000:4000 -w /home/wwwroot/hexo -v /home/wwwroot/hexo:/home/wwwroot/hexo  --entrypoint=<span class="string">"/home/wwwroot/hexo/hexo-sever.sh"</span> yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>  注：<br>   1)、第一次启动容器时需要将hexo-sever.sh中的#npm install解除注释，初始化node_modules</p><h3 id="2、elasticsearch"><a href="#2、elasticsearch" class="headerlink" title="2、elasticsearch"></a>2、elasticsearch</h3><p>基于elasticsearch7.12版本打包，允许跨域操作<br>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yizhidaozuihou/es</span><br></pre></td></tr></table></figure><br>2、创建用户定义的网络（用于连接到连接到同一网络的其他服务（例如，Kibana））<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create somenetwork</span><br></pre></td></tr></table></figure><br>3、创建挂载的目录<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"></span><br><span class="line">//生产环境才需要执行以下命令（挂载配置文件和插件目录）</span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http.host: 0.0.0.0"</span> &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">/mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">//需要设置挂载目录可读写权限，不然docker容器启动不了</span><br><span class="line">chmod -R 777 mydata/elasticsearch/</span><br></pre></td></tr></table></figure><br>4、创建容器并启动<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//测试环境docker（直接挂载数据库就行了）</span><br><span class="line">docker run -d --name es --net somenetwork -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span>  -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data yizhidaozuihou/es</span><br><span class="line"></span><br><span class="line">//生产环境docker(需要挂载配置文件和插件目录)</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300  -e <span class="string">"discovery.type=single-node"</span> -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span><br></pre></td></tr></table></figure><br>其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件，如ik，而数据挂载需要权限，需要设置data文件的权限为可读可写,需要下边的指令。<br>chmod -R 777 要修改的路径</p><p>-e “discovery.type=single-node” 设置为单节点<br>特别注意：<br>-e ES_JAVA_OPTS=”-Xms256m -Xmx256m” \ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES</p><h3 id="3、elasticsearch-head"><a href="#3、elasticsearch-head" class="headerlink" title="3、elasticsearch-head"></a>3、elasticsearch-head</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//基于elasticsearch-head5版本打包，兼容elasticsearch7.X版本</span><br><span class="line">docker pull yizhidaozuihou/es-head</span><br><span class="line">docker run  -d --name es-head -p 9100:9100 yizhidaozuihou/es-head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。&lt;/p&gt;
&lt;h3 id=&quot;1、hexo（私有仓库，不提供开放）&quot;&gt;&lt;a href=&quot;#1、hexo（私有仓库，不提供开
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker打包自定义镜像并上传docker hub</title>
    <link href="https://yzdzh.github.io/post/1624279696.html"/>
    <id>https://yzdzh.github.io/post/1624279696.html</id>
    <published>2021-04-26T08:05:00.000Z</published>
    <updated>2021-04-27T01:33:41.867Z</updated>
    
    <content type="html"><![CDATA[<h6 id="docker打包自定义镜像并上传docker-hub"><a href="#docker打包自定义镜像并上传docker-hub" class="headerlink" title="docker打包自定义镜像并上传docker hub"></a>docker打包自定义镜像并上传docker hub</h6><p>1、使用dockers commit命令来打包</p><p>dockers commit 容器名 要保存成的镜像名：版本名（若没有：版本名则直接默认为latest）<br>例如 docker commit vser vs:v1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 49ba413b3614 es</span><br></pre></td></tr></table></figure><p>2、将刚刚commit 的镜像名 打包成特定的格式。例如：<br>docker tag vs:v1 你docker的用户名/你dockerhub上创建的仓库名：版本号 （若无则默认为latest）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag es:v1 yizhidaozuihou/es</span><br></pre></td></tr></table></figure><p>3、打包好后, 将镜像拉取到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker push yizhidaozuihou/es</span><br><span class="line">注：如果未登录docker hub的话是不能push上传的，需要先 docker login 命令输入账号密码登录后才能push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;docker打包自定义镜像并上传docker-hub&quot;&gt;&lt;a href=&quot;#docker打包自定义镜像并上传docker-hub&quot; class=&quot;headerlink&quot; title=&quot;docker打包自定义镜像并上传docker hub&quot;&gt;&lt;/a&gt;docker打包
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>phpstrom实用插件集合</title>
    <link href="https://yzdzh.github.io/post/1452351953.html"/>
    <id>https://yzdzh.github.io/post/1452351953.html</id>
    <published>2021-01-30T18:02:00.000Z</published>
    <updated>2021-09-24T03:01:03.125Z</updated>
    
    <content type="html"><![CDATA[<p>以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。</p><h3 id="1、中英文转换：translation"><a href="#1、中英文转换：translation" class="headerlink" title="1、中英文转换：translation"></a>1、中英文转换：translation</h3><pre><code>快捷键 Ctrl+Shift+Y   OR 选中需要翻译的文本，然后鼠标右键选择Translate</code></pre><h3 id="2、拼写法转换：camelCase"><a href="#2、拼写法转换：camelCase" class="headerlink" title="2、拼写法转换：camelCase"></a>2、拼写法转换：camelCase</h3><pre><code>选中需要改变的变量  使用  快捷键 shift + alt + u ，变量就会改变，直到找到需要的格式。</code></pre><h3 id="3、php-注释增强工具：PHP-Annotation"><a href="#3、php-注释增强工具：PHP-Annotation" class="headerlink" title="3、php 注释增强工具：PHP Annotation"></a>3、php 注释增强工具：PHP Annotation</h3><pre><code>可以自动提示补全注解名和点击跳转追踪</code></pre><h3 id="4、自动关联数组键输入和完成：deep-assoc-completion"><a href="#4、自动关联数组键输入和完成：deep-assoc-completion" class="headerlink" title="4、自动关联数组键输入和完成：deep-assoc-completion"></a>4、自动关联数组键输入和完成：deep-assoc-completion</h3><pre><code>帮助完成数组参数 - 可以使用哪些键</code></pre><h3 id="5、proto语法高亮追踪提示：Protocol-Buffers"><a href="#5、proto语法高亮追踪提示：Protocol-Buffers" class="headerlink" title="5、proto语法高亮追踪提示：Protocol Buffers"></a>5、proto语法高亮追踪提示：Protocol Buffers</h3><pre><code>proto语法高亮追踪提示，临时看其他项目不想安装依赖包时使用</code></pre><h3 id="6、Chinese-​-Simplified-​-Language-Pack-中文语言包"><a href="#6、Chinese-​-Simplified-​-Language-Pack-中文语言包" class="headerlink" title="6、Chinese ​(Simplified)​ Language Pack / 中文语言包"></a>6、Chinese ​(Simplified)​ Language Pack / 中文语言包</h3><pre><code>中文语言汉化包</code></pre><h3 id="7、无限重置有效期插件：IDE-Eval-Reset"><a href="#7、无限重置有效期插件：IDE-Eval-Reset" class="headerlink" title="7、无限重置有效期插件：IDE Eval Reset"></a>7、无限重置有效期插件：IDE Eval Reset</h3><pre><code>需要先添加第三方仓库地址：https://plugins.zhile.io</code></pre><p><img src="/resource/images/pasted2-2.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。&lt;/p&gt;
&lt;h3 id=&quot;1、中英文转换：translation&quot;&gt;&lt;a href=&quot;#1、中英文转换：translation&quot; class=&quot;headerlink&quot; title=&quot;1、中英文转换：t
      
    
    </summary>
    
    
      <category term="phpStorm" scheme="https://yzdzh.github.io/categories/phpStorm/"/>
    
    
  </entry>
  
  <entry>
    <title>php获取指定前缀常量便捷操作方法</title>
    <link href="https://yzdzh.github.io/post/4113924384.html"/>
    <id>https://yzdzh.github.io/post/4113924384.html</id>
    <published>2020-09-03T04:04:00.000Z</published>
    <updated>2021-09-03T06:04:31.384Z</updated>
    
    <content type="html"><![CDATA[<p>例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 </p><p>1、在model中定义的字段类型规范如下order_status字段的常量前缀都是ORDER_STATUS_，常量内容都是：[值，中文解释]</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅为示例代码，实际三个封装方法可以直接放在基础类BaseModel里面所有model公用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">extends</span> <span class="title">BaseModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> int 订单类型 */</span></span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_WAITING = [<span class="number">0</span>,<span class="string">'待付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_SUCCESS = [<span class="number">1</span>,<span class="string">'已付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_REFUNDED    = [<span class="number">2</span>,<span class="string">'已退款'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组（返回无指定key的集合的二维数组）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array [[0,'待付款'],[1,'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstDesc</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[] = $v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (结果返回指定key，value字段名的二维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  二维数组，可以指定key和value的字段名 例：[['id'=&gt;0,'name'=&gt;'待付款'],['id'=&gt;1,'name'=&gt;'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstSelect</span><span class="params">(string $key,string $key_field = <span class="string">'id'</span> , string $value_field = <span class="string">'name'</span>)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $const_list = <span class="keyword">self</span>::getConstDesc($key);</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($const_list <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            $desc[] = [</span><br><span class="line">                $key_field=&gt;$v[<span class="number">0</span>]??<span class="number">0</span>,</span><br><span class="line">                $value_field=&gt;$v[<span class="number">1</span>]??<span class="string">''</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (結果返回一维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  一维数组，key为索引第一位数，value为索引第二位数。 例：['key'=&gt;value,0=&gt;'待付款',1=&gt;'已付款']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstPluck</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[$v[<span class="number">0</span>]] = $v[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$getConstDesc = Order::getConstDesc(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstSelect = Order::getConstSelect(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstPluck = Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>(Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>)[$params[<span class="string">'order_status'</span>]]))&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ErrorHelper::FAIL_CODE,<span class="string">'订单类型不存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 &lt;/p&gt;
&lt;p&gt;1、在model中定义的字段类型规范如下order_status字
      
    
    </summary>
    
    
      <category term="php" scheme="https://yzdzh.github.io/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>linux设置开机服务自动启动/关闭自动启动命令</title>
    <link href="https://yzdzh.github.io/post/1924607937.html"/>
    <id>https://yzdzh.github.io/post/1924607937.html</id>
    <published>2020-08-20T10:48:00.000Z</published>
    <updated>2021-08-21T14:18:26.770Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chkconfig --list 显示开机可以自动启动的服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --add *** 添加开机自动启动***服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --del *** 删除开机自动启动***服务</span></span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://blog.csdn.net/weixin_34254823/article/details/92815942" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34254823/article/details/92815942</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="linux" scheme="https://yzdzh.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql开启全部sql日志查询</title>
    <link href="https://yzdzh.github.io/post/2712546463.html"/>
    <id>https://yzdzh.github.io/post/2712546463.html</id>
    <published>2020-08-12T10:11:00.000Z</published>
    <updated>2020-08-12T10:12:36.570Z</updated>
    
    <content type="html"><![CDATA[<p>   本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！</p><h5 id="1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置"><a href="#1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置" class="headerlink" title="1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置"></a>1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">general_log=on</span><br><span class="line"><span class="comment">#自动生成日志 0-不打开  1-打开</span></span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/system_log/mysql_sql.log</span><br></pre></td></tr></table></figure><h5 id="2、重启mysql"><a href="#2、重启mysql" class="headerlink" title="2、重启mysql"></a>2、重启mysql</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h5 id="3、查看日志是否打开"><a href="#3、查看日志是否打开" class="headerlink" title="3、查看日志是否打开"></a>3、查看日志是否打开</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">where</span> Variable_name=<span class="string">"general_log"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！&lt;/p&gt;
&lt;h5 id=&quot;1、打开-my-cnf-配
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://yzdzh.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之捕获异常</title>
    <link href="https://yzdzh.github.io/post/2798837510.html"/>
    <id>https://yzdzh.github.io/post/2798837510.html</id>
    <published>2020-05-22T10:00:00.000Z</published>
    <updated>2020-05-22T10:01:11.239Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统内部错误：捕获错误，并提示。</strong></p><ul><li>使用了defer panic 和recover关键字</li><li>描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理　　</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> errRecover := <span class="built_in">recover</span>(); errRecover != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"errRecover "</span> , errRecover )</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;系统内部错误：捕获错误，并提示。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了defer panic 和recover关键字&lt;/li&gt;
&lt;li&gt;描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理　　&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之基于zap开箱即用日志组件</title>
    <link href="https://yzdzh.github.io/post/816087200.html"/>
    <id>https://yzdzh.github.io/post/816087200.html</id>
    <published>2020-05-19T09:34:00.000Z</published>
    <updated>2020-05-19T09:34:39.935Z</updated>
    
    <content type="html"><![CDATA[<p>logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显:</p><ul><li>优雅的代码框架设计</li><li>使用简单</li><li>组件化的开发思路</li><li>灵活的输出方式</li></ul><p>但是, 性能终究是忍痛舍弃 logrus 的“阿喀琉斯之踵”<br>目前 golang 日志库的大众选择主要集中在: logrus, zap, zerolog. zap 和 zerolog 的性能都是优秀的, 但是从用法习惯上我更倾向于 zap.</p><h3 id="简单介绍-Zap-的使用"><a href="#简单介绍-Zap-的使用" class="headerlink" title="简单介绍 Zap 的使用"></a>简单介绍 Zap 的使用</h3><p>Zap 提供三种不同方式的输出(以 Info为 例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.Info(<span class="string">"hello zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423173.016333,"caller":"test_zap/main.go:28","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infof(<span class="string">"hello %s"</span>, <span class="string">"zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423203.056074,"caller":"test_zap/main.go:29","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infow(<span class="string">"hello zap"</span>, <span class="string">"field1"</span>, <span class="string">"value1"</span>) <span class="comment">//&#123;"level":"info","ts":1576423203.0560799,"caller":"test_zap/main.go:30","msg":"hello zap","field1":"value1"&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们对 logrus 的 key-value 理论比较在意的话, 使用 zap infow 可以完美解决</p><ul><li>Zap 使用起来不便利的地方</li><li>Zap 使用上不能像 logrus 那样开箱即用</li><li>使用者需要自己去组装相关函数</li><li>Zap 同样不提供日志切割的功能, 但是想添加上这个功能没有 logrus 那样便利</li></ul><p>基于这些问题, 我封装了一套开箱即用的日志组件: <a href="https://github.com/yizhidaozuihou/log" target="_blank" rel="noopener">https://github.com/yizhidaozuihou/log</a></p><p>打造 Zap 开箱即用日志组件<br>提供的功能:</p><ul><li>提供的功能: 像 logrus 一样, 全局的 Debug, Info … 函数</li><li>日志分割功能. 默认文件大小1024M，自动压缩, 最大有3个文件备份，备份保存时间7天, 不会打印日志被调用的文文件名和位置</li><li>日志默认会被分成五类文件：debug、info、warn、error、panic 都会打印在xxx.log. xxx.log.Request输出 request log 的地方(如果有需要的话)</li></ul><p>使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/yizhidaozuihou/log</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/yizhidaozuihou/log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// init log</span></span><br><span class="line"><span class="comment">// set absolute path, and level</span></span><br><span class="line"><span class="comment">// set output level</span></span><br><span class="line"><span class="comment">// don't need request log</span></span><br><span class="line"><span class="comment">// set log's caller using logOption</span></span><br><span class="line">log.Init(<span class="string">"./test.log"</span>, log.DebugLevel, <span class="literal">false</span>, log.SetCaller(<span class="literal">true</span>))</span><br><span class="line">log.Info(<span class="string">"hello george log"</span>)</span><br><span class="line"><span class="comment">// flush</span></span><br><span class="line">log.Sync()</span><br><span class="line"><span class="comment">//output: &#123;"level":"info","ts":"2019-12-16T10:37:11.364+0800","caller":"example/example.go:12","msg":"hello george log"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优雅的代码框架设计&lt;/li&gt;
&lt;li&gt;使用简单&lt;/li&gt;
&lt;li&gt;组件化的开发思路&lt;/li&gt;
&lt;li&gt;灵活的输出方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是, 性能终究是忍痛舍弃
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang个人总结好用库集合</title>
    <link href="https://yzdzh.github.io/post/561152273.html"/>
    <id>https://yzdzh.github.io/post/561152273.html</id>
    <published>2020-05-18T18:37:00.000Z</published>
    <updated>2021-07-17T02:42:51.842Z</updated>
    
    <content type="html"><![CDATA[<p>以下是个人在实践工作中总结的好用库集合，持续不断更新中。。</p><h3 id="一、json处理库"><a href="#一、json处理库" class="headerlink" title="一、json处理库"></a>一、json处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/3838666233.html target = _blank>http://wangzhuanglin.gitee.io/post/3838666233.html</a></p><h3 id="二、配置文件处理库"><a href="#二、配置文件处理库" class="headerlink" title="二、配置文件处理库"></a>二、配置文件处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/132771847.html target = _blank>http://wangzhuanglin.gitee.io/post/132771847.html</a></p><h3 id="三、日志库"><a href="#三、日志库" class="headerlink" title="三、日志库"></a>三、日志库</h3><p><a href=http://wangzhuanglin.gitee.io/post/816087200.html target = _blank>http://wangzhuanglin.gitee.io/post/816087200.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是个人在实践工作中总结的好用库集合，持续不断更新中。。&lt;/p&gt;
&lt;h3 id=&quot;一、json处理库&quot;&gt;&lt;a href=&quot;#一、json处理库&quot; class=&quot;headerlink&quot; title=&quot;一、json处理库&quot;&gt;&lt;/a&gt;一、json处理库&lt;/h3&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之viper操作库</title>
    <link href="https://yzdzh.github.io/post/132771847.html"/>
    <id>https://yzdzh.github.io/post/132771847.html</id>
    <published>2020-05-18T08:58:00.000Z</published>
    <updated>2020-05-18T08:58:47.364Z</updated>
    
    <content type="html"><![CDATA[<p>Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。</p><p>这里记录下viper读取.env配置文件的具体代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">".env"</span>) <span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigType(<span class="string">"env"</span>) <span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"./"</span>)   <span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">err12 := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err12 != <span class="literal">nil</span> &#123; <span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Fatal error config file: %s \n"</span>, err12))</span><br><span class="line">&#125;</span><br><span class="line">viper.SetDefault(<span class="string">"DB_DRIVER"</span>,<span class="number">55555</span>)</span><br><span class="line">fmt.Println(<span class="number">777</span>,viper.GetString(<span class="string">"DB_DRIVER"</span>))</span><br></pre></td></tr></table></figure><p>其他详细教程可以直接看go大神写的详细文章<br><a href="https://www.liwenzhou.com/posts/Go/viper_tutorial/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/viper_tutorial/</a><br><a href="https://learnku.com/articles/33908" target="_blank" rel="noopener">https://learnku.com/articles/33908</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。&lt;/p&gt;
&lt;p&gt;这里记录下viper读取.env配置文件的具体代码&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang库集合</title>
    <link href="https://yzdzh.github.io/post/3243567407.html"/>
    <id>https://yzdzh.github.io/post/3243567407.html</id>
    <published>2020-05-13T15:25:00.000Z</published>
    <updated>2020-05-13T15:39:52.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="golang用于创建和发送电子邮件的库"><a href="#golang用于创建和发送电子邮件的库" class="headerlink" title="golang用于创建和发送电子邮件的库"></a>golang用于创建和发送电子邮件的库</h3><p>douceur - HTML 邮件中的内联 CSS<br>email - 一个健壮的、灵活的 email 库<br>Go-dkim - DKIM 库，用于对 email 进行签名和验证<br>Go-imap - IMAP 库，用于客户端和服务器<br>Go-message - 用于触雷互联网消息格式和邮件的库<br>Gomail - Gomail 是一个非常简单且强大的库，用于发送电子邮件<br>Hectane - 轻量级 SMTP 客户端，提供 HTTP API<br>hermes - 一个用于生成干净、响应式 HTML e-mail 的包<br>MailHog - Email 及 SMTP 测试工具，具有 web 及 API 接口<br>SendGrid - SendGrid 的 Go 语言库，用于发送电子邮件<br>smtp - SMTP 服务器协议状态机  </p><h3 id="golang处理日期和时间的库"><a href="#golang处理日期和时间的库" class="headerlink" title="golang处理日期和时间的库"></a>golang处理日期和时间的库</h3><p>carbon - 简单的时间扩展程序，有很多有用的方法，是 PHP Carbon 库的接口<br>durafmt - 持续时间格式化<br>feiertage - 一组计算德国公共假期的函数，比如复活节、感恩节等<br>Go-persian-calendar - 太阳历<br>Goweek - 处理星期的库<br>now - Now 是一个 Go 语言的时间工具集<br>NullTime -时间可以是 NULL 的库<br>timeutil - 为 Go 语言时间包扩展了有用的功能，例如时间间隔和格式化  </p><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>darwin - 数据库模式进化库<br>Go-fixtures - 类似 DjanGo fixtures，用于 Golang 的內建数据库/sql 库<br>Goose - 数据库迁移工具。你可以通过编写增量 SQL 或 Go 语言脚本来管理你的数据库<br>Gormigrate - 数据库模式迁移帮助工具，用于 Gorm ORM.<br>migrate - 数据库迁移。命令行及 Go 语言库<br>pravasan - 简单的迁移，目前支持 MySQL 但是近期打算支持 Postgres, SQLite, MonGoDB 等等<br>soda - 数据库迁移、创建、 ORM等等，用于 MySQL, PostgreSQL, 以及 SQLite.<br>sql-migrate - 数据库迁移工具，允许利用 Go-bindata 将数据库迁移嵌入应用程序  </p><h3 id="Go-语言实现的数据库"><a href="#Go-语言实现的数据库" class="headerlink" title="Go 语言实现的数据库"></a>Go 语言实现的数据库</h3><p>BigCache - 为 gigabytes 量级数据设计的高效键/值缓存<br>bolt - 底层键值数据库<br>buntdb - 快速，可嵌入的，内存键值数据库，可定义索引及 spatial<br>cache2Go - 基于内存存储的键值缓存，支持自动基于超时的自动失效<br>cockroach - 可扩展的、一致的事务型数据库<br>couchcache - RESTful 缓存微服务，基于Couchbase<br>dgraph - 可扩展的、分布式的、低延时、高吞吐的图数据库<br>diskv - 具有 disk-backed 功能的持久化键值存储<br>eliasdb - 无依赖、事物型图数据库，支持 REST API、短语搜索以及类 SQL 的查询语言<br>forestdb - ForestDB 的 Go 语言借口<br>GCache - 支持缓存过期、 LFU、 LRU 和 ARC 的缓存库<br>geocache - 基于内存存储的缓存，适用于分布式部署的应用<br>Go-cache - 内存键值存储/缓存库，适用于单机程序<br>Goleveldb - 使用 Go 语言实现的 LevelDB<br>groupcache - Groupcache 是一个缓存及缓存填充库，在很多情况下用于替代 memcached.<br>influxdb - 用于计量、事件及实时分析的、可扩展的数据库<br>ledisdb - Ledisdb 是一个高性能 NoSQL 数据库，类似 Redi<br>leviGo - LeviGo 是 LevelDB的 Go 语言封装<br>moss - Moss 是一个简单的 LSM 键值存储引擎，100% Go 语言实现<br>piladb - 轻量级 RESTful 数据库引擎，基于堆栈结构<br>prometheus - 监控系统及时间序列数据库<br>rqlite - 基于 SQLite 的轻量级的、分布式的关系型数据库<br>Scribble - 小巧的 JSON 文件存储<br>tempdb - 临时数据的键值对存储<br>tidb - TiDB 是一个分布式的 SQL 数据库。受到了 Google F1的启发<br>tiedot - 基于 Go 语言的 NoSQL 数据库<br>Tile38 - 地理位置数据库及实时地理围栏  </p><h3 id="golang通用数据结构及算法"><a href="#golang通用数据结构及算法" class="headerlink" title="golang通用数据结构及算法"></a>golang通用数据结构及算法</h3><p>binpacker - 二进制数据封包拆包工具，帮你构建自定义的二进制数据流<br>bit - Go 语言集合数据结构。提供了额外的位操作功能<br>bitset - 实现了 bitset 的 Go 语言包.<br>bloom - Go 语言实现的布隆过滤器（bloom filter）<br>bloom - Go 语言实现的布隆过滤器<br>boomfilters - 概率统计数据结构，用于处理大量连续的数据。<br>count-min-log - Go 语言实现的 Count-Min-Log sketch 算法(类似 Count-Min sketch 算法，但是使用的内存更少).<br>cuckoofilter - Cuckoo 过滤器：一个用go语言实现的计数布隆过滤器的替代品<br>encoding - 整型压缩库<br>Go-adaptive-radix-tree - Go 语言实现的自适应基数树<br>Go-datastructures - 一组有用的、高性能的、线程安全的数据结构<br>Go-geoindex - 基于内存存储的地理索引<br>Go-rquad - 区域四叉树，支持有效点位置和领域发现<br>Gods - Go 语言数据结构、容器、集合、列表、栈、键值对、 BidiMaps、树、HashSet 等<br>Golang-set - 线程安全和非线程安全的高性能集合<br>Goskiplist - Go 语言实现的跳跃表<br>Gota - 为go语言实现了数据帧，序列以及数据噪音的方法<br>hilbert - 用于映射空间填充曲线（例如希尔伯特曲线和皮亚诺曲线）和数值的库。<br>hyperloglog - HyperLogLog implementation with Sparse, LogLog-Beta bias correction and TailCut space reduction.<br>levenshtein - 编辑距离（levenshtein distance）和相似性度量， 可以自定义编辑代价和and Winkler-like bonus for common prefix.<br>levenshtein - Go 语言实现计算编辑距离<br>mafsa - Go 语言实现的 MA-FSA ，包含最小完美哈希<br>merkletree - 实现了梅克尔树，提供了一种高效、安全的数据结构内容验证方法<br>roaring - 实现了压缩 bitsets 的Go语言库<br>skiplist - Go语言实现的跳跃表<br>trie - Go语言实现的Trie树<br>ttlcache - In-memory LRU string-interface{} map with expiration for Golang<br>willf/bloom - 实现了布隆过滤器的库  </p><h3 id="golang用于进行配置解析的库"><a href="#golang用于进行配置解析的库" class="headerlink" title="golang用于进行配置解析的库"></a>golang用于进行配置解析的库</h3><p>config - JSON 或 YAML 配置的封装，支持环境变量和标记解析<br>configure - 可以通过多种途径进行配置，包括 JSON, 标记位以及环境变量<br>env - 解析环境变量为 Go 语言结构体<br>envcfg - 解析环境变量为 Go 语言结构体<br>envconf - 通过环境变量来配置<br>envconfig - 通过环境变量读取配置<br>gcfg - 读取类 INI 类型的配置文件为 Go 语言结构体，支持自定义变量和节<br>GoConfig - 通过命令行的输入、环境变量、配置文件来初始化一个结构体兵将一个结构体解析为输入<br>Godotenv - Ruby 库 dotenv 的 Go 语言接口 (通过 .env 来获取环境变量)<br>Gofigure - 让 Go 语言应用程序配置变得简单<br>Gone/jconf - 模块化 JSON 配置工具。允许你将配置参数结构体和使用它的代码放在一起，而不需要让主配置文件了解所有子模块的细节来进行序列化<br>hjson - 人性化的 JSON，一个便于程序员使用和阅读的配置文件格式。更加轻松的语法，更少的错误和更多的注释<br>inGo - 将配置标记持久化到一个类似 ini 的文件中<br>ini - 用于读写INI 文件的库<br>joshbetz/config - 消息配置库，可以解析环境变量、JSON 文件并根据SIGHUP自动重新载入<br>mini -用于解析类 ini 文件的库<br>store - 轻量级配置管理<br>viper - 这个库名叫毒蛇 ,Go 语言配置工具<br>xdg -遵守 XDG 标准 的配置工具  </p><h3 id="golang认证和授权库"><a href="#golang认证和授权库" class="headerlink" title="golang认证和授权库"></a>golang认证和授权库</h3><p>authboss - 用于 web 开发的组件化认证授权系统。它尝试尽可能的移除模板代码以及硬编码，这使你每次新建 web 项目的时候，可以做到即插即用、配置并开始开发你的 web 英语，而不必每次都重新创建一个认证授权系统。<br>casbin - 一个支持接入控制模型（例如:ACL,RBAC,ABAC）的授权库<br>Go-AWS-Auth - AWS 请求签名库<br>Go-jose - Fairly complete implementation of the JOSE working group’s JSON Web Token, JSON Web 签名以及JSON Web 加密 specs.<br>Go-oauth2-server - 使用 Go 语言编写的独立、符合标准的 OAuth2 服务器<br>Go.auth - 为 Go 语言 web 应用提供的授权 API.<br>Gologin - 可以串连使用OAuth1 和 OAuth2 认证服务<br>Gorbac - 一个用 Go 语言实现的轻量级RBAC<br>Goth - 提供了一种简洁的、惯用的方式来使用OAuth 和 OAuth2.<br>httpauth - HTTP 认证中间件<br>jwt - 简单易用的一个JSON Web Tokens (JWT)的实现<br>jwt-auth - JWT 为 Go 语言 HTTP 服务器编写的 jwt 中间件，有多种配置选项<br>jwt-Go - Go 语言实现的JSON Web Tokens (JWT).<br>loginsrv - JWT 登录微服务，可以继承OAuth2 (Github), htpasswd, osiam等后端。<br>oauth2 - Goauth2的继承者。 通用 OAuth 2.0 库，集成了对JWT, Google APIs, Compute Engine 和 App Engine的支持.<br>osin - Go 语言 OAuth2 服务器库<br>permissions2 - 用于追踪用户，登录状态和许可的库。使用安全 cookies 和 bcrypt.<br>session - Go 语言会话管理(支持 Google App Engine - GAE)<br>sessions - 为 Go 语言 HTTP 服务器开发的非常简单的、高性能的、高可定制的会话服务<br>traefik - 反向代理和负载均衡库，支持多种后端<br>yubiGo - Yubikey 客户端，提供了用于在 Go 语言应用中集成Yubico   Yubikey 的 API  </p><h3 id="golang用于操作音频的库"><a href="#golang用于操作音频的库" class="headerlink" title="golang用于操作音频的库"></a>golang用于操作音频的库</h3><p>flac - 原生 Go FLAC 解码器<br>flac - 原生 Go FLAC 解码器<br>gaad - 原生 Go AAC 比特流解析器<br>Go-sox - libsox 的 Go 语言接口<br>Go_mediainfo - libmediainfo 的 Go 语言接口<br>Gosamplerate - libsamplerate 的 Go 语言接口<br>id3v2 - 快速且稳定的 ID3 解析及写入库<br>mix - 基于序列的 Go 语言混音器，可用于音乐 app。<br>mp3 - 原生 Go MP3 解码器<br>music-theory - Go 语言编写的音乐理论模型<br>PortAudio - 音频 I/O 库的 Go 语言接口<br>portmidi - PortMidi 的 Go 语言接口<br>taglib - taglib 的 Go 语言接口<br>vorbis - “原生” Go Vorbis 解码器 (使用 CGo, 但是没有其他依赖).<br>waveform - 一个可以通过音频流生成波形图像的包  </p><h3 id="golang代码中嵌入其他语言的包"><a href="#golang代码中嵌入其他语言的包" class="headerlink" title="golang代码中嵌入其他语言的包"></a>golang代码中嵌入其他语言的包</h3><p>aGora - 一种动态类型的可以嵌入 Go 中的编程语言<br>anko - Go 语言编写的解释器<br>binder - Lua 接口, 基于 Gopher-lua<br>gisp - Simple LISP<br>Go-duktape - Duktape JavaScript 引擎的 Go 语言接口<br>Go-lua - Lua 5.2 虚拟机的纯 Go 语言接口<br>Go-php - PHP 的 Go 语言接口<br>Go-python - CPython C-API 的 Go 语言接口<br>Golua - Lua C API。的 Go 语言接口<br>Gopher-lua - Go 语言编写的 Lua 5.1 虚拟机和编译器<br>ngaro - 可嵌入的 Ngaro 虚拟机实现，支持在 Retro 中使用脚步<br>otto - Go 编写的 Javascrip 解释器<br>purl - 嵌入 Go 语言的 Perl 5.18.2  </p><h3 id="go日志库"><a href="#go日志库" class="headerlink" title="go日志库"></a>go日志库</h3><p>glg - glg 是一个简单、快速、分级的日志库<br>glog - 分级记录日志的库<br>Go-cronowriter 对日志文件进行自动循环写入的库基于当前日期和时间，类似 cronolog.<br>Go-log - 支持多处理器及日志分级的库<br>Go-log - Go 语言实现的 Log4j<br>Go-logger - 支持日志分级的简单的日志工具<br>Gologger - 简单易用的日志库，可以在彩色控制台、简易控制的、文件或 Elasticsearch 中记录<br>Gomol - 支持多种输出，结构化的日志模块，可以扩展它的输出<br>Gone/log - 快速、可扩展、全功能、兼容标准库的日志库<br>log - 结构化日志库<br>log - 简单、可配置、可扩展的结构化日志库<br>log-voyage - 全功能日志saas 使用 Go 语言编写<br>log15 - 简单强大的日志库<br>logdump - 支持分级的日志库<br>logex - Go 语言日志库，支持追踪和分级，基于标准库进行了封装<br>logger - 一个极简的日志库<br>logrus - 支持结构化的日志工具.<br>logrusly - logrus 的插件，用于将错误发送到 Loggly.<br>logutils - 对 Go 语言标准日志工具进行了扩展，使其更好用<br>logxi - 十二要素 app 日志工具，非常快速，令你开心<br>lumberjack - 简单的循环日志工具，实现了 io.WriteCloser.<br>mlog - 一个简单的日志模块，可以分5级并有一个可选的循环日志文件记录功能，支持 stdout/stderr 输出.<br>ozzo-log - 高性能日志库，支持日志严重级别、分类及过滤。可以将过滤后的信息发送到不同的目的地(例如： 控制台、网络、邮箱).<br>seelog - 一个灵活的、解耦的、格式化的日志库<br>slf - 简单日志门面（The Structured Logging Facade (SLF) ） (类似 SLF4J，但是它是结构化的，并且专为 Go 语言设计)<br>slog - 为 Go 语言实现的结构化日志门面（Structured Logging Facade (SLF) ）<br>spew - 为 Go 语言的数据结构实现了一个整洁的打印功能，有助于调试<br>stdlog - Stdlog 是一个面向对象的库，提供了分级日志功能，对于定时任务很有用.<br>tail - 这个 Go 语言软件包力争模拟 BSD tail 的功能<br>xlog - 插件架构以及灵活的日志系统，具有日志等级控制，多日志目标以及自定义日志格式功能<br>xlog - 结构化日志 for net/context aware HTTP handlers ，可以灵活的分发<br>zap - 快速的、结构化的、分级的日志库<br>zerolog - 零分配 JSON 日志.  </p><h3 id="golang操作表单的库"><a href="#golang操作表单的库" class="headerlink" title="golang操作表单的库"></a>golang操作表单的库</h3><p>bind - 将表单数据绑定到任意的 Go 变量上<br>binding - 将来自 net/HTTP 请求的表单、JSON 数据绑定到结构体<br>conform - 检查用户输入并基于结构标签来清理数据<br>form - 解码 url 中的数据到 Go 语言变量中以及将 Go 语言变量编码进 url 支持Dual Array 及 Full map<br>formam - 将表单数据解码到结构体<br>forms - 框架无关的表单/JSON数据解析验证库，支持多部分表单及文件<br>Gorilla/csrf - 为 Go 语言 web 应用提供 CSRF 防御<br>nosurf - CSRF 防御中间件  </p><h3 id="Go实现消息系统的库"><a href="#Go实现消息系统的库" class="headerlink" title="Go实现消息系统的库"></a>Go实现消息系统的库</h3><p>CentrifuGo - 实时消息服务器<br>dbus - D-Bus的 Go 语言接口<br>drone-line - 通过软件包，docker 或是 Drone CI来发送 Line 通知<br>emitter - 通过Go语言的方式发送事件消息，可以使用通配符，断言，取消发送等优秀特性<br>EventBus - 轻量级事件库，支持异步<br>gaurun-client - Go 语言编写的 Gaurun 客户端<br>Glue - 健壮的 Go 和 Javascript Socket 库 (可以用来替代 Socket.io).<br>Go-longpoll - 支持长轮询的发布与订阅<br>Go-notify - 原生实现的桌面通知规范<br>Go-nsq - NSQ 官方 Go 语言库<br>Go-socket.io - Go 语言的 socket.io库 ,一个实时应用框架.<br>Go-vitotrol - Viessmann Vitotrol 服务的 Go 语言客户端<br>Gollum - 一个 n:m 的多路复用器，从不同的源汇聚消息并向目标进行广播<br>Golongpoll - HTTP 长轮询服务器库，让 web 发布与订阅变的更简单.<br>Goose - Go 语言实现的服务器端事件发送<br>Gopush-cluster - Gopush-cluster 是一个 Go 语言实现的支持集群的comet服务（支持 websocket，和tcp协议）<br>Gorush - 通知推送服务器，使用 APNs2 和 Google GCM.<br>guble - 一个使用通知推送(Google Firebase Cloud Messaging, Apple Push Notification services, SMS)、websockets 、REST API 的消息服务器。提供了分布式操作和消息持久化特性<br>machinery - 异步任务队列，基于分布式消息处理<br>manGos - 纯 Go 语言实现的 Nanomsg (“Scalable Protocols”)<br>melody - 用于处理 websocket 会话的一个极简框架，包括广播和自动 ping/pong 处理<br>NATS Go Client - 轻量级高性能发布订阅(publish-subscribe) 以及分布式消息队列系统，这个一个Go语言库.<br>nsq-event-bus - 针对 NSQ 的主题和频道进行了简单的封装<br>oplog - 原生的 oplog/replication 系统，用于 REST APIs<br>pubsub - 一个简单的 pubsub 软件包<br>RapidMQ - RapidMQ 是一个轻量级，可靠的本地消息队列管理库<br>sarama - 用于 Apache Kafka 的库<br>Uniqush-Push - 基于 Redis 的统一推服务，用于服务器端向移动客户端推送消息<br>zmq4 - ZeroMQ version 4的 GO 语言接口。也有适用于version 3 及 version 2的  </p><p>最后还有github上的类库大全：<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;golang用于创建和发送电子邮件的库&quot;&gt;&lt;a href=&quot;#golang用于创建和发送电子邮件的库&quot; class=&quot;headerlink&quot; title=&quot;golang用于创建和发送电子邮件的库&quot;&gt;&lt;/a&gt;golang用于创建和发送电子邮件的库&lt;/h3&gt;&lt;p&gt;do
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
</feed>
