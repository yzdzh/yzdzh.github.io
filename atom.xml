<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光的博客</title>
  
  <subtitle>php后端工程师，兼职前端和go开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yzdzh.github.io/"/>
  <updated>2021-10-21T19:15:25.243Z</updated>
  <id>https://yzdzh.github.io/</id>
  
  <author>
    <name>xingguang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSL子系统修改默认root登入</title>
    <link href="https://yzdzh.github.io/post/2798337741.html"/>
    <id>https://yzdzh.github.io/post/2798337741.html</id>
    <published>2021-10-21T19:13:00.000Z</published>
    <updated>2021-10-21T19:15:25.243Z</updated>
    
    <content type="html"><![CDATA[<p>一般子系统就是自己用，每次启动还要人工切到root权限，很是麻烦，如何让Win10的WSL子系统默认root登入呢？</p><h5 id="命令行操作方法如下："><a href="#命令行操作方法如下：" class="headerlink" title="命令行操作方法如下："></a>命令行操作方法如下：</h5><p>1、Windows进入cmd命令行，执行指令进入Apps目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> %HOMEPATH%\AppData\Local\Microsoft\WindowsApps</span><br></pre></td></tr></table></figure><p>2、执行指令列出文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>3、进入定位的子系统文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc</span><br></pre></td></tr></table></figure><p>4、执行指令列出文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2004.exe</span><br></pre></td></tr></table></figure><p>5、执行指令修改默认用户为root：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure><p>6、重启WSL子系统即可看到效果，默认登入的就是root账户了。</p><p>原文链接：<a href="https://shipengliang.com/software-exp/win10-wsl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%85%A5.html" target="_blank" rel="noopener">https://shipengliang.com/software-exp/win10-wsl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%85%A5.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般子系统就是自己用，每次启动还要人工切到root权限，很是麻烦，如何让Win10的WSL子系统默认root登入呢？&lt;/p&gt;
&lt;h5 id=&quot;命令行操作方法如下：&quot;&gt;&lt;a href=&quot;#命令行操作方法如下：&quot; class=&quot;headerlink&quot; title=&quot;命令行操作方
      
    
    </summary>
    
    
      <category term="wsl" scheme="https://yzdzh.github.io/categories/wsl/"/>
    
    
  </entry>
  
  <entry>
    <title>基于win10 + wsl + ubuntu + terminal的本地开发环境</title>
    <link href="https://yzdzh.github.io/post/2270783465.html"/>
    <id>https://yzdzh.github.io/post/2270783465.html</id>
    <published>2021-10-19T20:13:00.000Z</published>
    <updated>2021-10-21T18:02:27.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先来一堆废话背景介绍："><a href="#先来一堆废话背景介绍：" class="headerlink" title="先来一堆废话背景介绍："></a><strong>先来一堆废话背景介绍：</strong></h3><p>之前都是使用vagrant+VirtualBox做为本地开发环境，一直也都是挺不错的，后来在新公司认识到win10 + wsl + ubuntu + terminal的开发环境，相较起vagrant+VirtualBox，优势和劣势如下：<br><strong>优势：</strong><br>1、可以直接将项目代码放入linux环境，而不是通过目录映射的方式。目录映射一方面代码编译速度慢，另一方面有可能会出现因为window和linux环境文件编码不同而导致的编译失败问题（这点本人在执行compose等操作时曾经吃过亏）。<br>2、hosts文件和.ssh文件夹可实现自动共享，不用本地定义个域名要window写一次，虚拟机里面的hosts文件也写一份。</p><p><strong>劣势：</strong><br>1、代码是放在子系统虚拟机中的，如果子系统突然奔溃修复不了的话很可能会导致代码没及时上传git而丢失白写的情况。所以需要养成每天下班前上传代码的好习惯。<br>2、占用内存大，本人实际开发中实际占内存10GB多点，加上其它开发软件，占了19GB左右（幸亏公司电脑内存是32GB）。</p><h3 id="环境搭建流程："><a href="#环境搭建流程：" class="headerlink" title="环境搭建流程："></a><strong>环境搭建流程：</strong></h3><h4 id="1-打开“Linux-子系统”与“虚拟机平台”"><a href="#1-打开“Linux-子系统”与“虚拟机平台”" class="headerlink" title="1. 打开“Linux 子系统”与“虚拟机平台”"></a>1. 打开“Linux 子系统”与“虚拟机平台”</h4><p><img src="/resource/images/pasted2-5.png" alt="upload successful"><br>选中上图圈出的两个项目，点击“确定”。</p><p>或者，也可以通过命令行操作。以管理员身份执行 CMD 或 PowerShell，执行如下两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable</span>-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable</span>-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><h4 id="2-安装-WSL-内核"><a href="#2-安装-WSL-内核" class="headerlink" title="2. 安装 WSL 内核"></a>2. 安装 WSL 内核</h4><p>点击下面的按钮从微软下载最新的 x64 或 arm64 WSL 内核：<br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" target="_blank" rel="noopener">最新版 x64 WSL 2 内核</a><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi" target="_blank" rel="noopener">最新版 arm64 wsl 2 内核</a></p><p>下载并安装 MSI 包即可。</p><h4 id="3-设置-WSL-默认版本为-2"><a href="#3-设置-WSL-默认版本为-2" class="headerlink" title="3. 设置 WSL 默认版本为 2"></a>3. 设置 WSL 默认版本为 2</h4><p>打开 CMD 或 PowerShell，执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version 2</span><br></pre></td></tr></table></figure><h4 id="4-安装ubuntu-和-terminal"><a href="#4-安装ubuntu-和-terminal" class="headerlink" title="4.安装ubuntu 和 terminal"></a>4.安装ubuntu 和 terminal</h4><p>直接从Microsoft store商店直接搜索下载即可，建议ubuntu版本为20.04或以上。</p><h4 id="5-安装docker"><a href="#5-安装docker" class="headerlink" title="5.安装docker"></a>5.安装docker</h4><p>直接下载安装即可（建议版本为4.1）<br><a href="https://docs.docker.com/docker-for-windows/release-notes/#docker-desktop-310" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/release-notes/#docker-desktop-310</a></p><p>至此，虚拟机环境搭建完毕。  </p><p><strong>注意必看：</strong><br>1、ubuntu默认是安装时创建的账号，非root账号，这给开发带来不便，如何设置默认root登入可以看我另一篇文章：<a href="http://www.baidu.com" target="_blank" rel="noopener">添加链接描述</a>   </p><p>2、wsl内子系统的ip每次启动都会重置，这给开发带来不便，如何解决这个问题可以看我另一篇文章：<a href="http://www.baidu.com" target="_blank" rel="noopener">添加链接描述</a></p><p>3、鄙人本地的lnmp环境是使用的是docker-compose.yaml一键安装及配置文件和目录挂载，具体可以看我另一篇文章：<a href="http://www.baidu.com" target="_blank" rel="noopener">添加链接描述</a></p><p>4.安装docker-compose命令如下:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1). 下载docker-compose</span><br><span class="line">curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.28.3/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose  </span><br><span class="line">(2). 修改执行权限</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先来一堆废话背景介绍：&quot;&gt;&lt;a href=&quot;#先来一堆废话背景介绍：&quot; class=&quot;headerlink&quot; title=&quot;先来一堆废话背景介绍：&quot;&gt;&lt;/a&gt;&lt;strong&gt;先来一堆废话背景介绍：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;之前都是使用vagrant+Vir
      
    
    </summary>
    
    
      <category term="wsl" scheme="https://yzdzh.github.io/categories/wsl/"/>
    
    
  </entry>
  
  <entry>
    <title>docker安装软件环境集合</title>
    <link href="https://yzdzh.github.io/post/527254571.html"/>
    <id>https://yzdzh.github.io/post/527254571.html</id>
    <published>2021-04-26T16:15:00.000Z</published>
    <updated>2021-07-17T03:30:36.282Z</updated>
    
    <content type="html"><![CDATA[<p>有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。</p><h3 id="1、hexo（私有仓库，不提供开放）"><a href="#1、hexo（私有仓库，不提供开放）" class="headerlink" title="1、hexo（私有仓库，不提供开放）"></a>1、hexo（私有仓库，不提供开放）</h3><p>本人私有博客打包，仅做个人笔记记录，不提供开放</p><p>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>2、创建启动容器<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hexo -it  -p 4000:4000 -w /home/wwwroot/hexo -v /home/wwwroot/hexo:/home/wwwroot/hexo  --entrypoint=<span class="string">"/home/wwwroot/hexo/hexo-sever.sh"</span> yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>  注：<br>   1)、第一次启动容器时需要将hexo-sever.sh中的#npm install解除注释，初始化node_modules</p><h3 id="2、elasticsearch"><a href="#2、elasticsearch" class="headerlink" title="2、elasticsearch"></a>2、elasticsearch</h3><p>基于elasticsearch7.12版本打包，允许跨域操作<br>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yizhidaozuihou/es</span><br></pre></td></tr></table></figure><br>2、创建用户定义的网络（用于连接到连接到同一网络的其他服务（例如，Kibana））<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create somenetwork</span><br></pre></td></tr></table></figure><br>3、创建挂载的目录<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"></span><br><span class="line">//生产环境才需要执行以下命令（挂载配置文件和插件目录）</span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http.host: 0.0.0.0"</span> &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">/mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">//需要设置挂载目录可读写权限，不然docker容器启动不了</span><br><span class="line">chmod -R 777 mydata/elasticsearch/</span><br></pre></td></tr></table></figure><br>4、创建容器并启动<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//测试环境docker（直接挂载数据库就行了）</span><br><span class="line">docker run -d --name es --net somenetwork -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span>  -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data yizhidaozuihou/es</span><br><span class="line"></span><br><span class="line">//生产环境docker(需要挂载配置文件和插件目录)</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300  -e <span class="string">"discovery.type=single-node"</span> -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span><br></pre></td></tr></table></figure><br>其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件，如ik，而数据挂载需要权限，需要设置data文件的权限为可读可写,需要下边的指令。<br>chmod -R 777 要修改的路径</p><p>-e “discovery.type=single-node” 设置为单节点<br>特别注意：<br>-e ES_JAVA_OPTS=”-Xms256m -Xmx256m” \ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES</p><h3 id="3、elasticsearch-head"><a href="#3、elasticsearch-head" class="headerlink" title="3、elasticsearch-head"></a>3、elasticsearch-head</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//基于elasticsearch-head5版本打包，兼容elasticsearch7.X版本</span><br><span class="line">docker pull yizhidaozuihou/es-head</span><br><span class="line">docker run  -d --name es-head -p 9100:9100 yizhidaozuihou/es-head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。&lt;/p&gt;
&lt;h3 id=&quot;1、hexo（私有仓库，不提供开放）&quot;&gt;&lt;a href=&quot;#1、hexo（私有仓库，不提供开
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker打包自定义镜像并上传docker hub</title>
    <link href="https://yzdzh.github.io/post/1624279696.html"/>
    <id>https://yzdzh.github.io/post/1624279696.html</id>
    <published>2021-04-26T08:05:00.000Z</published>
    <updated>2021-04-27T01:33:41.867Z</updated>
    
    <content type="html"><![CDATA[<h6 id="docker打包自定义镜像并上传docker-hub"><a href="#docker打包自定义镜像并上传docker-hub" class="headerlink" title="docker打包自定义镜像并上传docker hub"></a>docker打包自定义镜像并上传docker hub</h6><p>1、使用dockers commit命令来打包</p><p>dockers commit 容器名 要保存成的镜像名：版本名（若没有：版本名则直接默认为latest）<br>例如 docker commit vser vs:v1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 49ba413b3614 es</span><br></pre></td></tr></table></figure><p>2、将刚刚commit 的镜像名 打包成特定的格式。例如：<br>docker tag vs:v1 你docker的用户名/你dockerhub上创建的仓库名：版本号 （若无则默认为latest）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag es:v1 yizhidaozuihou/es</span><br></pre></td></tr></table></figure><p>3、打包好后, 将镜像拉取到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker push yizhidaozuihou/es</span><br><span class="line">注：如果未登录docker hub的话是不能push上传的，需要先 docker login 命令输入账号密码登录后才能push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;docker打包自定义镜像并上传docker-hub&quot;&gt;&lt;a href=&quot;#docker打包自定义镜像并上传docker-hub&quot; class=&quot;headerlink&quot; title=&quot;docker打包自定义镜像并上传docker hub&quot;&gt;&lt;/a&gt;docker打包
      
    
    </summary>
    
    
      <category term="docker" scheme="https://yzdzh.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>phpstrom实用插件集合</title>
    <link href="https://yzdzh.github.io/post/1452351953.html"/>
    <id>https://yzdzh.github.io/post/1452351953.html</id>
    <published>2021-01-30T18:02:00.000Z</published>
    <updated>2021-09-24T03:01:03.125Z</updated>
    
    <content type="html"><![CDATA[<p>以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。</p><h3 id="1、中英文转换：translation"><a href="#1、中英文转换：translation" class="headerlink" title="1、中英文转换：translation"></a>1、中英文转换：translation</h3><pre><code>快捷键 Ctrl+Shift+Y   OR 选中需要翻译的文本，然后鼠标右键选择Translate</code></pre><h3 id="2、拼写法转换：camelCase"><a href="#2、拼写法转换：camelCase" class="headerlink" title="2、拼写法转换：camelCase"></a>2、拼写法转换：camelCase</h3><pre><code>选中需要改变的变量  使用  快捷键 shift + alt + u ，变量就会改变，直到找到需要的格式。</code></pre><h3 id="3、php-注释增强工具：PHP-Annotation"><a href="#3、php-注释增强工具：PHP-Annotation" class="headerlink" title="3、php 注释增强工具：PHP Annotation"></a>3、php 注释增强工具：PHP Annotation</h3><pre><code>可以自动提示补全注解名和点击跳转追踪</code></pre><h3 id="4、自动关联数组键输入和完成：deep-assoc-completion"><a href="#4、自动关联数组键输入和完成：deep-assoc-completion" class="headerlink" title="4、自动关联数组键输入和完成：deep-assoc-completion"></a>4、自动关联数组键输入和完成：deep-assoc-completion</h3><pre><code>帮助完成数组参数 - 可以使用哪些键</code></pre><h3 id="5、proto语法高亮追踪提示：Protocol-Buffers"><a href="#5、proto语法高亮追踪提示：Protocol-Buffers" class="headerlink" title="5、proto语法高亮追踪提示：Protocol Buffers"></a>5、proto语法高亮追踪提示：Protocol Buffers</h3><pre><code>proto语法高亮追踪提示，临时看其他项目不想安装依赖包时使用</code></pre><h3 id="6、Chinese-​-Simplified-​-Language-Pack-中文语言包"><a href="#6、Chinese-​-Simplified-​-Language-Pack-中文语言包" class="headerlink" title="6、Chinese ​(Simplified)​ Language Pack / 中文语言包"></a>6、Chinese ​(Simplified)​ Language Pack / 中文语言包</h3><pre><code>中文语言汉化包</code></pre><h3 id="7、无限重置有效期插件：IDE-Eval-Reset"><a href="#7、无限重置有效期插件：IDE-Eval-Reset" class="headerlink" title="7、无限重置有效期插件：IDE Eval Reset"></a>7、无限重置有效期插件：IDE Eval Reset</h3><pre><code>需要先添加第三方仓库地址：https://plugins.zhile.io</code></pre><p><img src="/resource/images/pasted2-2.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。&lt;/p&gt;
&lt;h3 id=&quot;1、中英文转换：translation&quot;&gt;&lt;a href=&quot;#1、中英文转换：translation&quot; class=&quot;headerlink&quot; title=&quot;1、中英文转换：t
      
    
    </summary>
    
    
      <category term="phpStorm" scheme="https://yzdzh.github.io/categories/phpStorm/"/>
    
    
  </entry>
  
  <entry>
    <title>php获取指定前缀常量便捷操作方法</title>
    <link href="https://yzdzh.github.io/post/4113924384.html"/>
    <id>https://yzdzh.github.io/post/4113924384.html</id>
    <published>2020-09-03T04:04:00.000Z</published>
    <updated>2021-09-03T06:04:31.384Z</updated>
    
    <content type="html"><![CDATA[<p>例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 </p><p>1、在model中定义的字段类型规范如下order_status字段的常量前缀都是ORDER_STATUS_，常量内容都是：[值，中文解释]</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅为示例代码，实际三个封装方法可以直接放在基础类BaseModel里面所有model公用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">extends</span> <span class="title">BaseModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> int 订单类型 */</span></span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_WAITING = [<span class="number">0</span>,<span class="string">'待付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_SUCCESS = [<span class="number">1</span>,<span class="string">'已付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_REFUNDED    = [<span class="number">2</span>,<span class="string">'已退款'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组（返回无指定key的集合的二维数组）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array [[0,'待付款'],[1,'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstDesc</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[] = $v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (结果返回指定key，value字段名的二维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  二维数组，可以指定key和value的字段名 例：[['id'=&gt;0,'name'=&gt;'待付款'],['id'=&gt;1,'name'=&gt;'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstSelect</span><span class="params">(string $key,string $key_field = <span class="string">'id'</span> , string $value_field = <span class="string">'name'</span>)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $const_list = <span class="keyword">self</span>::getConstDesc($key);</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($const_list <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            $desc[] = [</span><br><span class="line">                $key_field=&gt;$v[<span class="number">0</span>]??<span class="number">0</span>,</span><br><span class="line">                $value_field=&gt;$v[<span class="number">1</span>]??<span class="string">''</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (結果返回一维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  一维数组，key为索引第一位数，value为索引第二位数。 例：['key'=&gt;value,0=&gt;'待付款',1=&gt;'已付款']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstPluck</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[$v[<span class="number">0</span>]] = $v[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$getConstDesc = Order::getConstDesc(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstSelect = Order::getConstSelect(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstPluck = Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>(Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>)[$params[<span class="string">'order_status'</span>]]))&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ErrorHelper::FAIL_CODE,<span class="string">'订单类型不存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 &lt;/p&gt;
&lt;p&gt;1、在model中定义的字段类型规范如下order_status字
      
    
    </summary>
    
    
      <category term="php" scheme="https://yzdzh.github.io/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>linux设置开机服务自动启动/关闭自动启动命令</title>
    <link href="https://yzdzh.github.io/post/1924607937.html"/>
    <id>https://yzdzh.github.io/post/1924607937.html</id>
    <published>2020-08-20T10:48:00.000Z</published>
    <updated>2021-08-21T14:18:26.770Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chkconfig --list 显示开机可以自动启动的服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --add *** 添加开机自动启动***服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --del *** 删除开机自动启动***服务</span></span><br></pre></td></tr></table></figure><p>参考地址：<a href="https://blog.csdn.net/weixin_34254823/article/details/92815942" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34254823/article/details/92815942</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="linux" scheme="https://yzdzh.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql开启全部sql日志查询</title>
    <link href="https://yzdzh.github.io/post/2712546463.html"/>
    <id>https://yzdzh.github.io/post/2712546463.html</id>
    <published>2020-08-12T10:11:00.000Z</published>
    <updated>2020-08-12T10:12:36.570Z</updated>
    
    <content type="html"><![CDATA[<p>   本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！</p><h5 id="1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置"><a href="#1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置" class="headerlink" title="1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置"></a>1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">general_log=on</span><br><span class="line"><span class="comment">#自动生成日志 0-不打开  1-打开</span></span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/system_log/mysql_sql.log</span><br></pre></td></tr></table></figure><h5 id="2、重启mysql"><a href="#2、重启mysql" class="headerlink" title="2、重启mysql"></a>2、重启mysql</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h5 id="3、查看日志是否打开"><a href="#3、查看日志是否打开" class="headerlink" title="3、查看日志是否打开"></a>3、查看日志是否打开</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">where</span> Variable_name=<span class="string">"general_log"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！&lt;/p&gt;
&lt;h5 id=&quot;1、打开-my-cnf-配
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://yzdzh.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之捕获异常</title>
    <link href="https://yzdzh.github.io/post/2798837510.html"/>
    <id>https://yzdzh.github.io/post/2798837510.html</id>
    <published>2020-05-22T10:00:00.000Z</published>
    <updated>2020-05-22T10:01:11.239Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统内部错误：捕获错误，并提示。</strong></p><ul><li>使用了defer panic 和recover关键字</li><li>描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理　　</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> errRecover := <span class="built_in">recover</span>(); errRecover != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"errRecover "</span> , errRecover )</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;系统内部错误：捕获错误，并提示。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了defer panic 和recover关键字&lt;/li&gt;
&lt;li&gt;描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理　　&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之基于zap开箱即用日志组件</title>
    <link href="https://yzdzh.github.io/post/816087200.html"/>
    <id>https://yzdzh.github.io/post/816087200.html</id>
    <published>2020-05-19T09:34:00.000Z</published>
    <updated>2020-05-19T09:34:39.935Z</updated>
    
    <content type="html"><![CDATA[<p>logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显:</p><ul><li>优雅的代码框架设计</li><li>使用简单</li><li>组件化的开发思路</li><li>灵活的输出方式</li></ul><p>但是, 性能终究是忍痛舍弃 logrus 的“阿喀琉斯之踵”<br>目前 golang 日志库的大众选择主要集中在: logrus, zap, zerolog. zap 和 zerolog 的性能都是优秀的, 但是从用法习惯上我更倾向于 zap.</p><h3 id="简单介绍-Zap-的使用"><a href="#简单介绍-Zap-的使用" class="headerlink" title="简单介绍 Zap 的使用"></a>简单介绍 Zap 的使用</h3><p>Zap 提供三种不同方式的输出(以 Info为 例)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.Info(<span class="string">"hello zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423173.016333,"caller":"test_zap/main.go:28","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infof(<span class="string">"hello %s"</span>, <span class="string">"zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423203.056074,"caller":"test_zap/main.go:29","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infow(<span class="string">"hello zap"</span>, <span class="string">"field1"</span>, <span class="string">"value1"</span>) <span class="comment">//&#123;"level":"info","ts":1576423203.0560799,"caller":"test_zap/main.go:30","msg":"hello zap","field1":"value1"&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们对 logrus 的 key-value 理论比较在意的话, 使用 zap infow 可以完美解决</p><ul><li>Zap 使用起来不便利的地方</li><li>Zap 使用上不能像 logrus 那样开箱即用</li><li>使用者需要自己去组装相关函数</li><li>Zap 同样不提供日志切割的功能, 但是想添加上这个功能没有 logrus 那样便利</li></ul><p>基于这些问题, 我封装了一套开箱即用的日志组件: <a href="https://github.com/yizhidaozuihou/log" target="_blank" rel="noopener">https://github.com/yizhidaozuihou/log</a></p><p>打造 Zap 开箱即用日志组件<br>提供的功能:</p><ul><li>提供的功能: 像 logrus 一样, 全局的 Debug, Info … 函数</li><li>日志分割功能. 默认文件大小1024M，自动压缩, 最大有3个文件备份，备份保存时间7天, 不会打印日志被调用的文文件名和位置</li><li>日志默认会被分成五类文件：debug、info、warn、error、panic 都会打印在xxx.log. xxx.log.Request输出 request log 的地方(如果有需要的话)</li></ul><p>使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/yizhidaozuihou/log</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/yizhidaozuihou/log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// init log</span></span><br><span class="line"><span class="comment">// set absolute path, and level</span></span><br><span class="line"><span class="comment">// set output level</span></span><br><span class="line"><span class="comment">// don't need request log</span></span><br><span class="line"><span class="comment">// set log's caller using logOption</span></span><br><span class="line">log.Init(<span class="string">"./test.log"</span>, log.DebugLevel, <span class="literal">false</span>, log.SetCaller(<span class="literal">true</span>))</span><br><span class="line">log.Info(<span class="string">"hello george log"</span>)</span><br><span class="line"><span class="comment">// flush</span></span><br><span class="line">log.Sync()</span><br><span class="line"><span class="comment">//output: &#123;"level":"info","ts":"2019-12-16T10:37:11.364+0800","caller":"example/example.go:12","msg":"hello george log"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优雅的代码框架设计&lt;/li&gt;
&lt;li&gt;使用简单&lt;/li&gt;
&lt;li&gt;组件化的开发思路&lt;/li&gt;
&lt;li&gt;灵活的输出方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是, 性能终究是忍痛舍弃
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang个人总结好用库集合</title>
    <link href="https://yzdzh.github.io/post/561152273.html"/>
    <id>https://yzdzh.github.io/post/561152273.html</id>
    <published>2020-05-18T18:37:00.000Z</published>
    <updated>2021-07-17T02:42:51.842Z</updated>
    
    <content type="html"><![CDATA[<p>以下是个人在实践工作中总结的好用库集合，持续不断更新中。。</p><h3 id="一、json处理库"><a href="#一、json处理库" class="headerlink" title="一、json处理库"></a>一、json处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/3838666233.html target = _blank>http://wangzhuanglin.gitee.io/post/3838666233.html</a></p><h3 id="二、配置文件处理库"><a href="#二、配置文件处理库" class="headerlink" title="二、配置文件处理库"></a>二、配置文件处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/132771847.html target = _blank>http://wangzhuanglin.gitee.io/post/132771847.html</a></p><h3 id="三、日志库"><a href="#三、日志库" class="headerlink" title="三、日志库"></a>三、日志库</h3><p><a href=http://wangzhuanglin.gitee.io/post/816087200.html target = _blank>http://wangzhuanglin.gitee.io/post/816087200.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是个人在实践工作中总结的好用库集合，持续不断更新中。。&lt;/p&gt;
&lt;h3 id=&quot;一、json处理库&quot;&gt;&lt;a href=&quot;#一、json处理库&quot; class=&quot;headerlink&quot; title=&quot;一、json处理库&quot;&gt;&lt;/a&gt;一、json处理库&lt;/h3&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之viper操作库</title>
    <link href="https://yzdzh.github.io/post/132771847.html"/>
    <id>https://yzdzh.github.io/post/132771847.html</id>
    <published>2020-05-18T08:58:00.000Z</published>
    <updated>2020-05-18T08:58:47.364Z</updated>
    
    <content type="html"><![CDATA[<p>Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。</p><p>这里记录下viper读取.env配置文件的具体代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">".env"</span>) <span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigType(<span class="string">"env"</span>) <span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"./"</span>)   <span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">err12 := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err12 != <span class="literal">nil</span> &#123; <span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Fatal error config file: %s \n"</span>, err12))</span><br><span class="line">&#125;</span><br><span class="line">viper.SetDefault(<span class="string">"DB_DRIVER"</span>,<span class="number">55555</span>)</span><br><span class="line">fmt.Println(<span class="number">777</span>,viper.GetString(<span class="string">"DB_DRIVER"</span>))</span><br></pre></td></tr></table></figure><p>其他详细教程可以直接看go大神写的详细文章<br><a href="https://www.liwenzhou.com/posts/Go/viper_tutorial/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/viper_tutorial/</a><br><a href="https://learnku.com/articles/33908" target="_blank" rel="noopener">https://learnku.com/articles/33908</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。&lt;/p&gt;
&lt;p&gt;这里记录下viper读取.env配置文件的具体代码&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang库集合</title>
    <link href="https://yzdzh.github.io/post/3243567407.html"/>
    <id>https://yzdzh.github.io/post/3243567407.html</id>
    <published>2020-05-13T15:25:00.000Z</published>
    <updated>2020-05-13T15:39:52.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="golang用于创建和发送电子邮件的库"><a href="#golang用于创建和发送电子邮件的库" class="headerlink" title="golang用于创建和发送电子邮件的库"></a>golang用于创建和发送电子邮件的库</h3><p>douceur - HTML 邮件中的内联 CSS<br>email - 一个健壮的、灵活的 email 库<br>Go-dkim - DKIM 库，用于对 email 进行签名和验证<br>Go-imap - IMAP 库，用于客户端和服务器<br>Go-message - 用于触雷互联网消息格式和邮件的库<br>Gomail - Gomail 是一个非常简单且强大的库，用于发送电子邮件<br>Hectane - 轻量级 SMTP 客户端，提供 HTTP API<br>hermes - 一个用于生成干净、响应式 HTML e-mail 的包<br>MailHog - Email 及 SMTP 测试工具，具有 web 及 API 接口<br>SendGrid - SendGrid 的 Go 语言库，用于发送电子邮件<br>smtp - SMTP 服务器协议状态机  </p><h3 id="golang处理日期和时间的库"><a href="#golang处理日期和时间的库" class="headerlink" title="golang处理日期和时间的库"></a>golang处理日期和时间的库</h3><p>carbon - 简单的时间扩展程序，有很多有用的方法，是 PHP Carbon 库的接口<br>durafmt - 持续时间格式化<br>feiertage - 一组计算德国公共假期的函数，比如复活节、感恩节等<br>Go-persian-calendar - 太阳历<br>Goweek - 处理星期的库<br>now - Now 是一个 Go 语言的时间工具集<br>NullTime -时间可以是 NULL 的库<br>timeutil - 为 Go 语言时间包扩展了有用的功能，例如时间间隔和格式化  </p><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>darwin - 数据库模式进化库<br>Go-fixtures - 类似 DjanGo fixtures，用于 Golang 的內建数据库/sql 库<br>Goose - 数据库迁移工具。你可以通过编写增量 SQL 或 Go 语言脚本来管理你的数据库<br>Gormigrate - 数据库模式迁移帮助工具，用于 Gorm ORM.<br>migrate - 数据库迁移。命令行及 Go 语言库<br>pravasan - 简单的迁移，目前支持 MySQL 但是近期打算支持 Postgres, SQLite, MonGoDB 等等<br>soda - 数据库迁移、创建、 ORM等等，用于 MySQL, PostgreSQL, 以及 SQLite.<br>sql-migrate - 数据库迁移工具，允许利用 Go-bindata 将数据库迁移嵌入应用程序  </p><h3 id="Go-语言实现的数据库"><a href="#Go-语言实现的数据库" class="headerlink" title="Go 语言实现的数据库"></a>Go 语言实现的数据库</h3><p>BigCache - 为 gigabytes 量级数据设计的高效键/值缓存<br>bolt - 底层键值数据库<br>buntdb - 快速，可嵌入的，内存键值数据库，可定义索引及 spatial<br>cache2Go - 基于内存存储的键值缓存，支持自动基于超时的自动失效<br>cockroach - 可扩展的、一致的事务型数据库<br>couchcache - RESTful 缓存微服务，基于Couchbase<br>dgraph - 可扩展的、分布式的、低延时、高吞吐的图数据库<br>diskv - 具有 disk-backed 功能的持久化键值存储<br>eliasdb - 无依赖、事物型图数据库，支持 REST API、短语搜索以及类 SQL 的查询语言<br>forestdb - ForestDB 的 Go 语言借口<br>GCache - 支持缓存过期、 LFU、 LRU 和 ARC 的缓存库<br>geocache - 基于内存存储的缓存，适用于分布式部署的应用<br>Go-cache - 内存键值存储/缓存库，适用于单机程序<br>Goleveldb - 使用 Go 语言实现的 LevelDB<br>groupcache - Groupcache 是一个缓存及缓存填充库，在很多情况下用于替代 memcached.<br>influxdb - 用于计量、事件及实时分析的、可扩展的数据库<br>ledisdb - Ledisdb 是一个高性能 NoSQL 数据库，类似 Redi<br>leviGo - LeviGo 是 LevelDB的 Go 语言封装<br>moss - Moss 是一个简单的 LSM 键值存储引擎，100% Go 语言实现<br>piladb - 轻量级 RESTful 数据库引擎，基于堆栈结构<br>prometheus - 监控系统及时间序列数据库<br>rqlite - 基于 SQLite 的轻量级的、分布式的关系型数据库<br>Scribble - 小巧的 JSON 文件存储<br>tempdb - 临时数据的键值对存储<br>tidb - TiDB 是一个分布式的 SQL 数据库。受到了 Google F1的启发<br>tiedot - 基于 Go 语言的 NoSQL 数据库<br>Tile38 - 地理位置数据库及实时地理围栏  </p><h3 id="golang通用数据结构及算法"><a href="#golang通用数据结构及算法" class="headerlink" title="golang通用数据结构及算法"></a>golang通用数据结构及算法</h3><p>binpacker - 二进制数据封包拆包工具，帮你构建自定义的二进制数据流<br>bit - Go 语言集合数据结构。提供了额外的位操作功能<br>bitset - 实现了 bitset 的 Go 语言包.<br>bloom - Go 语言实现的布隆过滤器（bloom filter）<br>bloom - Go 语言实现的布隆过滤器<br>boomfilters - 概率统计数据结构，用于处理大量连续的数据。<br>count-min-log - Go 语言实现的 Count-Min-Log sketch 算法(类似 Count-Min sketch 算法，但是使用的内存更少).<br>cuckoofilter - Cuckoo 过滤器：一个用go语言实现的计数布隆过滤器的替代品<br>encoding - 整型压缩库<br>Go-adaptive-radix-tree - Go 语言实现的自适应基数树<br>Go-datastructures - 一组有用的、高性能的、线程安全的数据结构<br>Go-geoindex - 基于内存存储的地理索引<br>Go-rquad - 区域四叉树，支持有效点位置和领域发现<br>Gods - Go 语言数据结构、容器、集合、列表、栈、键值对、 BidiMaps、树、HashSet 等<br>Golang-set - 线程安全和非线程安全的高性能集合<br>Goskiplist - Go 语言实现的跳跃表<br>Gota - 为go语言实现了数据帧，序列以及数据噪音的方法<br>hilbert - 用于映射空间填充曲线（例如希尔伯特曲线和皮亚诺曲线）和数值的库。<br>hyperloglog - HyperLogLog implementation with Sparse, LogLog-Beta bias correction and TailCut space reduction.<br>levenshtein - 编辑距离（levenshtein distance）和相似性度量， 可以自定义编辑代价和and Winkler-like bonus for common prefix.<br>levenshtein - Go 语言实现计算编辑距离<br>mafsa - Go 语言实现的 MA-FSA ，包含最小完美哈希<br>merkletree - 实现了梅克尔树，提供了一种高效、安全的数据结构内容验证方法<br>roaring - 实现了压缩 bitsets 的Go语言库<br>skiplist - Go语言实现的跳跃表<br>trie - Go语言实现的Trie树<br>ttlcache - In-memory LRU string-interface{} map with expiration for Golang<br>willf/bloom - 实现了布隆过滤器的库  </p><h3 id="golang用于进行配置解析的库"><a href="#golang用于进行配置解析的库" class="headerlink" title="golang用于进行配置解析的库"></a>golang用于进行配置解析的库</h3><p>config - JSON 或 YAML 配置的封装，支持环境变量和标记解析<br>configure - 可以通过多种途径进行配置，包括 JSON, 标记位以及环境变量<br>env - 解析环境变量为 Go 语言结构体<br>envcfg - 解析环境变量为 Go 语言结构体<br>envconf - 通过环境变量来配置<br>envconfig - 通过环境变量读取配置<br>gcfg - 读取类 INI 类型的配置文件为 Go 语言结构体，支持自定义变量和节<br>GoConfig - 通过命令行的输入、环境变量、配置文件来初始化一个结构体兵将一个结构体解析为输入<br>Godotenv - Ruby 库 dotenv 的 Go 语言接口 (通过 .env 来获取环境变量)<br>Gofigure - 让 Go 语言应用程序配置变得简单<br>Gone/jconf - 模块化 JSON 配置工具。允许你将配置参数结构体和使用它的代码放在一起，而不需要让主配置文件了解所有子模块的细节来进行序列化<br>hjson - 人性化的 JSON，一个便于程序员使用和阅读的配置文件格式。更加轻松的语法，更少的错误和更多的注释<br>inGo - 将配置标记持久化到一个类似 ini 的文件中<br>ini - 用于读写INI 文件的库<br>joshbetz/config - 消息配置库，可以解析环境变量、JSON 文件并根据SIGHUP自动重新载入<br>mini -用于解析类 ini 文件的库<br>store - 轻量级配置管理<br>viper - 这个库名叫毒蛇 ,Go 语言配置工具<br>xdg -遵守 XDG 标准 的配置工具  </p><h3 id="golang认证和授权库"><a href="#golang认证和授权库" class="headerlink" title="golang认证和授权库"></a>golang认证和授权库</h3><p>authboss - 用于 web 开发的组件化认证授权系统。它尝试尽可能的移除模板代码以及硬编码，这使你每次新建 web 项目的时候，可以做到即插即用、配置并开始开发你的 web 英语，而不必每次都重新创建一个认证授权系统。<br>casbin - 一个支持接入控制模型（例如:ACL,RBAC,ABAC）的授权库<br>Go-AWS-Auth - AWS 请求签名库<br>Go-jose - Fairly complete implementation of the JOSE working group’s JSON Web Token, JSON Web 签名以及JSON Web 加密 specs.<br>Go-oauth2-server - 使用 Go 语言编写的独立、符合标准的 OAuth2 服务器<br>Go.auth - 为 Go 语言 web 应用提供的授权 API.<br>Gologin - 可以串连使用OAuth1 和 OAuth2 认证服务<br>Gorbac - 一个用 Go 语言实现的轻量级RBAC<br>Goth - 提供了一种简洁的、惯用的方式来使用OAuth 和 OAuth2.<br>httpauth - HTTP 认证中间件<br>jwt - 简单易用的一个JSON Web Tokens (JWT)的实现<br>jwt-auth - JWT 为 Go 语言 HTTP 服务器编写的 jwt 中间件，有多种配置选项<br>jwt-Go - Go 语言实现的JSON Web Tokens (JWT).<br>loginsrv - JWT 登录微服务，可以继承OAuth2 (Github), htpasswd, osiam等后端。<br>oauth2 - Goauth2的继承者。 通用 OAuth 2.0 库，集成了对JWT, Google APIs, Compute Engine 和 App Engine的支持.<br>osin - Go 语言 OAuth2 服务器库<br>permissions2 - 用于追踪用户，登录状态和许可的库。使用安全 cookies 和 bcrypt.<br>session - Go 语言会话管理(支持 Google App Engine - GAE)<br>sessions - 为 Go 语言 HTTP 服务器开发的非常简单的、高性能的、高可定制的会话服务<br>traefik - 反向代理和负载均衡库，支持多种后端<br>yubiGo - Yubikey 客户端，提供了用于在 Go 语言应用中集成Yubico   Yubikey 的 API  </p><h3 id="golang用于操作音频的库"><a href="#golang用于操作音频的库" class="headerlink" title="golang用于操作音频的库"></a>golang用于操作音频的库</h3><p>flac - 原生 Go FLAC 解码器<br>flac - 原生 Go FLAC 解码器<br>gaad - 原生 Go AAC 比特流解析器<br>Go-sox - libsox 的 Go 语言接口<br>Go_mediainfo - libmediainfo 的 Go 语言接口<br>Gosamplerate - libsamplerate 的 Go 语言接口<br>id3v2 - 快速且稳定的 ID3 解析及写入库<br>mix - 基于序列的 Go 语言混音器，可用于音乐 app。<br>mp3 - 原生 Go MP3 解码器<br>music-theory - Go 语言编写的音乐理论模型<br>PortAudio - 音频 I/O 库的 Go 语言接口<br>portmidi - PortMidi 的 Go 语言接口<br>taglib - taglib 的 Go 语言接口<br>vorbis - “原生” Go Vorbis 解码器 (使用 CGo, 但是没有其他依赖).<br>waveform - 一个可以通过音频流生成波形图像的包  </p><h3 id="golang代码中嵌入其他语言的包"><a href="#golang代码中嵌入其他语言的包" class="headerlink" title="golang代码中嵌入其他语言的包"></a>golang代码中嵌入其他语言的包</h3><p>aGora - 一种动态类型的可以嵌入 Go 中的编程语言<br>anko - Go 语言编写的解释器<br>binder - Lua 接口, 基于 Gopher-lua<br>gisp - Simple LISP<br>Go-duktape - Duktape JavaScript 引擎的 Go 语言接口<br>Go-lua - Lua 5.2 虚拟机的纯 Go 语言接口<br>Go-php - PHP 的 Go 语言接口<br>Go-python - CPython C-API 的 Go 语言接口<br>Golua - Lua C API。的 Go 语言接口<br>Gopher-lua - Go 语言编写的 Lua 5.1 虚拟机和编译器<br>ngaro - 可嵌入的 Ngaro 虚拟机实现，支持在 Retro 中使用脚步<br>otto - Go 编写的 Javascrip 解释器<br>purl - 嵌入 Go 语言的 Perl 5.18.2  </p><h3 id="go日志库"><a href="#go日志库" class="headerlink" title="go日志库"></a>go日志库</h3><p>glg - glg 是一个简单、快速、分级的日志库<br>glog - 分级记录日志的库<br>Go-cronowriter 对日志文件进行自动循环写入的库基于当前日期和时间，类似 cronolog.<br>Go-log - 支持多处理器及日志分级的库<br>Go-log - Go 语言实现的 Log4j<br>Go-logger - 支持日志分级的简单的日志工具<br>Gologger - 简单易用的日志库，可以在彩色控制台、简易控制的、文件或 Elasticsearch 中记录<br>Gomol - 支持多种输出，结构化的日志模块，可以扩展它的输出<br>Gone/log - 快速、可扩展、全功能、兼容标准库的日志库<br>log - 结构化日志库<br>log - 简单、可配置、可扩展的结构化日志库<br>log-voyage - 全功能日志saas 使用 Go 语言编写<br>log15 - 简单强大的日志库<br>logdump - 支持分级的日志库<br>logex - Go 语言日志库，支持追踪和分级，基于标准库进行了封装<br>logger - 一个极简的日志库<br>logrus - 支持结构化的日志工具.<br>logrusly - logrus 的插件，用于将错误发送到 Loggly.<br>logutils - 对 Go 语言标准日志工具进行了扩展，使其更好用<br>logxi - 十二要素 app 日志工具，非常快速，令你开心<br>lumberjack - 简单的循环日志工具，实现了 io.WriteCloser.<br>mlog - 一个简单的日志模块，可以分5级并有一个可选的循环日志文件记录功能，支持 stdout/stderr 输出.<br>ozzo-log - 高性能日志库，支持日志严重级别、分类及过滤。可以将过滤后的信息发送到不同的目的地(例如： 控制台、网络、邮箱).<br>seelog - 一个灵活的、解耦的、格式化的日志库<br>slf - 简单日志门面（The Structured Logging Facade (SLF) ） (类似 SLF4J，但是它是结构化的，并且专为 Go 语言设计)<br>slog - 为 Go 语言实现的结构化日志门面（Structured Logging Facade (SLF) ）<br>spew - 为 Go 语言的数据结构实现了一个整洁的打印功能，有助于调试<br>stdlog - Stdlog 是一个面向对象的库，提供了分级日志功能，对于定时任务很有用.<br>tail - 这个 Go 语言软件包力争模拟 BSD tail 的功能<br>xlog - 插件架构以及灵活的日志系统，具有日志等级控制，多日志目标以及自定义日志格式功能<br>xlog - 结构化日志 for net/context aware HTTP handlers ，可以灵活的分发<br>zap - 快速的、结构化的、分级的日志库<br>zerolog - 零分配 JSON 日志.  </p><h3 id="golang操作表单的库"><a href="#golang操作表单的库" class="headerlink" title="golang操作表单的库"></a>golang操作表单的库</h3><p>bind - 将表单数据绑定到任意的 Go 变量上<br>binding - 将来自 net/HTTP 请求的表单、JSON 数据绑定到结构体<br>conform - 检查用户输入并基于结构标签来清理数据<br>form - 解码 url 中的数据到 Go 语言变量中以及将 Go 语言变量编码进 url 支持Dual Array 及 Full map<br>formam - 将表单数据解码到结构体<br>forms - 框架无关的表单/JSON数据解析验证库，支持多部分表单及文件<br>Gorilla/csrf - 为 Go 语言 web 应用提供 CSRF 防御<br>nosurf - CSRF 防御中间件  </p><h3 id="Go实现消息系统的库"><a href="#Go实现消息系统的库" class="headerlink" title="Go实现消息系统的库"></a>Go实现消息系统的库</h3><p>CentrifuGo - 实时消息服务器<br>dbus - D-Bus的 Go 语言接口<br>drone-line - 通过软件包，docker 或是 Drone CI来发送 Line 通知<br>emitter - 通过Go语言的方式发送事件消息，可以使用通配符，断言，取消发送等优秀特性<br>EventBus - 轻量级事件库，支持异步<br>gaurun-client - Go 语言编写的 Gaurun 客户端<br>Glue - 健壮的 Go 和 Javascript Socket 库 (可以用来替代 Socket.io).<br>Go-longpoll - 支持长轮询的发布与订阅<br>Go-notify - 原生实现的桌面通知规范<br>Go-nsq - NSQ 官方 Go 语言库<br>Go-socket.io - Go 语言的 socket.io库 ,一个实时应用框架.<br>Go-vitotrol - Viessmann Vitotrol 服务的 Go 语言客户端<br>Gollum - 一个 n:m 的多路复用器，从不同的源汇聚消息并向目标进行广播<br>Golongpoll - HTTP 长轮询服务器库，让 web 发布与订阅变的更简单.<br>Goose - Go 语言实现的服务器端事件发送<br>Gopush-cluster - Gopush-cluster 是一个 Go 语言实现的支持集群的comet服务（支持 websocket，和tcp协议）<br>Gorush - 通知推送服务器，使用 APNs2 和 Google GCM.<br>guble - 一个使用通知推送(Google Firebase Cloud Messaging, Apple Push Notification services, SMS)、websockets 、REST API 的消息服务器。提供了分布式操作和消息持久化特性<br>machinery - 异步任务队列，基于分布式消息处理<br>manGos - 纯 Go 语言实现的 Nanomsg (“Scalable Protocols”)<br>melody - 用于处理 websocket 会话的一个极简框架，包括广播和自动 ping/pong 处理<br>NATS Go Client - 轻量级高性能发布订阅(publish-subscribe) 以及分布式消息队列系统，这个一个Go语言库.<br>nsq-event-bus - 针对 NSQ 的主题和频道进行了简单的封装<br>oplog - 原生的 oplog/replication 系统，用于 REST APIs<br>pubsub - 一个简单的 pubsub 软件包<br>RapidMQ - RapidMQ 是一个轻量级，可靠的本地消息队列管理库<br>sarama - 用于 Apache Kafka 的库<br>Uniqush-Push - 基于 Redis 的统一推服务，用于服务器端向移动客户端推送消息<br>zmq4 - ZeroMQ version 4的 GO 语言接口。也有适用于version 3 及 version 2的  </p><p>最后还有github上的类库大全：<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;golang用于创建和发送电子邮件的库&quot;&gt;&lt;a href=&quot;#golang用于创建和发送电子邮件的库&quot; class=&quot;headerlink&quot; title=&quot;golang用于创建和发送电子邮件的库&quot;&gt;&lt;/a&gt;golang用于创建和发送电子邮件的库&lt;/h3&gt;&lt;p&gt;do
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang之json操作库</title>
    <link href="https://yzdzh.github.io/post/3838666233.html"/>
    <id>https://yzdzh.github.io/post/3838666233.html</id>
    <published>2020-05-13T14:24:00.000Z</published>
    <updated>2020-05-13T14:24:43.037Z</updated>
    
    <content type="html"><![CDATA[<p>总结有三个非常好用的json操作库<br>1、gjson （读取json）<br>2、sjson   （增删改json）<br>3、gojsonq  （高级查询统计json数据）  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/tidwall/gjson</span><br><span class="line">$ <span class="keyword">go</span> get github.com/tidwall/sjson</span><br><span class="line">$ <span class="keyword">go</span> get github.com/thedevsaddam/gojsonq</span><br></pre></td></tr></table></figure><p>具体详情文章：<br>gjson ：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439052&amp;idx=4&amp;sn=4b668ec590db68ac5850e4c9eff6bfd1&amp;chksm=80bb613eb7cce828155ccfa92821b3da15f2551b8f6335bf6b8189aa9747a20c0ce1855de4f5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439052&amp;idx=4&amp;sn=4b668ec590db68ac5850e4c9eff6bfd1&amp;chksm=80bb613eb7cce828155ccfa92821b3da15f2551b8f6335bf6b8189aa9747a20c0ce1855de4f5&amp;scene=21#wechat_redirect</a><br>sjson   ：<a href="https://mp.weixin.qq.com/s/ucfJxIw_NLb6TGrhQa3UcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ucfJxIw_NLb6TGrhQa3UcQ</a><br>gojsonq  ：<a href="https://mp.weixin.qq.com/s/ZfaH6ROWiVX9IsoxJ04oXw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZfaH6ROWiVX9IsoxJ04oXw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结有三个非常好用的json操作库&lt;br&gt;1、gjson （读取json）&lt;br&gt;2、sjson   （增删改json）&lt;br&gt;3、gojsonq  （高级查询统计json数据）  &lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>go依赖管理--Go modules</title>
    <link href="https://yzdzh.github.io/post/2526408434.html"/>
    <id>https://yzdzh.github.io/post/2526408434.html</id>
    <published>2020-05-12T16:01:00.000Z</published>
    <updated>2020-05-12T16:06:28.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Go-Modules"><a href="#一、什么是Go-Modules" class="headerlink" title="一、什么是Go Modules?"></a>一、什么是Go Modules?</h2><p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。  </p><p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：  </p><ol><li>Go 语言长久以来的依赖管理问题。  </li><li>“淘汰”现有的 GOPATH 的使用模式。  </li><li>统一社区中的其它的依赖管理工具（提供迁移功能）。  </li></ol><h2 id="二、GOPATH的工作模式"><a href="#二、GOPATH的工作模式" class="headerlink" title="二、GOPATH的工作模式"></a>二、GOPATH的工作模式</h2><p>Go Modoules的目的之一就是淘汰GOPATH, 那么GOPATH是个什么?  </p><p>为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？  </p><h3 id="1-Wait-is-GOPATH"><a href="#1-Wait-is-GOPATH" class="headerlink" title="(1) Wait is GOPATH?"></a><strong>(1) Wait is GOPATH?</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line"></span><br><span class="line">GOPATH=<span class="string">"/home/itheima/go"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们输入go env命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>GOPATH目录下一共包含了三个子目录，分别是：</p><ul><li>bin：存储所编译生成的二进制文件。</li><li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li><li>src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放。</li></ul><blockquote><p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。</p></blockquote><h3 id="2-GOPATH模式的弊端"><a href="#2-GOPATH模式的弊端" class="headerlink" title="(2) GOPATH模式的弊端"></a><strong>(2) GOPATH模式的弊端</strong></h3><p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端.</p><p>A. 无版本控制概念. 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。<br>B.无法同步一致第三方版本号. 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。<br>C.无法指定当前项目引用的第三方版本号. 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。  </p><h2 id="三、Go-Modules模式"><a href="#三、Go-Modules模式" class="headerlink" title="三、Go Modules模式"></a>三、Go Modules模式</h2><p>我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在GOPATH/src下.</p><h3 id="1-go-mod命令"><a href="#1-go-mod命令" class="headerlink" title="(1) go mod命令"></a>(1) go mod命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init：生成 <span class="keyword">go</span>.mod 文件</span><br><span class="line"><span class="keyword">go</span> mod download : 下载 <span class="keyword">go</span>.mod 文件中指明的所有依赖</span><br><span class="line"><span class="keyword">go</span> mod tidy: 整理现有的依赖</span><br><span class="line"><span class="keyword">go</span> mod graph: 查看现有的依赖结构</span><br><span class="line"><span class="keyword">go</span> mod edit : 编辑 <span class="keyword">go</span>.mod 文件</span><br><span class="line"><span class="keyword">go</span> mod vendor : 导出项目所有的依赖到vendor目录</span><br><span class="line"><span class="keyword">go</span> mod verify: 校验一个模块是否被篡改过</span><br><span class="line"><span class="keyword">go</span> mod why: 查看为什么需要依赖某模块</span><br></pre></td></tr></table></figure><h3 id="2-go-mod环境变量"><a href="#2-go-mod环境变量" class="headerlink" title="(2) go mod环境变量"></a>(2) go mod环境变量</h3><p>可以通过 go env 命令来进行查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line">GO111MODULE=<span class="string">"auto"</span></span><br><span class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></span><br><span class="line">GONOPROXY=<span class="string">""</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GONOSUMDB=<span class="string">""</span></span><br><span class="line">GOPRIVATE=<span class="string">""</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a><strong>GO111MODULE</strong></h4><p>Go语言提供了 GO111MODULE这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p><p><strong>auto：</strong>只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。<br><strong>on：</strong>启用 Go modules，推荐设置，将会是未来版本中的默认值。<br><strong>off：</strong>禁用 Go modules，不推荐设置。<br>可以通过来设置  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a><strong>GOPROXY</strong></h4><p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。</p><p>GOPROXY 的默认值是：<a href="https://proxy.golang.org,direct" target="_blank" rel="noopener">https://proxy.golang.org,direct</a></p><p>proxy.golang.org国内访问不了,需要设置国内的代理.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里云</span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/goproxy/</span></span><br><span class="line"></span><br><span class="line">七牛云</span><br><span class="line">https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure><p>如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash $ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure><p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p><p>如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct</span></span><br><span class="line">direct</span><br></pre></td></tr></table></figure><p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p><p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。</p><h4 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a><strong>GOSUMDB</strong></h4><p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。  </p><p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p><p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p><p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p><p>格式 1：<SUMDB_NAME>+<PUBLIC_KEY>。<br>格式 2：<SUMDB_NAME>+<PUBLIC_KEY> <SUMDB_URL>。<br>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p><p>GONOPROXY/GONOSUMDB/GOPRIVATE<br>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p><p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p><p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。</p><p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPRIVATE=<span class="string">"git.example.com,github.com/eddycjy/mquote"</span></span><br></pre></td></tr></table></figure><p>设置后，前缀为 <a href="http://git.xxx.com" target="_blank" rel="noopener">http://git.xxx.com</a> 和 <a href="http://github.com/eddycjy/mquote" target="_blank" rel="noopener">http://github.com/eddycjy/mquote</a> 的模块都会被认为是私有模块。</p><p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPRIVATE=<span class="string">"*.example.com"</span></span><br></pre></td></tr></table></figure><p>这样子设置的话，所有模块路径为 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 的子域名（例如：<a href="http://git.example.com）都将不经过" target="_blank" rel="noopener">http://git.example.com）都将不经过</a> Go module proxy 和 Go checksum database，需要注意的是不包括 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 本身。</p><h2 id="四、使用Go-Modules初始化项目"><a href="#四、使用Go-Modules初始化项目" class="headerlink" title="四、使用Go Modules初始化项目"></a>四、使用Go Modules初始化项目</h2><h3 id="1-开启Go-Modules"><a href="#1-开启Go-Modules" class="headerlink" title="(1) 开启Go Modules"></a>(1) 开启Go Modules</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><p>又或是可以通过直接设置系统环境变量（写入对应的~/.bash_profile 文件亦可）来实现这个目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export GO111MODULE=on</span><br></pre></td></tr></table></figure><h3 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="(2) 初始化项目"></a>(2) 初始化项目</h3><p>创建项目目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p $HOME/aceld/modules_test</span><br><span class="line">$ cd $HOME/aceld/modules_test</span><br></pre></td></tr></table></figure><p>执行Go modules 初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init github.com/aceld/modules_test</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module github.com/aceld/modules_test</span><br></pre></td></tr></table></figure><p>​ 在执行 go mod init 命令时，我们指定了模块导入路径为 github.com/aceld/modules_test。接下来我们在该项目根目录下创建 main.go 文件，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/aceld/zinx/znet"</span></span><br><span class="line">    <span class="string">"github.com/aceld/zinx/ziface"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ping test 自定义路由</span></span><br><span class="line"><span class="keyword">type</span> PingRouter <span class="keyword">struct</span> &#123;</span><br><span class="line">    znet.BaseRouter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Ping Handle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *PingRouter)</span> <span class="title">Handle</span><span class="params">(request ziface.IRequest)</span></span> &#123;</span><br><span class="line">    <span class="comment">//先读取客户端的数据</span></span><br><span class="line">    fmt.Println(<span class="string">"recv from client : msgId="</span>, request.GetMsgID(), </span><br><span class="line">              <span class="string">", data="</span>, <span class="keyword">string</span>(request.GetData()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再回写ping...ping...ping</span></span><br><span class="line">    err := request.GetConnection().SendBuffMsg(<span class="number">0</span>, []<span class="keyword">byte</span>(<span class="string">"ping...ping...ping"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 创建一个server句柄</span></span><br><span class="line">    s := znet.NewServer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 配置路由</span></span><br><span class="line">    s.AddRouter(<span class="number">0</span>, &amp;PingRouter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 开启服务</span></span><br><span class="line">    s.Serve()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, 我们先不要关注代码本身,我们看当前的main.go也就是我们的aceld/modules_test项目,是依赖一个叫github.com/aceld/zinx库的. znet和ziface只是zinx的两个模块.</p><p>接下来我们在$HOME/aceld/modules_test,本项目的根目录执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/aceld/zinx/znet</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br><span class="line"><span class="keyword">go</span>: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure><p>我们会看到 我们的go.mod被修改,同时多了一个go.sum文件.</p><h3 id="3-查看go-mod文件"><a href="#3-查看go-mod文件" class="headerlink" title="(3) 查看go.mod文件"></a>(3) 查看go.mod文件</h3><p>aceld/modules_test/go.mod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 <span class="comment">// indirect</span></span><br></pre></td></tr></table></figure><p>我们来简单看一下这里面的关键字</p><p>module: 用于定义当前项目的模块路径</p><p>go:标识当前Go版本.即初始化版本</p><p>require: 当前项目依赖的一个特定的必须版本</p><p>// indirect: 示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的.我们的代码很明显是依赖的”github.com/aceld/zinx/znet”和”github.com/aceld/zinx/ziface”,所以就间接的依赖了github.com/aceld/zinx</p><h3 id="4-查看go-sum文件"><a href="#4-查看go-sum文件" class="headerlink" title="(4) 查看go.sum文件"></a>(4) 查看go.sum文件</h3><p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54=</span><br><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100/<span class="keyword">go</span>.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:vzj43D7+SQXF/<span class="number">4</span>pzW/hwtAqwc6iTitCiVSaWz5lYuqw=</span><br></pre></td></tr></table></figure><p>我们可以看到一个模块路径可能有如下两种：</p><p>h1:hash情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54=</span><br></pre></td></tr></table></figure><p>go.mod hash情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100/<span class="keyword">go</span>.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:vzj43D7+SQXF/<span class="number">4</span>pzW/hwtAqwc6iTitCiVSaWz5lYuqw=</span><br></pre></td></tr></table></figure><p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p><p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p><h2 id="五、修改模块的版本依赖关系"><a href="#五、修改模块的版本依赖关系" class="headerlink" title="五、修改模块的版本依赖关系"></a>五、修改模块的版本依赖关系</h2><p>​ 为了作尝试,假定我们现在都zinx版本作了升级, 由zinx v0.0.0-20200221135252-8a8954e75100 升级到 zinx v0.0.0-20200306023939-bc416543ae24 (注意zinx是一个没有打版本tag打第三方库,如果有的版本号是有tag的,那么可以直接对应v后面的版本号即可)</p><p>​ 那么,我们是怎么知道zinx做了升级呢, 我们又是如何知道的最新的zinx版本号是多少呢?</p><p>​ 先回到$HOME/aceld/modules_test,本项目的根目录执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/aceld/zinx/znet</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br><span class="line"><span class="keyword">go</span>: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br><span class="line"><span class="keyword">go</span>: github.com/aceld/zinx upgrade =&gt; v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br></pre></td></tr></table></figure><p>这样我们,下载了最新的zinx, 版本是v0.0.0-20200306023939-bc416543ae24</p><p>​ 然后,我么看一下go.mod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 <span class="comment">// indirect</span></span><br></pre></td></tr></table></figure><p>我们会看到,当我们执行go get 的时候, 会自动的将本地将当前项目的require更新了.变成了最新的依赖.</p><p>好了, 现在我们就要做另外一件事,就是,我们想用一个旧版本的zinx. 来修改当前zinx模块的依赖版本号.</p><p>目前我们在$GOPATH/pkg/mod/github.com/aceld下,已经有了两个版本的zinx库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">go</span>/pkg/mod/github.com/aceld$ ls</span><br><span class="line">zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br><span class="line">zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br></pre></td></tr></table></figure><p>​ 目前,我们/aceld/modules_test依赖的是<a href="mailto:zinx@v0.0.0-20200306023939-bc416543ae24">zinx@v0.0.0-20200306023939-bc416543ae24</a> 这个是最新版, 我们要改成之前的版本<a href="mailto:zinx@v0.0.0-20200306023939-bc416543ae24">zinx@v0.0.0-20200306023939-bc416543ae24</a>.</p><p>​ 回到/aceld/modules_test项目目录下,执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod edit -replace=zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24=zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure><p>​ 然后我们打开go.mod查看一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 <span class="comment">// indirect</span></span><br><span class="line"></span><br><span class="line">replace zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 =&gt; zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure><p>​ 这里出现了replace关键字.用于将一个模块版本替换为另外一个模块版本。</p><p>文章参考：<a href="https://zhuanlan.zhihu.com/p/113506780" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113506780</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是Go-Modules&quot;&gt;&lt;a href=&quot;#一、什么是Go-Modules&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Go Modules?&quot;&gt;&lt;/a&gt;一、什么是Go Modules?&lt;/h2&gt;&lt;p&gt;Go modules 是 Go 
      
    
    </summary>
    
    
      <category term="golang" scheme="https://yzdzh.github.io/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB中各种类型的索引</title>
    <link href="https://yzdzh.github.io/post/579789855.html"/>
    <id>https://yzdzh.github.io/post/579789855.html</id>
    <published>2020-05-03T15:57:00.000Z</published>
    <updated>2020-05-03T15:58:19.435Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 中索引的类型大致包含单键索引、复合索引、多键值索引、地理索引、全文索引、 散列索引等，下面简单介绍各类索引的用法。</p><h3 id="1、单字段索引"><a href="#1、单字段索引" class="headerlink" title="1、单字段索引"></a>1、单字段索引</h3><p>这个是最简单最常用的索引类型，比如我们上边的例子，为id建立一个单独的索引就是此种类型。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 为id field建立索引，1表示升序，-1表示降序，没有差别</span></span><br><span class="line">db.employee.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是通常MongoDB会自动为我们的文档插入’_id’ field，且已经按照升序进行索引，如果我们插入的文档中包含有’_id’ field，则MongoDB就不会自动创建’_id’ field，但是需要我们自己来保证唯一性从而唯一标识一个文档</p><h3 id="2、复合索引"><a href="#2、复合索引" class="headerlink" title="2、复合索引"></a>2、复合索引</h3><p><img src="https://img-blog.csdnimg.cn/20200503234104706.png" alt="在这里插入图片描述"><br>上图查询索引的时候会先查询userid，再查询score，然后就可以找到对应的文档。<br>对于复合索引需要注意以下几点：</p><p><strong>索引field的先后顺序很关键，影响有两方面</strong>：<br>1、MongoDB在复合索引中是根据prefix排序查询，就是说排在前面的可以单独使用。<br>我们创建一个如下的索引</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'city'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们如下的查询可以利用索引</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure><p>但是如下的查询无法利用该索引</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure><p>还有一种特殊的情况，就是如下查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure><p>这个查询也可以利用索引的前缀’id’来查询，但是却不能针对score进行查询，你可以说是部分利用了索引，因此其效率可能不如如下索引：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.过滤出的document越少的field越应该放在前面，比如此例中id如果是唯一的，那么就应该放在最前面，因为这样通过id就可以锁定唯一一个文档。而如果通过city或者score过滤完成后还是会有大量文档，这就会影响最终的性能。</p><p><strong>索引的排序顺序不同</strong><br>复合索引最末尾的field，其排序顺序不同对于MongoDB的查询排序操作是有影响的。<br>比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.events.createIndex( &#123; username: <span class="number">1</span>, date: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure><p>这种情况下， 如下的query可以利用索引：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure><p>但是如下query则无法利用index进行排序</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure><h3 id="3、多键值索引"><a href="#3、多键值索引" class="headerlink" title="3、多键值索引"></a>3、多键值索引</h3><p>这个主要是针对数据类型为数组的类型，如下示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span> : <span class="string">"jack"</span>, <span class="string">"age"</span> : <span class="number">19</span>, habbit: [<span class="string">"football, runnning"</span>]&#125;</span><br><span class="line">db.person.createIndex( &#123;habbit: <span class="number">1</span>&#125; )  <span class="comment">// 自动创建多key索引</span></span><br><span class="line">db.person.find( &#123;habbit: <span class="string">"football"</span>&#125; )</span><br></pre></td></tr></table></figure><h3 id="4、散列索引"><a href="#4、散列索引" class="headerlink" title="4、散列索引"></a>4、散列索引</h3><p>散列（Hashed）索引是指按照某个字段的散列值来建立索引，目前主要用于 MongoDB Sharded Cluster 的散列分片，散列索引只能用于字段完全匹配的查询，不能用于范围查询等。<br>散列其语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createlndex( &#123; _id : <span class="string">"hashed"</span> &#125;)</span><br></pre></td></tr></table></figure><p>MongoDB 支持散列任何单个字段的索引，但是不支持多键（即数组）索引。</p><p>需要说明的是，MongoDB 在进行散列索引之前，需要将浮点数截断为 64 位整数。例如，散列将对 2.3、2.2 和 2.9 这些值产生同样的返回值。</p><h3 id="5、过期索引"><a href="#5、过期索引" class="headerlink" title="5、过期索引"></a>5、过期索引</h3><p>顾名思义，过期索引就是一种会过期的索引，在索引过期之后，索引对应的数据会被删除，创建方式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;time:<span class="number">1</span>&#125;,&#123;expireAfterSeconds:<span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure><p>expireAfterSeconds表示索引的过期时间，单位为秒。time表示索引的字段，time的数据类型必须是ISODate或者ISODate数组，否则的话，当索引过期之后，time的数据就不会被删除。</p><h3 id="6、全文索引"><a href="#6、全文索引" class="headerlink" title="6、全文索引"></a>6、全文索引</h3><p>全文索引虽然好用，可惜不支持中文，我们这里就先做一个简单的了解。</p><p>比如，我的数据集如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc3189"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java C# Python PHP"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318a"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java C#"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318b"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318c"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"PHP Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a4541f9e8e181ffc318d"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"C C++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给x字段建立一个全文索引，创建方式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:<span class="string">"text"</span>&#125;)</span><br></pre></td></tr></table></figure><p>MongoDB会自动对x字段的数据进行分词，然后我们就可以通过如下语句进行查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"Java"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时x中包含Java的文档都会被查询出来。如果想查询既包含Java又包含C#的文档，操作如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"\"Java C#\""</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用一对双引号将查询条件括起来，如果想查询包含PHP或者Python的文档，操作如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果想查询既有PHP，又有Python，但是又不包括Java的文档，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python -Java"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>建立了全文索引之后，我们也可以查看查询结果的相似度，使用$meta，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;,&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时查询结果中会多出一个score字段，该字段的值越大，表示相似度越高，我们可以根据score利用sort来对其进行排序，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;,&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;).sort(&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>全文索引目前看起来功能还是很强大，可惜暂时不支持中文，不过网上对此也有很多解决方案，小伙伴们可以自行搜索查看。</p><h3 id="7、地理空间索引"><a href="#7、地理空间索引" class="headerlink" title="7、地理空间索引"></a>7、地理空间索引</h3><p>地理空间索引类型<br><strong>地理空间索引可以分为两类：</strong></p><p>1.<strong>2d索引</strong>，可以用来存储和查找平面上的点。<br>2.<strong>2d sphere索引</strong>，可以用来存储和查找球面上的点。</p><h4 id="2d索引"><a href="#2d索引" class="headerlink" title="2d索引"></a><strong>2d索引</strong></h4><p>2d索引一般我们可以用在游戏地图中。<br>向集合中插入一条记录点的数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;x:[<span class="number">90</span>,<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure><p>插入数据的格式为[经度,纬度]，取值范围，经度[-180,180]，纬度[-90,90]。数据插入成功之后，我们先通过如下命令创建索引：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:<span class="string">"2d"</span>&#125;)</span><br></pre></td></tr></table></figure><p>然后通过$near我们可以查询某一个点附近的点，如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[<span class="number">90</span>,<span class="number">0</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下返回该点附近100个点，我们可以通过$maxDistance来设置返回的最远距离：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[<span class="number">90</span>,<span class="number">0</span>],$maxDistance:<span class="number">99</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们也可以通过$geoWithin查询某个形状内的点，比如查询矩形中的点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$box:[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">91</span>,<span class="number">1</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>两个坐标点用来确定矩形的位置。</p><p>查询圆中的点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$center:[[<span class="number">0</span>,<span class="number">0</span>],<span class="number">90</span>]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>参数分别表示圆的圆心和半径。</p><p>查询多边形中的点：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$polygon:[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">100</span>,<span class="number">0</span>],[<span class="number">100</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里可以填入任意多个点，表示多边形中的各个点。</p><h4 id="2d-sphere索引"><a href="#2d-sphere索引" class="headerlink" title="2d sphere索引"></a><strong>2d sphere索引</strong></h4><p>2dsphere适用于球面类型的地图，它的数据类型是GeoJSON格式的，我们可以在<a href="http://geojson.org/地址上查看GeoJSON格式的样式，比如我们描述一个点，GeoJSON如下：" target="_blank" rel="noopener">http://geojson.org/地址上查看GeoJSON格式的样式，比如我们描述一个点，GeoJSON如下：</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e0571f9e8e181ffc3196"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"shenzhen"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"Point"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            <span class="number">90.0</span>, </span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述线，GeoJSON格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e0d01f9e8e181ffc3199"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"shenzhen"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"LineString"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">0.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">1.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">2.0</span></span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述多边形，GeoJSON格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e3f91f9e8e181ffc31d0"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"beijing"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"Polygon"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">1.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">1.0</span>, </span><br><span class="line">                    <span class="number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">1.0</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他的类型，具体小伙伴们可以参考<a href="http://geojson.org/。有了数据之后，我们可以通过如下操作来创建地理空间索引了：" target="_blank" rel="noopener">http://geojson.org/。有了数据之后，我们可以通过如下操作来创建地理空间索引了：</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;location:<span class="string">"2dsphere"</span>&#125;)</span><br></pre></td></tr></table></figure><p>比如我想查询和深圳这个区域有交集的文档，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$geoIntersects:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里的查询结果是和深圳这个区域有交集的都会查到(比如经过深圳的高速公路、铁路等)，我们也可以只查询深圳市内的区域(比如深圳市内所有的学校)，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>也可以查询腾讯附近的其他位置，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> QQ = db.sang_collect.findOne(&#123;name:<span class="string">"QQ"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$near:&#123;$geometry:QQ.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>复合地理空间索引<br>位置往往只是我们查询的一个条件，比如我要查询深圳市内所有的学校，那我得再增加一个查询条件，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;,name:<span class="string">"QQ"</span>&#125;)</span><br></pre></td></tr></table></figure><p>其他的查询条件跟在后面就行了。</p><p>参考文章：<br><a href="https://blog.csdn.net/u012702547/article/details/81027421" target="_blank" rel="noopener">https://blog.csdn.net/u012702547/article/details/81027421</a><br><a href="https://www.jianshu.com/p/2b09821a365d" target="_blank" rel="noopener">https://www.jianshu.com/p/2b09821a365d</a><br><a href="http://c.biancheng.net/view/6558.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6558.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB 中索引的类型大致包含单键索引、复合索引、多键值索引、地理索引、全文索引、 散列索引等，下面简单介绍各类索引的用法。&lt;/p&gt;
&lt;h3 id=&quot;1、单字段索引&quot;&gt;&lt;a href=&quot;#1、单字段索引&quot; class=&quot;headerlink&quot; title=&quot;1、单字段
      
    
    </summary>
    
    
      <category term="mongodb" scheme="https://yzdzh.github.io/categories/mongodb/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB-分片片键</title>
    <link href="https://yzdzh.github.io/post/1182994018.html"/>
    <id>https://yzdzh.github.io/post/1182994018.html</id>
    <published>2020-05-03T14:44:00.000Z</published>
    <updated>2020-05-03T14:46:40.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1．分片"><a href="#1．分片" class="headerlink" title="1．分片"></a>1．分片</h2><p>   分片是什么？分片就是将数据存储在多个机器上。当数据集超过单台服务器的容量，服务器的内存，磁盘IO都会有问题，即超过单台服务器的性能瓶颈。此时有两种解决方案，垂直扩展和水平扩展（分片）。 </p><p>  垂直扩展就是增加CPU，增加容量，但高性能系统的CPU和容量不成比例，这样扩展成本大，并且有上限。      </p><p>  水平扩展分片，将数据分发到多个服务器，每个服务器是一个单独的数据库，各个服务器加起来组成一个逻辑数据库，把写压力和操作分流到不同服务器，提高容量和吞吐量。  </p><p>  MongoDB的文档是无模式的，不固定结构，因此只能进行水平分片。当块超过指定大小或者文档数超过最大文档数，MongoDB尝试分割这个块，若分割成功，把它标记为一个大块避免重复分割。拆分块的关键就是片键，下面介绍常见片键的种类。</p><h2 id="2．片键种类"><a href="#2．片键种类" class="headerlink" title="2．片键种类"></a>2．片键种类</h2><p>  片键是文档的一个属性字段或者一个复合索引字段，一旦建立不能改变。片键是分片拆分数据的关键，片键的选择直接影响集群的性能。  </p><p>  MongoDB首先根据片键划分块chunks当块超过指定大小（默认64M），然后把块分到其他的分片上，片键类型主要有以下几种：    </p><p>  注意：片键也是查询时常用的一个索引。</p><h3 id="（1）-递增片键"><a href="#（1）-递增片键" class="headerlink" title="（1） 递增片键"></a>（1） 递增片键</h3><p>   这类片键比较常见，比如使用时间戳，日期，自增的主键，ObjectId，_id等，此类片键的写入操作集中在一个分片服务器上，写入不具有分散性，这会导致单台服务器压力较大，但分割比较容易，这台服务器可能会成为性能瓶颈。  </p><p>递增片键的创建，对foo数据库的bar集合使用timestamp时间戳分片  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; use foo</span><br><span class="line">mongos&gt; db.bar.ensureIndex(&#123;"timestamp":1&#125;)</span><br><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.bar",&#123;"timestamp":1&#125;)</span><br><span class="line">&#123; "collectionsharded" : "foo.bar", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure><h3 id="（2）-哈希片键"><a href="#（2）-哈希片键" class="headerlink" title="（2） 哈希片键"></a>（2） 哈希片键</h3><p>   使用一个哈希索引字段作为片键，优点是使数据在各节点分布比较均匀，数据写入可随机分发到每个分片服务器上，把写入的压力分散到了各个服务器上。但是读也是随机的，可能会命中更多的分片，一般具有随机性的片键（如密码，哈希，MD5）查询隔离性能比较差。   </p><p>哈希片键的创建，对GridFS的chunks集合使用files_id哈希分片</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; db.bar.ensureIndex(&#123;"files_id":"hashed"&#125;)</span><br><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.fs.chunks",&#123;"files_id":"hashed"&#125;)</span><br><span class="line">&#123; "collectionsharded" : " foo.fs.chunks ", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-组合片键"><a href="#（3）-组合片键" class="headerlink" title="（3） 组合片键"></a>（3） 组合片键</h3><p>  数据库中没有比较合适的片键供选择，或者是打算使用的片键基数太小（即变化少如星期只有7天可变化），可以选另一个字段使用组合片键，甚至可以添加冗余字段来组合。一般是粗粒度+细粒度进行组合。 </p><p>组合片键的创建，对GridFS的chunks集合使用files_id和n组合分片</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.fs.chunks",&#123;"files_id":1, "n":1&#125;)</span><br><span class="line">&#123; "collectionsharded" : " foo.fs.chunks ", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-标签分片"><a href="#（4）-标签分片" class="headerlink" title="（4） 标签分片"></a>（4） 标签分片</h3><p>  数据存储在指定的分片服务器上，可以为分片添加tag标签，然后指定相应的tag，比如让10.<em>.</em>.<em>(T)出现在shard0000上，11.</em>.<em>.</em>(Q)出现在shard0001或shard0002上，就可以使用tag让均衡器指定分发。</p><p>标签分片的创建</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongos &gt; sh.addShardTag("shard0000", "T")</span><br><span class="line">mongos &gt; sh.addShardTag("shard0001", "Q")</span><br><span class="line">mongos &gt; sh.addShardTag("shard0002", "Q")</span><br><span class="line">mongos&gt; sh.addTagRange("foo.ips",&#123; "ip": "010.000.000.000 ", … , "ip": "011.000.000.000 "&#125;&#125;, "T")</span><br><span class="line">mongos&gt; sh.addTagRange("foo.ips",&#123; "ip": "011.000.000.000 ", … , "ip": "012.000.000.000 "&#125;&#125;, "Q")</span><br></pre></td></tr></table></figure><h3 id="3．片键选择策略"><a href="#3．片键选择策略" class="headerlink" title="3．片键选择策略"></a>3．片键选择策略</h3><p>   大致了解了片键的种类，那么怎么选择片键呢？无非从两个方面考虑，数据的查询和写入，最好的效果就是数据查询时能命中更少的分片，数据写入时能够随机的写入每个分片，关键在于如何权衡性能和负载。  </p><p>如何选择片键主要从下面几个问题考虑：<br>（1）首先确定一个经常性查询的字段<br>（2）找到影响这些操作性能的关键点<br>（3）如果选的字段基数比较小，添加一个粒度细的字段  </p><p>   怎么选择，如何权衡，跟具体的业务以及数据类型都有关系，具体问题具体分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1．分片&quot;&gt;&lt;a href=&quot;#1．分片&quot; class=&quot;headerlink&quot; title=&quot;1．分片&quot;&gt;&lt;/a&gt;1．分片&lt;/h2&gt;&lt;p&gt;   分片是什么？分片就是将数据存储在多个机器上。当数据集超过单台服务器的容量，服务器的内存，磁盘IO都会有问题，即超过单台
      
    
    </summary>
    
    
      <category term="mongodb" scheme="https://yzdzh.github.io/categories/mongodb/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB之分片集群与复制集</title>
    <link href="https://yzdzh.github.io/post/3134727742.html"/>
    <id>https://yzdzh.github.io/post/3134727742.html</id>
    <published>2020-05-03T13:15:00.000Z</published>
    <updated>2020-05-03T13:20:02.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p>分片集群是将数据存储在多台机器上的操作，主要由查询路由mongos、分片、配置服务器组成。<br>●查询路由根据配置服务器上的元数据将请求分发到相应的分片上，本身不存储集群的元数据，只是缓存在内存中。<br>●分片用来存储数据块。数据集根据分片键将集合分割为数据块，存储在不同的分片上。在生产环境下，通常一个分片由一个复制集组成。<br>●配置服务器存储集群的元数据，包括数据与分片的映射关系，配置服务器一旦挂掉，集群将无法工作。<br><strong>注意：</strong><br>●当mongos重启时，会从配置服务器读取元数据更新自己缓存的元数据<br>●当分割数据时或者在分片间移动数据时会写配置服务器。<br>●在分片集群中，配置服务器可以采用复制集的架构，但复制集中不允许有仲裁节点和延时节点，且buildindexes必须设为true。<br>●集合的数据分布在多个分片上，如果某个分片失效，查询会返回错误，可以通过为查询指定partial选项，允许接受不完整的数据<br><strong>作用</strong><br><strong>单台机器无法满足存储需求，内存、磁盘空间不够，读写吞吐量不够。</strong></p><h3 id="1-2、如何维护数据均衡分布"><a href="#1-2、如何维护数据均衡分布" class="headerlink" title="1.2、如何维护数据均衡分布"></a>1.2、如何维护数据均衡分布</h3><p><strong>集群使用分割器和平衡器两个后台进程维护数据均匀分布。</strong></p><h4 id="分割器"><a href="#分割器" class="headerlink" title="分割器"></a>分割器</h4><p>●分割器的作用是防止数据块变大，数据块大小默认是64MB，当超过64MB时，分割器会将其一分为二。<br>●分割的对象不是实际的数据，而是元数据，只是在逻辑上进行逻辑块的划分，不会影响到实际数据的分布<br>●数据块太小会产生大量块，容易使集群不平衡，导致数据块频繁移动，降低集群性能，元数据增加，降低查询效率<br>●数据块太大，会减小移动频率，元数据少，有利于数据查询，但一旦移动，会花费很长时间<br>●并不是所有的集合都会分片，没有被分片的集合都存储在同一个主分片上<br>●只有对数据库和集合开启分片后，数据才会在不同分片上分布，否则只存储在主分片上<br>●插入和更新操作都有可能引发分割  </p><h4 id="平衡器"><a href="#平衡器" class="headerlink" title="平衡器"></a>平衡器</h4><p>●平衡器的作用是管理数据块的移动。<br>●当集群中数据块的分布达到移动阈值时，平衡器会移动数据块。<br>●增加或减少分片或增删数据也会使平衡器移动数据块  </p><h3 id="1-3数据块如何存储在相应分片上"><a href="#1-3数据块如何存储在相应分片上" class="headerlink" title="1.3数据块如何存储在相应分片上"></a>1.3数据块如何存储在相应分片上</h3><p>每个需要被分片的集合都需要指定索引字段作为分片键，mongodb使用<strong>区间分区</strong>或<strong>哈希分区</strong>算法根据分片键将数据分割为数据块。  </p><h4 id="区间分区"><a href="#区间分区" class="headerlink" title="区间分区"></a>区间分区</h4><p><strong>数据块覆盖一段子区间，任何分片键都会被某一段覆盖</strong><br><strong>优缺点</strong><br><strong>区间分区支持更好的range查询，通过分片键查询，查询路由可以很容易的判断出哪些数据块含有查询需要数据，并将请求分配到的分片上。</strong><br><strong>区间分区使数据分布不均匀</strong>  </p><h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p><strong>根据分片键的哈希值进行数据的分配。<br>优缺点<br>数据随机分配到不同的数据块<br>在进行range查询时，由于相邻数据分布在不同分片上，导致访问很多分片</strong><br><strong>注意</strong><br>●分片键不能是多键索引，即索引字段的值不能是数组<br>●分片键一旦被指定，不能被修改为其他字段，同时分片键的字段值也不能被修改<br>●如果集群的写操作比较多，可以使用哈希分区，将数据均匀分配到节点上，将写操作均匀应用与集群，<br>如果集群读操作比较多，可以使用区间分区，将相邻数据分到同一节点上，便于查询<br>●如果查询时没有指定索引字段，查询路由会将请求分发到所有节点上，等待返回结果，查询效率低<br>如果查询时指定了索引字段，查询路由会将请求分发到少数节点上，查询效率高  </p><h3 id="1-4、数据迁移过程"><a href="#1-4、数据迁移过程" class="headerlink" title="1.4、数据迁移过程"></a>1.4、数据迁移过程</h3><p>●平衡器向源节点发送movechunk指令<br>●源节点移动指定数据块，在迁移期间，数据块的读写操作仍路由到源节点<br>●目的节点如果没有需要的索引，此时会构建索引<br>●目的节点开始请求数据块中的数据，保存在本地<br>●在迁移期间，源节点上的数据如果发生变化，在迁移完之后，目的节点会同步源节点上变更的数据<br>●同步结束后，目的节点会与配置服务器建立连接，配置服务器更新元数据，此期间源节点阻塞写操作<br>●源节点上的旧数据被删除  </p><h3 id="1-5、备份数据"><a href="#1-5、备份数据" class="headerlink" title="1.5、备份数据"></a>1.5、备份数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h dbhost -d dbname -o directory 命令格式</span><br><span class="line">mongodump -h 127.0.0.1：28002 -d <span class="built_in">test</span> -o /home/backup</span><br></pre></td></tr></table></figure><p>将本机数据库test中数据备份到/home/backup下<br>恢复数据<br>mongorestore -h dbhost -d dbname –directoryperdb dbdirectory dbdirectory为备份数据所在位置  </p><h2 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h2><h3 id="2-1、概念与特性"><a href="#2-1、概念与特性" class="headerlink" title="2.1、概念与特性"></a>2.1、概念与特性</h3><p><strong>概念<br>复制集是一组具有相同数据的mongod实例，包含主节点以及从节点。集群中任何时候只有一个主节点，主节点将数据变更操作写到oplog（封顶表）中，从节点读取oplog，并将oplog中的操作应用的本地数据，从而实现数据同步。</strong>  </p><p><strong>特性</strong><br>●<strong>异步复制</strong><br>从节点并不是实时复制主节点中的数据<br><strong>●自动容灾</strong><br>主节点宕机，主动发起选举<br><strong>●读操作</strong><br>从从节点上读到的数据可能并不是最新的  </p><h3 id="2-2、复制集成员"><a href="#2-2、复制集成员" class="headerlink" title="2.2、复制集成员"></a>2.2、复制集成员</h3><p>复** <strong>制集最多包含</strong>50个节点<strong>，最多</strong>只能有7个可以投票<strong>。包含以下节点类型<br>●</strong>主节点primary**<br>可以执行读写操作，所有节点均可以执行读操作。默认情况下，读请求只会发送给主节点，可以通过read preference设置。主节点的优先级priority至少为1。<br>●<strong>从节点secondary</strong><br>只可以执行读操作。从节点通过与主节点同步，实现备份数据的功能，复制集至少有一个从节点。通过配置复制集的配置文件可以设置从节点是否参与选举（vote=0）以及是否可以被选举为主节点（priority=0）优先级priority为0的节点不能发起选举，不能被选举为主节点，但可以投票。<br>●<strong>隐藏节点</strong><br>通过设置从节点的hidden属性，可以对客户端隐藏节点，不接受读写请求，无法被选举为主节点（priority=0），只能投票，主要用于备份数据。<br>●<strong>延时节点</strong><br>通过设置隐藏节点的slaveDelay属性可以使节点延时一定时间从主节点复制数据，可以起到保护数据的作用。延时节点是在隐藏节点的基础上，多了一个延时属性。<br>●<strong>仲裁节点Arbiter</strong><br>本身不存储数据，不能被选举为主节点，只能投票，仲裁节点主要用于使复制集中节点个数为奇数，从而容易达到多数派。仲裁节点只消耗极少的资源，但不要与主节点、从节点部署在同一个物理节点上。<br>●<strong>非投票节点</strong><br>不参与投票，但存储数据，可以接受读操作  </p><h3 id="2-3、复制集管理"><a href="#2-3、复制集管理" class="headerlink" title="2.3、复制集管理"></a>2.3、复制集管理</h3><p>●use admin切换到admin数据库<br>●config={_id:”myset”,members:[{“_id”:0,”host”:”127.0.0.1:28001”,”priority”:2},{“_id”:1,”host”:”127.0.0.1:28002”,”priority”:1}]}<br>●rs.initiate(config)<br>修改复制集配置<br>●cfg=rs.conf()<br>●cfg.members[0].priority=1<br>●rs.reconfig(cfg)<br>复制集维护<br>将配置文件中的replset注释掉，从而以单机模式启动复制集，维护完毕后再加入复制集。  </p><h3 id="2-4、大多数原则"><a href="#2-4、大多数原则" class="headerlink" title="2.4、大多数原则"></a>2.4、大多数原则</h3><p><strong>概念</strong><br>如果复制集中的节点个数为N，则大多数为N/2+1（N/2向下取整），当复制集中存活节点数小于大多数时，不存在主节点，无法提供写服务。    </p><p><strong>作用</strong><br>大多数原则保证了，在任何时刻复制集中的主节点个数不会超过一个。比如复制集部署在两个机房，两个机房通信发生故障，不含有主节点的机房会选举出一个主节点，等到故障恢复，复制集就会存在两个主节点，无法保证数据的一致性。  </p><h3 id="2-5、选举"><a href="#2-5、选举" class="headerlink" title="2.5、选举"></a>2.5、选举</h3><p><strong>选举的前提条件</strong><br>复制集满足大多数原则。在选举的过程中，复制集无法进行写操作。  </p><p><strong>何时会引发选举</strong><br>●复制集初始化时或被重新配置后<br>●主节点宕机或主节点网络不可达，即大多数节点无法连接主节点<br>●人为将主节点降为从节点，执行rs.stepDown(n)命令<br>●有更高优先级的节点加入复制集  </p><p><strong>选举特点</strong><br>●优先级高的节点优先被选为主节点<br>●具有最高optime的节点被选为主节点<br>●如果优先级高的节点不具有最新的optime，那么首先会同步主节点的oplog<br>●优先级为0的节点无法发起选举，且无法成为主节点，只能投票。<br>●所有成员都可以否决选举，包括不投票的节点Non-voting  </p><p><strong>何时否决选举</strong><br>●发起选举的节点不包含最新数据<br>●发起选举的节点优先级比其他节点低<br>●发起选举的节点没有持有最高的optime  </p><h3 id="2-6、数据回滚"><a href="#2-6、数据回滚" class="headerlink" title="2.6、数据回滚"></a>2.6、数据回滚</h3><p>概念：在主节点失效之前，从节点并未全部复制主节点上的数据，原先的主节点在选举出新的主节点后重新加入复制集，会导致旧主节点与新主节点数据不一致，旧主节点会将不一致的数据回滚，从而与主节点数据保持一致。  </p><p>避免数据回滚<br>默认情况下，在主节点上写入成功后，就会向客户端返回结果，可能造成回滚，客户端可以修改写策略writeconcern为向大多数节点写入成功后才返回结果。  </p><h3 id="2-7、读写策略"><a href="#2-7、读写策略" class="headerlink" title="2.7、读写策略"></a>2.7、读写策略</h3><p>writeconcern：不等待主节点写入成功，客户端就返回结果；等待主节点写入成功，就返回结果；等到大多数节点写入成功，才返回结果<br>readconcern：只读主节点、只读从节点、优先主节点、优先从节点、读网络延迟最小的节点  </p><h3 id="2-8、复制集优缺点"><a href="#2-8、复制集优缺点" class="headerlink" title="2.8、复制集优缺点"></a>2.8、复制集优缺点</h3><p><strong>优点</strong><br>●自动容灾。主节点宕机，通过投票选举主节点，保证数据安全<br>●自动备份数据，无需人工干预<br>●易于扩展<br>●数据可靠性高<br><strong>缺点</strong><br>●消耗资源高<br>●不能解决负载均衡的问题<br>●客户端读到的数据可能并未持久化 ，比如：客户端可以读到最新写入的数据，但数据有可能存在磁盘写入失败的可能；客户端读到的数据可能发生rolled back  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分片集群&quot;&gt;&lt;a href=&quot;#分片集群&quot; class=&quot;headerlink&quot; title=&quot;分片集群&quot;&gt;&lt;/a&gt;分片集群&lt;/h2&gt;&lt;h3 id=&quot;1-1、概念&quot;&gt;&lt;a href=&quot;#1-1、概念&quot; class=&quot;headerlink&quot; title=&quot;1.1、概
      
    
    </summary>
    
    
      <category term="mongodb" scheme="https://yzdzh.github.io/categories/mongodb/"/>
    
    
  </entry>
  
  <entry>
    <title>vagrant虚拟机共享目录加速</title>
    <link href="https://yzdzh.github.io/post/1735609695.html"/>
    <id>https://yzdzh.github.io/post/1735609695.html</id>
    <published>2020-04-25T13:13:00.000Z</published>
    <updated>2020-04-25T13:15:31.985Z</updated>
    
    <content type="html"><![CDATA[<p>vagrant一般都是搭配VirtualBox虚拟机的，但是vagrant默认启动VirtualBox虚拟机的目录共享方式是VirtualBox方式，这种方式性能差，如果文件夹里面的文件数量不多的情况下影响还不是很大，如果数量多的话会很慢，网上说的可以通过安装vagrant一款插件使共享目录以”nfs”方式，速度会变快很多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-winnfsd</span><br></pre></td></tr></table></figure><p>但是我实际上发现还有另外一款vagrant插件能使共享目录性能更高。<br>这款插件不但能使共享目录支持”nfs”方式而且还有其他系统优化，使实际共享目录性能更高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br></pre></td></tr></table></figure><p>不管是哪一款vagant插件都需要在对应的共享目录后面加”, type: “nfs””才能生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder <span class="string">"D:/xiangmu"</span>,<span class="string">"/home/wwwroot"</span> , <span class="built_in">type</span>: <span class="string">"nfs"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vagrant一般都是搭配VirtualBox虚拟机的，但是vagrant默认启动VirtualBox虚拟机的目录共享方式是VirtualBox方式，这种方式性能差，如果文件夹里面的文件数量不多的情况下影响还不是很大，如果数量多的话会很慢，网上说的可以通过安装vagrant
      
    
    </summary>
    
    
      <category term="vagrant" scheme="https://yzdzh.github.io/categories/vagrant/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb添加账号密码</title>
    <link href="https://yzdzh.github.io/post/2802551252.html"/>
    <id>https://yzdzh.github.io/post/2802551252.html</id>
    <published>2020-04-21T02:52:00.000Z</published>
    <updated>2020-04-21T02:52:45.538Z</updated>
    
    <content type="html"><![CDATA[<p>添加账号密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user:<span class="string">"root"</span>,<span class="built_in">pwd</span>:<span class="string">""</span>,roles:[<span class="string">"root"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.createUser(&#123;user:<span class="string">'root'</span>,<span class="built_in">pwd</span>:<span class="string">'root'</span>,roles:[<span class="string">'readWrite'</span>]&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;添加账号密码&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="mongodb" scheme="https://yzdzh.github.io/categories/mongodb/"/>
    
    
  </entry>
  
</feed>
