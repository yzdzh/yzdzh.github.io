[{"title":"ab压测工具","date":"2021-12-31T19:05:00.000Z","path":"post/984256984.html","text":"ubuntu安装ab 1apt-get install apache2-utils centos安装ab 1yum install httpd-tools ab 测试命令 1ab -n 100 -c 10 http://test.com/ 其中－n表示请求数，－c表示并发数 原文链接：https://www.jianshu.com/p/43d04d8baaf7","tags":[]},{"title":"linux网络带宽监控工具","date":"2021-12-31T18:02:00.000Z","path":"post/3478081417.html","text":"centos安装命令 1yum install dstat -y 查看命令 1dstat -cdnrsy 效果如下图： 分组 分组含义及子项字段含义 CPU状态 CPU的使用率。显示了用户占比，系统占比、空闲占比、等待占比、硬中断和软中断情况。 磁盘统计 磁盘的读写，分别显示磁盘的读、写总数。 网络统计 网络设备发送和接受的数据，分别显示的网络收、发数据总数。 分页统计 系统的分页活动。分别显示换入（in）和换出（out）。 系统统计 统计中断（int）和上下文切换（csw）。 常见选项 12345678910111213141516171819-c：显示CPU系统占用，用户占用，空闲，等待，中断，软件中断等信息。-C：当有多个CPU时候，此参数可按需分别显示cpu状态，例：-C 0,1 是显示cpu0和cpu1的信息。-d：显示磁盘读写数据大小。-D hda,total：include hda and total。-n：显示网络状态。-N eth1,total：有多块网卡时，指定要显示的网卡。-l：显示系统负载情况。-m：显示内存使用情况。-g：显示页面使用情况。-p：显示进程状态。-s：显示交换分区使用情况。-S：类似D/N。-r：I/O请求情况。-y：系统状态。--ipc：显示ipc消息队列，信号等信息。--socket：用来显示tcp udp端口状态。-a：此为默认选项，等同于-cdngy。-v：等同于 -pmgdsc -D total。--output 文件：此选项也比较有用，可以把状态信息以csv的格式重定向到指定的文件中，以便日后查看。例：dstat --output /root/dstat.csv &amp; 此时让程序默默的在后台运行并把结果输出到/root/dstat.csv文件中。 原文链接：https://blog.csdn.net/sinat_34789167/article/details/80986709","tags":[]},{"title":"k8s-集群搭建的三种方式和区别，kubeadm、minikube，二进制包","date":"2021-12-30T19:47:00.000Z","path":"post/710540892.html","text":"k8s-集群搭建的三种方式，目前主流的搭建k8s集群的方式有kubeadm、minikube，二进制包。 1、kubeadm 是一个工具，用于快速搭建kubernetes集群，目前应该是比较方便和推荐的，简单易用 kubeadm是Kubernetes 1.4开始新增的特性 kubeadm init 以及 kubeadm join 这两个命令可以快速创建 kubernetes 集群 2、minikube 一般用于本地开发、测试和学习，不能用于生产环境 是一个工具，minikube快速搭建一个运行在本地的单节点的Kubernetes 3、二进制包 在官网下载相关的组件的二进制包，上面的两个是工具，可以快速搭建集群，也就是相当于用程序脚本帮我们装好了集群，前两者属于自动部署，简化部署操作，自动部署屏蔽了很多细节，使得对各个模块感知很少，遇到问题很难排查，如果手动安装，对kubernetes理解也会更全面。 目前生产环境的主流搭建方式，已在生产环境验证，kubeadm也可以搭建生产环境，不过kubeadm应该还没有被大规模在生产环境验证 参考原文：https://www.cnblogs.com/albertzhangyu/p/13446528.html","tags":[]},{"title":"linux中root账号也无法修改文件权限解决方法","date":"2021-12-03T19:21:00.000Z","path":"post/1494107583.html","text":"一般是被用chattr命令锁住文件 1、lsattr命令查看文件的属性执行命令lsattr authorized_keys查看当前文件属性，可以发现有i和a两个属性。 2、去掉锁住的权限去掉lsattr命令查看到的i和a两个属性 1chattr -ia authorized_keys 3、还原权限修改完后还原文件权限 1chattr +ia authorized_keys 借鉴于原文：https://www.cnblogs.com/cpl9412290130/p/11592803.htmlhttps://www.runoob.com/linux/linux-comm-chattr.html","tags":[]},{"title":"mongodb容器的数据导入和导出","date":"2021-12-03T19:01:00.000Z","path":"post/381300251.html","text":"1、mongodump导出备份1)、执行mongodump命令1docker exec -it -u root com_mongo mongodump -h 127.0.0.1:27017 -d ag_mongo -u root -p 123456 --authenticationDatabase admin -o /mongo_sql_back 注：-h 地址-d 数据库名称-u 用户名-p 密码-o 输出地址–authenticationDatabase admin 验证账户的数据库 2)、将备份文件从里面cp出来（如果已经容器目录映射，则忽略此步骤）123docker cp com_mongo:mongo_sql_back /mongo_sql_backdocker cp 容器名:容器内导出数据库文件夹 宿主机保存文件夹 2、mongorestore恢复数据库1docker exec -it -u root com_mongo mongorestore -h 127.0.0.1:27017 -d ag_mongo --dir /mongo_sql_back/ag_mongo -u root -p 123456 --authenticationDatabase admin 注：-h 地址-d 数据库名称-u 用户名-p 密码–dir 导入的数据库文件夹–authenticationDatabase admin 验证账户的数据库 借鉴于原文：https://www.jianshu.com/p/398bcccd7981","tags":[]},{"title":"mysql容器的数据导入和导出","date":"2021-12-03T18:30:00.000Z","path":"post/1607203207.html","text":"1、mysqldump导出备份123docker exec -it com_mysql mysqldump -c -uroot -p123456 app_agent &gt; app_agent.sqldocker exec -it com_mysql【docker容器名称/ID】 mysqldump -uroot -p123456【数据库密码】 test_db【数据库名称】 &gt; /opt/sql_bak/test_db.sql【导出表格路径】 选项说明 参数名 缩写 含义 –host -h 服务器IP地址 –port -P 服务器端口号 –user -u MySQL 用户名 –pasword -p MySQL 密码 –databases 指定要备份的数据库 –all-databases 备份mysql服务器上的所有数据库 –compact -c 压缩模式，产生更少的输出 –comments 添加注释信息 –complete-insert 输出完成的插入语句 –lock-tables 备份前，锁定所有数据库表 –no-create-db/–no-create-info 禁止生成创建数据库语句 –force 当出现错误时仍然继续备份操作 –default-character-set 指定默认字符集 –add-locks 备份数据库表时锁定数据库表 2、导入数据库123docker exec -i com_mysql mysqldump -c -uroot -p123456 app_agent &lt; app_agent.sqldocker exec -i com_mysql【docker容器名称/ID】 mysqltest_db_copy【数据库名称】 &lt; /opt/sql_bak/test_db.sql【本地数据表路径】 注意：这里需要将参数 -it 更换为 -i ，否则会报错：”the input device is not a TTY” 借鉴于原文：https://blog.csdn.net/qq_27565769/article/details/80731271","tags":[]},{"title":"docker容器以ROOT账号登录（获取ROOT权限/ROOT密码）","date":"2021-12-03T18:27:00.000Z","path":"post/3568385113.html","text":"第一步：查看容器的CONTAINER ID1docker ps 第二步：获取root权限，例如需要进入的CONTAINER ID为4650e8d1bcca1docker exec -it -u root 4650e8d1bcca bash","tags":[]},{"title":"ssh生成公钥私钥对和远程免密登录","date":"2021-11-07T19:38:00.000Z","path":"post/588796899.html","text":"1、在本地机器上使用ssh-keygen产生公钥私钥对123456789本地先安装git客户端，终端执行ssh-keygen -t rsa -C \"yourname\"一路回车全局设置git 用户信息git config --global user.email yournamegit config --global user.name yournamechmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub 2、用ssh-copy-id将公钥复制到远程机器中123ssh-copy-id -i .ssh/id_rsa.pub 用户名字@192.168.x.xxx注意: ssh-copy-id 将key写到远程机器的 ~/ .ssh/authorized_key.文件中 3、登录到远程机器不用输入密码12ssh 用户名字@192.168.x.xxxLast login: Sun Nov 16 17:22:33 2008 from 192.168.1.2","tags":[]},{"title":"Linux下清除docker容器终端输出的全部日志","date":"2021-11-07T12:33:00.000Z","path":"post/3848110738.html","text":"查询当前目录下所有文件大小 1du -h --max-depth=1 查询当前目录下所有文件大小 1ls -lh 清除docker容器终端输出的全部日志 1truncate -s 0 /var/lib/docker/containers/*/*-json.log","tags":[]},{"title":"win10开机设置wsl子系统固定内网ip","date":"2021-10-27T18:54:00.000Z","path":"post/3748404520.html","text":"wsl的liunx子系统虽然很优秀，但是每次重启都会重新分配内网ip，但实际开发中，本地环境还是需要固定内网ip比较方便，但是wsl不支持设置固定内网ip，折中办法就是每次开机或重启是将内网ip设置为指定ip。 1、自制bat脚本将下面的命令复制到.bat后缀的文件中，如fix_wsl_ip.bat 12345678910111213141516171819202122232425262728@echo off:: 获取管理员权限setlocalset uac=~uac_permission_tmp_%random%md \"%SystemRoot%\\system32\\%uac%\" 2&gt;nulif %errorlevel%==0 ( rd \"%SystemRoot%\\system32\\%uac%\" &gt;nul 2&gt;nul ) else ( echo set uac = CreateObject^(\"Shell.Application\"^)&gt;\"%temp%\\%uac%.vbs\" echo uac.ShellExecute \"%~s0\",\"\",\"\",\"runas\",1 &gt;&gt;\"%temp%\\%uac%.vbs\" echo WScript.Quit &gt;&gt;\"%temp%\\%uac%.vbs\" \"%temp%\\%uac%.vbs\" /f del /f /q \"%temp%\\%uac%.vbs\" &amp; exit )endlocal# 给wsl 中的ubuntu 设置ipv4 的ip 192.168.33.10，要在windows中访问wsl就用此ipwsl -d Ubuntu-20.04 -u root ip addr add 192.168.33.10/24 broadcast 192.168.33.255 dev eth0 label eth0:1# 给windows 设置ipv4 的ip 192.168.33.11，要在wsl中访问宿主机就用此ipnetsh interface ip add address \"vEthernet (WSL)\" 192.168.33.11 255.255.255.0 注意的是bat中的给wsl中的ubuntu设置固定ip中的Ubuntu-20.04为ubuntu的版本名称，具体版本名可以直接wsl -l命令查询，如图： 2、查看win10宿主机和子系统是否ip设置成功右键管理员运行bat文件（一定要管理员权限运行！），然后查看是否设置成功。 3、设置bat脚本开机自动启动1、设置bat脚本开机自动启动”窗口+R”打开命令窗口，并且输入命令Shell:startup，点击确定按钮运行该命令2、将自制的bat启动脚本快捷方式放入文件夹中","tags":[]},{"title":"WSL子系统修改默认root登入","date":"2021-10-21T19:13:00.000Z","path":"post/2798337741.html","text":"一般子系统就是自己用，每次启动还要人工切到root权限，很是麻烦，如何让Win10的WSL子系统默认root登入呢？ 命令行操作方法如下：1、Windows进入cmd命令行，执行指令进入Apps目录： 1cd %HOMEPATH%\\AppData\\Local\\Microsoft\\WindowsApps 2、执行指令列出文件夹： 1dir 输出示例： 1CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc 3、进入定位的子系统文件夹： 1cd CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc 4、执行指令列出文件夹： 1dir 输出示例： 1ubuntu2004.exe 5、执行指令修改默认用户为root： 1ubuntu2004.exe config --default-user root 6、重启WSL子系统即可看到效果，默认登入的就是root账户了。 原文链接：https://shipengliang.com/software-exp/win10-wsl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%85%A5.html","tags":[]},{"title":"基于win10 + wsl + ubuntu + terminal的本地开发环境","date":"2021-10-19T20:13:00.000Z","path":"post/2270783465.html","text":"先来一堆废话背景介绍：之前都是使用vagrant+VirtualBox做为本地开发环境，一直也都是挺不错的，后来在新公司认识到win10 + wsl + ubuntu + terminal的开发环境，相较起vagrant+VirtualBox，优势和劣势如下：优势：1、可以直接将项目代码放入linux环境，而不是通过目录映射的方式。目录映射一方面代码编译速度慢，另一方面有可能会出现因为window和linux环境文件编码不同而导致的编译失败问题（这点本人在执行compose等操作时曾经吃过亏）。2、hosts文件和.ssh文件夹可实现自动共享，不用本地定义个域名要window写一次，虚拟机里面的hosts文件也写一份。 劣势：1、代码是放在子系统虚拟机中的，如果子系统突然奔溃修复不了的话很可能会导致代码没及时上传git而丢失白写的情况。所以需要养成每天下班前上传代码的好习惯。2、占用内存大，本人实际开发中实际占内存10GB多点，加上其它开发软件，占了19GB左右（幸亏公司电脑内存是32GB）。 环境搭建流程：1. 打开“Linux 子系统”与“虚拟机平台”选中上图圈出的两个项目，点击“确定”。 或者，也可以通过命令行操作。以管理员身份执行 CMD 或 PowerShell，执行如下两个命令： 12dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2. 安装 WSL 内核点击下面的按钮从微软下载最新的 x64 或 arm64 WSL 内核：最新版 x64 WSL 2 内核最新版 arm64 wsl 2 内核 下载并安装 MSI 包即可。 3. 设置 WSL 默认版本为 2打开 CMD 或 PowerShell，执行如下的命令： 1wsl --set-default-version 2 4.安装ubuntu 和 terminal直接从Microsoft store商店直接搜索下载即可，建议ubuntu版本为20.04或以上。 5.安装docker直接下载安装即可（建议版本为4.1）https://docs.docker.com/docker-for-windows/release-notes/#docker-desktop-310 至此，虚拟机环境搭建完毕。 注意必看：1、ubuntu默认是安装时创建的账号，非root账号，这给开发带来不便，如何设置默认root登入可以看我另一篇文章： WSL子系统修改默认root登入 2、wsl内子系统的ip每次启动都会重置，这给开发带来不便，如何解决这个问题可以看我另一篇文章： win10开机设置wsl子系统固定内网ip 3、鄙人本地的lnmp环境是使用的是docker-compose.yaml一键安装及配置文件和目录挂载，git地址为(私人仓库不对外开放)：https://github.com/yzdzh/docker_php_dev 4.安装docker-compose命令如下: 1234(1). 下载docker-composecurl -L \"https://github.com/docker/compose/releases/download/1.28.3/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose (2). 修改执行权限chmod +x /usr/local/bin/docker-compose","tags":[]},{"title":"docker安装软件环境集合","date":"2021-04-26T16:15:00.000Z","path":"post/527254571.html","text":"有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。 1、hexo（私有仓库，不提供开放）本人私有博客打包，仅做个人笔记记录，不提供开放 1、下载镜像 1docker pull yizhidaozuihou/hexo2、创建启动容器 1docker run -d --name hexo -it -p 4000:4000 -w /home/wwwroot/hexo -v /home/wwwroot/hexo:/home/wwwroot/hexo --entrypoint=\"/home/wwwroot/hexo/hexo-sever.sh\" yizhidaozuihou/hexo 注： 1)、第一次启动容器时需要将hexo-sever.sh中的#npm install解除注释，初始化node_modules 2、elasticsearch基于elasticsearch7.12版本打包，允许跨域操作1、下载镜像 1docker pull yizhidaozuihou/es2、创建用户定义的网络（用于连接到连接到同一网络的其他服务（例如，Kibana）） 1docker network create somenetwork3、创建挂载的目录 1234567891011mkdir -p /mydata/elasticsearch/data//生产环境才需要执行以下命令（挂载配置文件和插件目录）mkdir -p /mydata/elasticsearch/configecho \"http.host: 0.0.0.0\" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.ymlmkdir -p /mydata/elasticsearch/config/mydata/elasticsearch/plugins//需要设置挂载目录可读写权限，不然docker容器启动不了chmod -R 777 mydata/elasticsearch/4、创建容器并启动 12345//测试环境docker（直接挂载数据库就行了）docker run -d --name es --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx128m\" -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data yizhidaozuihou/es//生产环境docker(需要挂载配置文件和插件目录)docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx128m\" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件，如ik，而数据挂载需要权限，需要设置data文件的权限为可读可写,需要下边的指令。chmod -R 777 要修改的路径 -e “discovery.type=single-node” 设置为单节点特别注意：-e ES_JAVA_OPTS=”-Xms256m -Xmx256m” \\ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES 3、elasticsearch-head 123//基于elasticsearch-head5版本打包，兼容elasticsearch7.X版本docker pull yizhidaozuihou/es-headdocker run -d --name es-head -p 9100:9100 yizhidaozuihou/es-head","tags":[]},{"title":"docker打包自定义镜像并上传docker hub","date":"2021-04-26T08:05:00.000Z","path":"post/1624279696.html","text":"docker打包自定义镜像并上传docker hub1、使用dockers commit命令来打包 dockers commit 容器名 要保存成的镜像名：版本名（若没有：版本名则直接默认为latest）例如 docker commit vser vs:v1 1docker commit 49ba413b3614 es 2、将刚刚commit 的镜像名 打包成特定的格式。例如：docker tag vs:v1 你docker的用户名/你dockerhub上创建的仓库名：版本号 （若无则默认为latest） 1docker tag es:v1 yizhidaozuihou/es 3、打包好后, 将镜像拉取到仓库 12docker push yizhidaozuihou/es注：如果未登录docker hub的话是不能push上传的，需要先 docker login 命令输入账号密码登录后才能push","tags":[]},{"title":"phpstrom实用插件集合","date":"2021-01-30T18:02:00.000Z","path":"post/1452351953.html","text":"以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。 1、中英文转换：translation快捷键 Ctrl+Shift+Y OR 选中需要翻译的文本，然后鼠标右键选择Translate2、拼写法转换：camelCase选中需要改变的变量 使用 快捷键 shift + alt + u ，变量就会改变，直到找到需要的格式。3、php 注释增强工具：PHP Annotation可以自动提示补全注解名和点击跳转追踪4、自动关联数组键输入和完成：deep-assoc-completion帮助完成数组参数 - 可以使用哪些键5、proto语法高亮追踪提示：Protocol Buffersproto语法高亮追踪提示，临时看其他项目不想安装依赖包时使用6、Chinese ​(Simplified)​ Language Pack / 中文语言包中文语言汉化包7、无限重置有效期插件：IDE Eval Reset需要先添加第三方仓库地址：https://plugins.zhile.io","tags":[]},{"title":"php获取指定前缀常量便捷操作方法","date":"2020-09-03T04:04:00.000Z","path":"post/4113924384.html","text":"例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 1、在model中定义的字段类型规范如下order_status字段的常量前缀都是ORDER_STATUS_，常量内容都是：[值，中文解释] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php/*** 仅为示例代码，实际三个封装方法可以直接放在基础类BaseModel里面所有model公用*/class Order extends BaseModel&#123; /** @var int 订单类型 */ const ORDER_STATUS_PAY_WAITING = [0,'待付款']; const ORDER_STATUS_PAY_SUCCESS = [1,'已付款']; const ORDER_STATUS_REFUNDED = [2,'已退款']; /** * 根据常量的前缀获取键值对数组（返回无指定key的集合的二维数组） * @param string $key 常量下标 * @return array [[0,'待付款'],[1,'已付款']] */ public static function getConstDesc(string $key): array &#123; $oClass = new \\ReflectionClass(static::class); $constAry = $oClass-&gt;getConstants(); $desc = []; foreach ($constAry as $const =&gt; $v) &#123; if (strpos($const, $key) === 0) &#123; $desc[] = $v; &#125; &#125; return $desc; &#125; /** * 根据常量的前缀获取键值对数组 (结果返回指定key，value字段名的二维数组) * @param string $key 常量下标 * @return array 二维数组，可以指定key和value的字段名 例：[['id'=&gt;0,'name'=&gt;'待付款'],['id'=&gt;1,'name'=&gt;'已付款']] */ public static function getConstSelect(string $key,string $key_field = 'id' , string $value_field = 'name'): array &#123; $const_list = self::getConstDesc($key); $desc = []; foreach ($const_list as $const =&gt; $v) &#123; $desc[] = [ $key_field=&gt;$v[0]??0, $value_field=&gt;$v[1]??'', ]; &#125; return $desc; &#125; /** * 根据常量的前缀获取键值对数组 (結果返回一维数组) * @param string $key 常量下标 * @return array 一维数组，key为索引第一位数，value为索引第二位数。 例：['key'=&gt;value,0=&gt;'待付款',1=&gt;'已付款'] */ public static function getConstPluck(string $key): array &#123; $oClass = new \\ReflectionClass(static::class); $constAry = $oClass-&gt;getConstants(); $desc = []; foreach ($constAry as $const =&gt; $v) &#123; if (strpos($const, $key) === 0) &#123; $desc[$v[0]] = $v[1]; &#125; &#125; return $desc; &#125;&#125; 调用方法示例： 1234567$getConstDesc = Order::getConstDesc('ORDER_STATUS_');$getConstSelect = Order::getConstSelect('ORDER_STATUS_');$getConstPluck = Order::getConstPluck('ORDER_STATUS_');if(empty(Order::getConstPluck('ORDER_STATUS_')[$params['order_status']]))&#123; throw new BusinessException(ErrorHelper::FAIL_CODE,'订单类型不存在');&#125;","tags":[]},{"title":"linux设置开机服务自动启动/关闭自动启动命令","date":"2020-08-20T10:48:00.000Z","path":"post/1924607937.html","text":"123[root@localhost ~]# chkconfig --list 显示开机可以自动启动的服务 [root@localhost ~]# chkconfig --add *** 添加开机自动启动***服务 [root@localhost ~]# chkconfig --del *** 删除开机自动启动***服务 参考地址：https://blog.csdn.net/weixin_34254823/article/details/92815942","tags":[]},{"title":"Mysql开启全部sql日志查询","date":"2020-08-12T10:11:00.000Z","path":"post/2712546463.html","text":"本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！ 1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置1234general_log=on#自动生成日志 0-不打开 1-打开general_log=1general_log_file=/system_log/mysql_sql.log 2、重启mysql1service mysql restart 3、查看日志是否打开1show variables where Variable_name=\"general_log\";","tags":[]},{"title":"golang之捕获异常","date":"2020-05-22T10:00:00.000Z","path":"post/2798837510.html","text":"系统内部错误：捕获错误，并提示。 使用了defer panic 和recover关键字 描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理 12345defer func()&#123; if errRecover := recover(); errRecover != nil&#123; fmt.Println(\"errRecover \" , errRecover ) &#125;&#125;()","tags":[]},{"title":"golang之基于zap开箱即用日志组件","date":"2020-05-19T09:34:00.000Z","path":"post/816087200.html","text":"logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显: 优雅的代码框架设计 使用简单 组件化的开发思路 灵活的输出方式 但是, 性能终究是忍痛舍弃 logrus 的“阿喀琉斯之踵”目前 golang 日志库的大众选择主要集中在: logrus, zap, zerolog. zap 和 zerolog 的性能都是优秀的, 但是从用法习惯上我更倾向于 zap. 简单介绍 Zap 的使用Zap 提供三种不同方式的输出(以 Info为 例) 123log.Info(\"hello zap\") // &#123;\"level\":\"info\",\"ts\":1576423173.016333,\"caller\":\"test_zap/main.go:28\",\"msg\":\"hello zap\"&#125;log.Infof(\"hello %s\", \"zap\") // &#123;\"level\":\"info\",\"ts\":1576423203.056074,\"caller\":\"test_zap/main.go:29\",\"msg\":\"hello zap\"&#125;log.Infow(\"hello zap\", \"field1\", \"value1\") //&#123;\"level\":\"info\",\"ts\":1576423203.0560799,\"caller\":\"test_zap/main.go:30\",\"msg\":\"hello zap\",\"field1\":\"value1\"&#125; 如果我们对 logrus 的 key-value 理论比较在意的话, 使用 zap infow 可以完美解决 Zap 使用起来不便利的地方 Zap 使用上不能像 logrus 那样开箱即用 使用者需要自己去组装相关函数 Zap 同样不提供日志切割的功能, 但是想添加上这个功能没有 logrus 那样便利 基于这些问题, 我封装了一套开箱即用的日志组件: https://github.com/yizhidaozuihou/log 打造 Zap 开箱即用日志组件提供的功能: 提供的功能: 像 logrus 一样, 全局的 Debug, Info … 函数 日志分割功能. 默认文件大小1024M，自动压缩, 最大有3个文件备份，备份保存时间7天, 不会打印日志被调用的文文件名和位置 日志默认会被分成五类文件：debug、info、warn、error、panic 都会打印在xxx.log. xxx.log.Request输出 request log 的地方(如果有需要的话) 使用方法 1go get github.com/yizhidaozuihou/log 例子 12345678910111213141516package mainimport \"github.com/yizhidaozuihou/log\"func main() &#123; // init log // set absolute path, and level // set output level // don't need request log // set log's caller using logOption log.Init(\"./test.log\", log.DebugLevel, false, log.SetCaller(true)) log.Info(\"hello george log\") // flush log.Sync() //output: &#123;\"level\":\"info\",\"ts\":\"2019-12-16T10:37:11.364+0800\",\"caller\":\"example/example.go:12\",\"msg\":\"hello george log\"&#125;&#125;","tags":[]},{"title":"golang个人总结好用库集合","date":"2020-05-18T18:37:00.000Z","path":"post/561152273.html","text":"以下是个人在实践工作中总结的好用库集合，持续不断更新中。。 一、json处理库http://wangzhuanglin.gitee.io/post/3838666233.html 二、配置文件处理库http://wangzhuanglin.gitee.io/post/132771847.html 三、日志库http://wangzhuanglin.gitee.io/post/816087200.html","tags":[]},{"title":"golang之viper操作库","date":"2020-05-18T08:58:00.000Z","path":"post/132771847.html","text":"Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。 这里记录下viper读取.env配置文件的具体代码 123456789viper.SetConfigName(\".env\") // 配置文件名称(无扩展名)viper.SetConfigType(\"env\") // 如果配置文件的名称中没有扩展名，则需要配置此项viper.AddConfigPath(\"./\") // 查找配置文件所在的路径err12 := viper.ReadInConfig() // 查找并读取配置文件if err12 != nil &#123; // 处理读取配置文件的错误 panic(fmt.Errorf(\"Fatal error config file: %s \\n\", err12))&#125;viper.SetDefault(\"DB_DRIVER\",55555)fmt.Println(777,viper.GetString(\"DB_DRIVER\")) 其他详细教程可以直接看go大神写的详细文章https://www.liwenzhou.com/posts/Go/viper_tutorial/https://learnku.com/articles/33908","tags":[]},{"title":"golang库集合","date":"2020-05-13T15:25:00.000Z","path":"post/3243567407.html","text":"golang用于创建和发送电子邮件的库douceur - HTML 邮件中的内联 CSSemail - 一个健壮的、灵活的 email 库Go-dkim - DKIM 库，用于对 email 进行签名和验证Go-imap - IMAP 库，用于客户端和服务器Go-message - 用于触雷互联网消息格式和邮件的库Gomail - Gomail 是一个非常简单且强大的库，用于发送电子邮件Hectane - 轻量级 SMTP 客户端，提供 HTTP APIhermes - 一个用于生成干净、响应式 HTML e-mail 的包MailHog - Email 及 SMTP 测试工具，具有 web 及 API 接口SendGrid - SendGrid 的 Go 语言库，用于发送电子邮件smtp - SMTP 服务器协议状态机 golang处理日期和时间的库carbon - 简单的时间扩展程序，有很多有用的方法，是 PHP Carbon 库的接口durafmt - 持续时间格式化feiertage - 一组计算德国公共假期的函数，比如复活节、感恩节等Go-persian-calendar - 太阳历Goweek - 处理星期的库now - Now 是一个 Go 语言的时间工具集NullTime -时间可以是 NULL 的库timeutil - 为 Go 语言时间包扩展了有用的功能，例如时间间隔和格式化 数据库迁移darwin - 数据库模式进化库Go-fixtures - 类似 DjanGo fixtures，用于 Golang 的內建数据库/sql 库Goose - 数据库迁移工具。你可以通过编写增量 SQL 或 Go 语言脚本来管理你的数据库Gormigrate - 数据库模式迁移帮助工具，用于 Gorm ORM.migrate - 数据库迁移。命令行及 Go 语言库pravasan - 简单的迁移，目前支持 MySQL 但是近期打算支持 Postgres, SQLite, MonGoDB 等等soda - 数据库迁移、创建、 ORM等等，用于 MySQL, PostgreSQL, 以及 SQLite.sql-migrate - 数据库迁移工具，允许利用 Go-bindata 将数据库迁移嵌入应用程序 Go 语言实现的数据库BigCache - 为 gigabytes 量级数据设计的高效键/值缓存bolt - 底层键值数据库buntdb - 快速，可嵌入的，内存键值数据库，可定义索引及 spatialcache2Go - 基于内存存储的键值缓存，支持自动基于超时的自动失效cockroach - 可扩展的、一致的事务型数据库couchcache - RESTful 缓存微服务，基于Couchbasedgraph - 可扩展的、分布式的、低延时、高吞吐的图数据库diskv - 具有 disk-backed 功能的持久化键值存储eliasdb - 无依赖、事物型图数据库，支持 REST API、短语搜索以及类 SQL 的查询语言forestdb - ForestDB 的 Go 语言借口GCache - 支持缓存过期、 LFU、 LRU 和 ARC 的缓存库geocache - 基于内存存储的缓存，适用于分布式部署的应用Go-cache - 内存键值存储/缓存库，适用于单机程序Goleveldb - 使用 Go 语言实现的 LevelDBgroupcache - Groupcache 是一个缓存及缓存填充库，在很多情况下用于替代 memcached.influxdb - 用于计量、事件及实时分析的、可扩展的数据库ledisdb - Ledisdb 是一个高性能 NoSQL 数据库，类似 RedileviGo - LeviGo 是 LevelDB的 Go 语言封装moss - Moss 是一个简单的 LSM 键值存储引擎，100% Go 语言实现piladb - 轻量级 RESTful 数据库引擎，基于堆栈结构prometheus - 监控系统及时间序列数据库rqlite - 基于 SQLite 的轻量级的、分布式的关系型数据库Scribble - 小巧的 JSON 文件存储tempdb - 临时数据的键值对存储tidb - TiDB 是一个分布式的 SQL 数据库。受到了 Google F1的启发tiedot - 基于 Go 语言的 NoSQL 数据库Tile38 - 地理位置数据库及实时地理围栏 golang通用数据结构及算法binpacker - 二进制数据封包拆包工具，帮你构建自定义的二进制数据流bit - Go 语言集合数据结构。提供了额外的位操作功能bitset - 实现了 bitset 的 Go 语言包.bloom - Go 语言实现的布隆过滤器（bloom filter）bloom - Go 语言实现的布隆过滤器boomfilters - 概率统计数据结构，用于处理大量连续的数据。count-min-log - Go 语言实现的 Count-Min-Log sketch 算法(类似 Count-Min sketch 算法，但是使用的内存更少).cuckoofilter - Cuckoo 过滤器：一个用go语言实现的计数布隆过滤器的替代品encoding - 整型压缩库Go-adaptive-radix-tree - Go 语言实现的自适应基数树Go-datastructures - 一组有用的、高性能的、线程安全的数据结构Go-geoindex - 基于内存存储的地理索引Go-rquad - 区域四叉树，支持有效点位置和领域发现Gods - Go 语言数据结构、容器、集合、列表、栈、键值对、 BidiMaps、树、HashSet 等Golang-set - 线程安全和非线程安全的高性能集合Goskiplist - Go 语言实现的跳跃表Gota - 为go语言实现了数据帧，序列以及数据噪音的方法hilbert - 用于映射空间填充曲线（例如希尔伯特曲线和皮亚诺曲线）和数值的库。hyperloglog - HyperLogLog implementation with Sparse, LogLog-Beta bias correction and TailCut space reduction.levenshtein - 编辑距离（levenshtein distance）和相似性度量， 可以自定义编辑代价和and Winkler-like bonus for common prefix.levenshtein - Go 语言实现计算编辑距离mafsa - Go 语言实现的 MA-FSA ，包含最小完美哈希merkletree - 实现了梅克尔树，提供了一种高效、安全的数据结构内容验证方法roaring - 实现了压缩 bitsets 的Go语言库skiplist - Go语言实现的跳跃表trie - Go语言实现的Trie树ttlcache - In-memory LRU string-interface{} map with expiration for Golangwillf/bloom - 实现了布隆过滤器的库 golang用于进行配置解析的库config - JSON 或 YAML 配置的封装，支持环境变量和标记解析configure - 可以通过多种途径进行配置，包括 JSON, 标记位以及环境变量env - 解析环境变量为 Go 语言结构体envcfg - 解析环境变量为 Go 语言结构体envconf - 通过环境变量来配置envconfig - 通过环境变量读取配置gcfg - 读取类 INI 类型的配置文件为 Go 语言结构体，支持自定义变量和节GoConfig - 通过命令行的输入、环境变量、配置文件来初始化一个结构体兵将一个结构体解析为输入Godotenv - Ruby 库 dotenv 的 Go 语言接口 (通过 .env 来获取环境变量)Gofigure - 让 Go 语言应用程序配置变得简单Gone/jconf - 模块化 JSON 配置工具。允许你将配置参数结构体和使用它的代码放在一起，而不需要让主配置文件了解所有子模块的细节来进行序列化hjson - 人性化的 JSON，一个便于程序员使用和阅读的配置文件格式。更加轻松的语法，更少的错误和更多的注释inGo - 将配置标记持久化到一个类似 ini 的文件中ini - 用于读写INI 文件的库joshbetz/config - 消息配置库，可以解析环境变量、JSON 文件并根据SIGHUP自动重新载入mini -用于解析类 ini 文件的库store - 轻量级配置管理viper - 这个库名叫毒蛇 ,Go 语言配置工具xdg -遵守 XDG 标准 的配置工具 golang认证和授权库authboss - 用于 web 开发的组件化认证授权系统。它尝试尽可能的移除模板代码以及硬编码，这使你每次新建 web 项目的时候，可以做到即插即用、配置并开始开发你的 web 英语，而不必每次都重新创建一个认证授权系统。casbin - 一个支持接入控制模型（例如:ACL,RBAC,ABAC）的授权库Go-AWS-Auth - AWS 请求签名库Go-jose - Fairly complete implementation of the JOSE working group’s JSON Web Token, JSON Web 签名以及JSON Web 加密 specs.Go-oauth2-server - 使用 Go 语言编写的独立、符合标准的 OAuth2 服务器Go.auth - 为 Go 语言 web 应用提供的授权 API.Gologin - 可以串连使用OAuth1 和 OAuth2 认证服务Gorbac - 一个用 Go 语言实现的轻量级RBACGoth - 提供了一种简洁的、惯用的方式来使用OAuth 和 OAuth2.httpauth - HTTP 认证中间件jwt - 简单易用的一个JSON Web Tokens (JWT)的实现jwt-auth - JWT 为 Go 语言 HTTP 服务器编写的 jwt 中间件，有多种配置选项jwt-Go - Go 语言实现的JSON Web Tokens (JWT).loginsrv - JWT 登录微服务，可以继承OAuth2 (Github), htpasswd, osiam等后端。oauth2 - Goauth2的继承者。 通用 OAuth 2.0 库，集成了对JWT, Google APIs, Compute Engine 和 App Engine的支持.osin - Go 语言 OAuth2 服务器库permissions2 - 用于追踪用户，登录状态和许可的库。使用安全 cookies 和 bcrypt.session - Go 语言会话管理(支持 Google App Engine - GAE)sessions - 为 Go 语言 HTTP 服务器开发的非常简单的、高性能的、高可定制的会话服务traefik - 反向代理和负载均衡库，支持多种后端yubiGo - Yubikey 客户端，提供了用于在 Go 语言应用中集成Yubico Yubikey 的 API golang用于操作音频的库flac - 原生 Go FLAC 解码器flac - 原生 Go FLAC 解码器gaad - 原生 Go AAC 比特流解析器Go-sox - libsox 的 Go 语言接口Go_mediainfo - libmediainfo 的 Go 语言接口Gosamplerate - libsamplerate 的 Go 语言接口id3v2 - 快速且稳定的 ID3 解析及写入库mix - 基于序列的 Go 语言混音器，可用于音乐 app。mp3 - 原生 Go MP3 解码器music-theory - Go 语言编写的音乐理论模型PortAudio - 音频 I/O 库的 Go 语言接口portmidi - PortMidi 的 Go 语言接口taglib - taglib 的 Go 语言接口vorbis - “原生” Go Vorbis 解码器 (使用 CGo, 但是没有其他依赖).waveform - 一个可以通过音频流生成波形图像的包 golang代码中嵌入其他语言的包aGora - 一种动态类型的可以嵌入 Go 中的编程语言anko - Go 语言编写的解释器binder - Lua 接口, 基于 Gopher-luagisp - Simple LISPGo-duktape - Duktape JavaScript 引擎的 Go 语言接口Go-lua - Lua 5.2 虚拟机的纯 Go 语言接口Go-php - PHP 的 Go 语言接口Go-python - CPython C-API 的 Go 语言接口Golua - Lua C API。的 Go 语言接口Gopher-lua - Go 语言编写的 Lua 5.1 虚拟机和编译器ngaro - 可嵌入的 Ngaro 虚拟机实现，支持在 Retro 中使用脚步otto - Go 编写的 Javascrip 解释器purl - 嵌入 Go 语言的 Perl 5.18.2 go日志库glg - glg 是一个简单、快速、分级的日志库glog - 分级记录日志的库Go-cronowriter 对日志文件进行自动循环写入的库基于当前日期和时间，类似 cronolog.Go-log - 支持多处理器及日志分级的库Go-log - Go 语言实现的 Log4jGo-logger - 支持日志分级的简单的日志工具Gologger - 简单易用的日志库，可以在彩色控制台、简易控制的、文件或 Elasticsearch 中记录Gomol - 支持多种输出，结构化的日志模块，可以扩展它的输出Gone/log - 快速、可扩展、全功能、兼容标准库的日志库log - 结构化日志库log - 简单、可配置、可扩展的结构化日志库log-voyage - 全功能日志saas 使用 Go 语言编写log15 - 简单强大的日志库logdump - 支持分级的日志库logex - Go 语言日志库，支持追踪和分级，基于标准库进行了封装logger - 一个极简的日志库logrus - 支持结构化的日志工具.logrusly - logrus 的插件，用于将错误发送到 Loggly.logutils - 对 Go 语言标准日志工具进行了扩展，使其更好用logxi - 十二要素 app 日志工具，非常快速，令你开心lumberjack - 简单的循环日志工具，实现了 io.WriteCloser.mlog - 一个简单的日志模块，可以分5级并有一个可选的循环日志文件记录功能，支持 stdout/stderr 输出.ozzo-log - 高性能日志库，支持日志严重级别、分类及过滤。可以将过滤后的信息发送到不同的目的地(例如： 控制台、网络、邮箱).seelog - 一个灵活的、解耦的、格式化的日志库slf - 简单日志门面（The Structured Logging Facade (SLF) ） (类似 SLF4J，但是它是结构化的，并且专为 Go 语言设计)slog - 为 Go 语言实现的结构化日志门面（Structured Logging Facade (SLF) ）spew - 为 Go 语言的数据结构实现了一个整洁的打印功能，有助于调试stdlog - Stdlog 是一个面向对象的库，提供了分级日志功能，对于定时任务很有用.tail - 这个 Go 语言软件包力争模拟 BSD tail 的功能xlog - 插件架构以及灵活的日志系统，具有日志等级控制，多日志目标以及自定义日志格式功能xlog - 结构化日志 for net/context aware HTTP handlers ，可以灵活的分发zap - 快速的、结构化的、分级的日志库zerolog - 零分配 JSON 日志. golang操作表单的库bind - 将表单数据绑定到任意的 Go 变量上binding - 将来自 net/HTTP 请求的表单、JSON 数据绑定到结构体conform - 检查用户输入并基于结构标签来清理数据form - 解码 url 中的数据到 Go 语言变量中以及将 Go 语言变量编码进 url 支持Dual Array 及 Full mapformam - 将表单数据解码到结构体forms - 框架无关的表单/JSON数据解析验证库，支持多部分表单及文件Gorilla/csrf - 为 Go 语言 web 应用提供 CSRF 防御nosurf - CSRF 防御中间件 Go实现消息系统的库CentrifuGo - 实时消息服务器dbus - D-Bus的 Go 语言接口drone-line - 通过软件包，docker 或是 Drone CI来发送 Line 通知emitter - 通过Go语言的方式发送事件消息，可以使用通配符，断言，取消发送等优秀特性EventBus - 轻量级事件库，支持异步gaurun-client - Go 语言编写的 Gaurun 客户端Glue - 健壮的 Go 和 Javascript Socket 库 (可以用来替代 Socket.io).Go-longpoll - 支持长轮询的发布与订阅Go-notify - 原生实现的桌面通知规范Go-nsq - NSQ 官方 Go 语言库Go-socket.io - Go 语言的 socket.io库 ,一个实时应用框架.Go-vitotrol - Viessmann Vitotrol 服务的 Go 语言客户端Gollum - 一个 n:m 的多路复用器，从不同的源汇聚消息并向目标进行广播Golongpoll - HTTP 长轮询服务器库，让 web 发布与订阅变的更简单.Goose - Go 语言实现的服务器端事件发送Gopush-cluster - Gopush-cluster 是一个 Go 语言实现的支持集群的comet服务（支持 websocket，和tcp协议）Gorush - 通知推送服务器，使用 APNs2 和 Google GCM.guble - 一个使用通知推送(Google Firebase Cloud Messaging, Apple Push Notification services, SMS)、websockets 、REST API 的消息服务器。提供了分布式操作和消息持久化特性machinery - 异步任务队列，基于分布式消息处理manGos - 纯 Go 语言实现的 Nanomsg (“Scalable Protocols”)melody - 用于处理 websocket 会话的一个极简框架，包括广播和自动 ping/pong 处理NATS Go Client - 轻量级高性能发布订阅(publish-subscribe) 以及分布式消息队列系统，这个一个Go语言库.nsq-event-bus - 针对 NSQ 的主题和频道进行了简单的封装oplog - 原生的 oplog/replication 系统，用于 REST APIspubsub - 一个简单的 pubsub 软件包RapidMQ - RapidMQ 是一个轻量级，可靠的本地消息队列管理库sarama - 用于 Apache Kafka 的库Uniqush-Push - 基于 Redis 的统一推服务，用于服务器端向移动客户端推送消息zmq4 - ZeroMQ version 4的 GO 语言接口。也有适用于version 3 及 version 2的 最后还有github上的类库大全：https://github.com/avelino/awesome-go","tags":[]},{"title":"golang之json操作库","date":"2020-05-13T14:24:00.000Z","path":"post/3838666233.html","text":"总结有三个非常好用的json操作库1、gjson （读取json）2、sjson （增删改json）3、gojsonq （高级查询统计json数据） 123$ go get github.com/tidwall/gjson$ go get github.com/tidwall/sjson$ go get github.com/thedevsaddam/gojsonq 具体详情文章：gjson ：https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439052&amp;idx=4&amp;sn=4b668ec590db68ac5850e4c9eff6bfd1&amp;chksm=80bb613eb7cce828155ccfa92821b3da15f2551b8f6335bf6b8189aa9747a20c0ce1855de4f5&amp;scene=21#wechat_redirectsjson ：https://mp.weixin.qq.com/s/ucfJxIw_NLb6TGrhQa3UcQgojsonq ：https://mp.weixin.qq.com/s/ZfaH6ROWiVX9IsoxJ04oXw","tags":[]},{"title":"go依赖管理--Go modules","date":"2020-05-12T16:01:00.000Z","path":"post/2526408434.html","text":"一、什么是Go Modules?Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。 Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题： Go 语言长久以来的依赖管理问题。 “淘汰”现有的 GOPATH 的使用模式。 统一社区中的其它的依赖管理工具（提供迁移功能）。 二、GOPATH的工作模式Go Modoules的目的之一就是淘汰GOPATH, 那么GOPATH是个什么? 为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？ (1) Wait is GOPATH?1234$ go envGOPATH=\"/home/itheima/go\"... 我们输入go env命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下： 123456789go├── bin├── pkg└── src ├── github.com ├── golang.org ├── google.golang.org ├── gopkg.in .... GOPATH目录下一共包含了三个子目录，分别是： bin：存储所编译生成的二进制文件。 pkg：存储预编译的目标文件，以加快程序的后续编译速度。 src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放。 因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。 (2) GOPATH模式的弊端在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端. A. 无版本控制概念. 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。B.无法同步一致第三方版本号. 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。C.无法指定当前项目引用的第三方版本号. 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。 三、Go Modules模式我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在GOPATH/src下. (1) go mod命令12345678go mod init：生成 go.mod 文件go mod download : 下载 go.mod 文件中指明的所有依赖go mod tidy: 整理现有的依赖go mod graph: 查看现有的依赖结构go mod edit : 编辑 go.mod 文件go mod vendor : 导出项目所有的依赖到vendor目录go mod verify: 校验一个模块是否被篡改过go mod why: 查看为什么需要依赖某模块 (2) go mod环境变量可以通过 go env 命令来进行查看 12345678$ go envGO111MODULE=\"auto\"GOPROXY=\"https://proxy.golang.org,direct\"GONOPROXY=\"\"GOSUMDB=\"sum.golang.org\"GONOSUMDB=\"\"GOPRIVATE=\"\"... GO111MODULEGo语言提供了 GO111MODULE这个环境变量来作为 Go modules 的开关，其允许设置以下参数： auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。on：启用 Go modules，推荐设置，将会是未来版本中的默认值。off：禁用 Go modules，不推荐设置。可以通过来设置 1$ go env -w GO111MODULE=on GOPROXY这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。 GOPROXY 的默认值是：https://proxy.golang.org,direct proxy.golang.org国内访问不了,需要设置国内的代理. 12345阿里云https://mirrors.aliyun.com/goproxy/七牛云https://goproxy.cn,direct 如: 1bash $ go env -w GOPROXY=https://goproxy.cn,direct GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。 如: 12$ go env -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy/,directdirect 而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？ 实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。 GOSUMDB它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。 GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。 因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。 另外若对 GOSUMDB 的值有自定义需求，其支持如下格式： 格式 1：+。格式 2：+ 。也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。 GONOPROXY/GONOSUMDB/GOPRIVATE这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。 更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。 而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。 并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如： 1$ go env -w GOPRIVATE=\"git.example.com,github.com/eddycjy/mquote\" 设置后，前缀为 http://git.xxx.com 和 http://github.com/eddycjy/mquote 的模块都会被认为是私有模块。 如果不想每次都重新设置，我们也可以利用通配符，例如： 1$ go env -w GOPRIVATE=\"*.example.com\" 这样子设置的话，所有模块路径为 http://example.com 的子域名（例如：http://git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 http://example.com 本身。 四、使用Go Modules初始化项目(1) 开启Go Modules1$ go env -w GO111MODULE=on 又或是可以通过直接设置系统环境变量（写入对应的~/.bash_profile 文件亦可）来实现这个目的： 1$ export GO111MODULE=on (2) 初始化项目创建项目目录 12$ mkdir -p $HOME/aceld/modules_test$ cd $HOME/aceld/modules_test 执行Go modules 初始化 12$ go mod init github.com/aceld/modules_testgo: creating new go.mod: module github.com/aceld/modules_test ​ 在执行 go mod init 命令时，我们指定了模块导入路径为 github.com/aceld/modules_test。接下来我们在该项目根目录下创建 main.go 文件，如下： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\" \"github.com/aceld/zinx/znet\" \"github.com/aceld/zinx/ziface\")//ping test 自定义路由type PingRouter struct &#123; znet.BaseRouter&#125;//Ping Handlefunc (this *PingRouter) Handle(request ziface.IRequest) &#123; //先读取客户端的数据 fmt.Println(\"recv from client : msgId=\", request.GetMsgID(), \", data=\", string(request.GetData())) //再回写ping...ping...ping err := request.GetConnection().SendBuffMsg(0, []byte(\"ping...ping...ping\")) if err != nil &#123; fmt.Println(err) &#125;&#125;func main() &#123; //1 创建一个server句柄 s := znet.NewServer() //2 配置路由 s.AddRouter(0, &amp;PingRouter&#123;&#125;) //3 开启服务 s.Serve()&#125; OK, 我们先不要关注代码本身,我们看当前的main.go也就是我们的aceld/modules_test项目,是依赖一个叫github.com/aceld/zinx库的. znet和ziface只是zinx的两个模块. 接下来我们在$HOME/aceld/modules_test,本项目的根目录执行 1234$ go get github.com/aceld/zinx/znetgo: downloading github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100go: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100 我们会看到 我们的go.mod被修改,同时多了一个go.sum文件. (3) 查看go.mod文件aceld/modules_test/go.mod 12345module github.com/aceld/modules_testgo 1.14require github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100 // indirect 我们来简单看一下这里面的关键字 module: 用于定义当前项目的模块路径 go:标识当前Go版本.即初始化版本 require: 当前项目依赖的一个特定的必须版本 // indirect: 示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的.我们的代码很明显是依赖的”github.com/aceld/zinx/znet”和”github.com/aceld/zinx/ziface”,所以就间接的依赖了github.com/aceld/zinx (4) 查看go.sum文件在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。 123github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54=github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100/go.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw= 我们可以看到一个模块路径可能有如下两种： h1:hash情况 1github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54= go.mod hash情况 12github.com/aceld/zinx v0.0.0-20200221135252-8a8954e75100/go.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw= h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。 而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。 五、修改模块的版本依赖关系​ 为了作尝试,假定我们现在都zinx版本作了升级, 由zinx v0.0.0-20200221135252-8a8954e75100 升级到 zinx v0.0.0-20200306023939-bc416543ae24 (注意zinx是一个没有打版本tag打第三方库,如果有的版本号是有tag的,那么可以直接对应v后面的版本号即可) ​ 那么,我们是怎么知道zinx做了升级呢, 我们又是如何知道的最新的zinx版本号是多少呢? ​ 先回到$HOME/aceld/modules_test,本项目的根目录执行 1234$ go get github.com/aceld/zinx/znetgo: downloading github.com/aceld/zinx v0.0.0-20200306023939-bc416543ae24go: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0.0.0-20200306023939-bc416543ae24go: github.com/aceld/zinx upgrade =&gt; v0.0.0-20200306023939-bc416543ae24 这样我们,下载了最新的zinx, 版本是v0.0.0-20200306023939-bc416543ae24 ​ 然后,我么看一下go.mod 12345module github.com/aceld/modules_testgo 1.14require github.com/aceld/zinx v0.0.0-20200306023939-bc416543ae24 // indirect 我们会看到,当我们执行go get 的时候, 会自动的将本地将当前项目的require更新了.变成了最新的依赖. 好了, 现在我们就要做另外一件事,就是,我们想用一个旧版本的zinx. 来修改当前zinx模块的依赖版本号. 目前我们在$GOPATH/pkg/mod/github.com/aceld下,已经有了两个版本的zinx库 123/go/pkg/mod/github.com/aceld$ lszinx@v0.0.0-20200221135252-8a8954e75100zinx@v0.0.0-20200306023939-bc416543ae24 ​ 目前,我们/aceld/modules_test依赖的是zinx@v0.0.0-20200306023939-bc416543ae24 这个是最新版, 我们要改成之前的版本zinx@v0.0.0-20200306023939-bc416543ae24. ​ 回到/aceld/modules_test项目目录下,执行 1$ go mod edit -replace=zinx@v0.0.0-20200306023939-bc416543ae24=zinx@v0.0.0-20200221135252-8a8954e75100 ​ 然后我们打开go.mod查看一下 1234567module github.com/aceld/modules_testgo 1.14require github.com/aceld/zinx v0.0.0-20200306023939-bc416543ae24 // indirectreplace zinx v0.0.0-20200306023939-bc416543ae24 =&gt; zinx v0.0.0-20200221135252-8a8954e75100 ​ 这里出现了replace关键字.用于将一个模块版本替换为另外一个模块版本。 文章参考：https://zhuanlan.zhihu.com/p/113506780","tags":[]},{"title":"MongoDB中各种类型的索引","date":"2020-05-03T15:57:00.000Z","path":"post/579789855.html","text":"MongoDB 中索引的类型大致包含单键索引、复合索引、多键值索引、地理索引、全文索引、 散列索引等，下面简单介绍各类索引的用法。 1、单字段索引这个是最简单最常用的索引类型，比如我们上边的例子，为id建立一个单独的索引就是此种类型。 12 # 为id field建立索引，1表示升序，-1表示降序，没有差别db.employee.createIndex(&#123;'id': 1&#125;) 需要注意的是通常MongoDB会自动为我们的文档插入’_id’ field，且已经按照升序进行索引，如果我们插入的文档中包含有’_id’ field，则MongoDB就不会自动创建’_id’ field，但是需要我们自己来保证唯一性从而唯一标识一个文档 2、复合索引上图查询索引的时候会先查询userid，再查询score，然后就可以找到对应的文档。对于复合索引需要注意以下几点： 索引field的先后顺序很关键，影响有两方面：1、MongoDB在复合索引中是根据prefix排序查询，就是说排在前面的可以单独使用。我们创建一个如下的索引 1db.collection.createIndex(&#123;'id': 1, 'city': 1, 'score': 1&#125;) 我们如下的查询可以利用索引 123db.collection.find(&#123;'id': xxx&#125;)db.collection.find(&#123;'id': xxx, 'city': xxx&#125;)db.collection.find(&#123;'id': xxx, 'city':xxx, 'score': xxxx&#125;) 但是如下的查询无法利用该索引 12db.collection.find(&#123;'city': xxx&#125;)db.collection.find(&#123;'city':xxx, 'score': xxxx&#125;) 还有一种特殊的情况，就是如下查询： 1db.collection.find(&#123;'id': xxx, 'score': xxxx&#125;) 这个查询也可以利用索引的前缀’id’来查询，但是却不能针对score进行查询，你可以说是部分利用了索引，因此其效率可能不如如下索引： 1db.collection.createIndex(&#123;'id': 1, 'score': 1&#125;) 2.过滤出的document越少的field越应该放在前面，比如此例中id如果是唯一的，那么就应该放在最前面，因为这样通过id就可以锁定唯一一个文档。而如果通过city或者score过滤完成后还是会有大量文档，这就会影响最终的性能。 索引的排序顺序不同复合索引最末尾的field，其排序顺序不同对于MongoDB的查询排序操作是有影响的。比如： 1db.events.createIndex( &#123; username: 1, date: -1 &#125; ) 这种情况下， 如下的query可以利用索引： 1db.events.find().sort( &#123; username: 1, date: -1 &#125; ) 但是如下query则无法利用index进行排序 1db.events.find().sort( &#123; username: 1, date: 1 &#125; ) 3、多键值索引这个主要是针对数据类型为数组的类型，如下示例： 123&#123;\"name\" : \"jack\", \"age\" : 19, habbit: [\"football, runnning\"]&#125;db.person.createIndex( &#123;habbit: 1&#125; ) // 自动创建多key索引db.person.find( &#123;habbit: \"football\"&#125; ) 4、散列索引散列（Hashed）索引是指按照某个字段的散列值来建立索引，目前主要用于 MongoDB Sharded Cluster 的散列分片，散列索引只能用于字段完全匹配的查询，不能用于范围查询等。散列其语法如下： 1db.collection.createlndex( &#123; _id : \"hashed\" &#125;) MongoDB 支持散列任何单个字段的索引，但是不支持多键（即数组）索引。 需要说明的是，MongoDB 在进行散列索引之前，需要将浮点数截断为 64 位整数。例如，散列将对 2.3、2.2 和 2.9 这些值产生同样的返回值。 5、过期索引顾名思义，过期索引就是一种会过期的索引，在索引过期之后，索引对应的数据会被删除，创建方式如下： 1db.sang_collect.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:30&#125;) expireAfterSeconds表示索引的过期时间，单位为秒。time表示索引的字段，time的数据类型必须是ISODate或者ISODate数组，否则的话，当索引过期之后，time的数据就不会被删除。 6、全文索引全文索引虽然好用，可惜不支持中文，我们这里就先做一个简单的了解。 比如，我的数据集如下： 1234567891011121314151617181920&#123; \"_id\" : ObjectId(\"59f5a3da1f9e8e181ffc3189\"), \"x\" : \"Java C# Python PHP\"&#125;&#123; \"_id\" : ObjectId(\"59f5a3da1f9e8e181ffc318a\"), \"x\" : \"Java C#\"&#125;&#123; \"_id\" : ObjectId(\"59f5a3da1f9e8e181ffc318b\"), \"x\" : \"Java Python\"&#125;&#123; \"_id\" : ObjectId(\"59f5a3da1f9e8e181ffc318c\"), \"x\" : \"PHP Python\"&#125;&#123; \"_id\" : ObjectId(\"59f5a4541f9e8e181ffc318d\"), \"x\" : \"C C++\"&#125; 我们可以给x字段建立一个全文索引，创建方式如下： 1db.sang_collect.ensureIndex(&#123;x:\"text\"&#125;) MongoDB会自动对x字段的数据进行分词，然后我们就可以通过如下语句进行查询： 1db.sang_collect.find(&#123;$text:&#123;$search:\"Java\"&#125;&#125;) 此时x中包含Java的文档都会被查询出来。如果想查询既包含Java又包含C#的文档，操作如下： 1db.sang_collect.find(&#123;$text:&#123;$search:\"\\\"Java C#\\\"\"&#125;&#125;) 用一对双引号将查询条件括起来，如果想查询包含PHP或者Python的文档，操作如下： 1db.sang_collect.find(&#123;$text:&#123;$search:\"PHP Python\"&#125;&#125;) 如果想查询既有PHP，又有Python，但是又不包括Java的文档，如下： 1db.sang_collect.find(&#123;$text:&#123;$search:\"PHP Python -Java\"&#125;&#125;) 建立了全文索引之后，我们也可以查看查询结果的相似度，使用$meta，如下： 1db.sang_collect.find(&#123;$text:&#123;$search:\"PHP Python\"&#125;&#125;,&#123;score:&#123;$meta:\"textScore\"&#125;&#125;) 此时查询结果中会多出一个score字段，该字段的值越大，表示相似度越高，我们可以根据score利用sort来对其进行排序，如下： 1db.sang_collect.find(&#123;$text:&#123;$search:\"PHP Python\"&#125;&#125;,&#123;score:&#123;$meta:\"textScore\"&#125;&#125;).sort(&#123;score:&#123;$meta:\"textScore\"&#125;&#125;) 全文索引目前看起来功能还是很强大，可惜暂时不支持中文，不过网上对此也有很多解决方案，小伙伴们可以自行搜索查看。 7、地理空间索引地理空间索引类型地理空间索引可以分为两类： 1.2d索引，可以用来存储和查找平面上的点。2.2d sphere索引，可以用来存储和查找球面上的点。 2d索引2d索引一般我们可以用在游戏地图中。向集合中插入一条记录点的数据： 1db.sang_collect.insert(&#123;x:[90,0]&#125;) 插入数据的格式为[经度,纬度]，取值范围，经度[-180,180]，纬度[-90,90]。数据插入成功之后，我们先通过如下命令创建索引： 1db.sang_collect.ensureIndex(&#123;x:\"2d\"&#125;) 然后通过$near我们可以查询某一个点附近的点，如下: 1db.sang_collect.find(&#123;x:&#123;$near:[90,0]&#125;&#125;) 默认情况下返回该点附近100个点，我们可以通过$maxDistance来设置返回的最远距离： 1db.sang_collect.find(&#123;x:&#123;$near:[90,0],$maxDistance:99&#125;&#125;) 我们也可以通过$geoWithin查询某个形状内的点，比如查询矩形中的点： 1db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$box:[[0,0],[91,1]]&#125;&#125;&#125;) 两个坐标点用来确定矩形的位置。 查询圆中的点： 1db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$center:[[0,0],90]&#125;&#125;&#125;) 参数分别表示圆的圆心和半径。 查询多边形中的点： 1db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$polygon:[[0,0],[100,0],[100,1],[0,1]]&#125;&#125;&#125;) 这里可以填入任意多个点，表示多边形中的各个点。 2d sphere索引2dsphere适用于球面类型的地图，它的数据类型是GeoJSON格式的，我们可以在http://geojson.org/地址上查看GeoJSON格式的样式，比如我们描述一个点，GeoJSON如下： 1234567891011&#123; \"_id\" : ObjectId(\"59f5e0571f9e8e181ffc3196\"), \"name\" : \"shenzhen\", \"location\" : &#123; \"type\" : \"Point\", \"coordinates\" : [ 90.0, 0.0 ] &#125;&#125; 描述线，GeoJSON格式如下： 123456789101112131415161718192021&#123; \"_id\" : ObjectId(\"59f5e0d01f9e8e181ffc3199\"), \"name\" : \"shenzhen\", \"location\" : &#123; \"type\" : \"LineString\", \"coordinates\" : [ [ 90.0, 0.0 ], [ 90.0, 1.0 ], [ 90.0, 2.0 ] ] &#125;&#125; 描述多边形，GeoJSON格式如下： 123456789101112131415161718192021222324252627&#123; \"_id\" : ObjectId(\"59f5e3f91f9e8e181ffc31d0\"), \"name\" : \"beijing\", \"location\" : &#123; \"type\" : \"Polygon\", \"coordinates\" : [ [ [ 0.0, 1.0 ], [ 0.0, 2.0 ], [ 1.0, 2.0 ], [ 0.0, 1.0 ] ] ] &#125;&#125; 还有其他的类型，具体小伙伴们可以参考http://geojson.org/。有了数据之后，我们可以通过如下操作来创建地理空间索引了： 1db.sang_collect.ensureIndex(&#123;location:\"2dsphere\"&#125;) 比如我想查询和深圳这个区域有交集的文档，如下： 12var shenzhen = db.sang_collect.findOne(&#123;name:\"shenzhen\"&#125;)db.sang_collect.find(&#123;location:&#123;$geoIntersects:&#123;$geometry:shenzhen.location&#125;&#125;&#125;) 这里的查询结果是和深圳这个区域有交集的都会查到(比如经过深圳的高速公路、铁路等)，我们也可以只查询深圳市内的区域(比如深圳市内所有的学校)，如下： 12var shenzhen = db.sang_collect.findOne(&#123;name:\"shenzhen\"&#125;)db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;&#125;) 也可以查询腾讯附近的其他位置，如下： 12var QQ = db.sang_collect.findOne(&#123;name:\"QQ\"&#125;)db.sang_collect.find(&#123;location:&#123;$near:&#123;$geometry:QQ.location&#125;&#125;&#125;) 复合地理空间索引位置往往只是我们查询的一个条件，比如我要查询深圳市内所有的学校，那我得再增加一个查询条件，如下： 12var shenzhen = db.sang_collect.findOne(&#123;name:\"shenzhen\"&#125;)db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;,name:\"QQ\"&#125;) 其他的查询条件跟在后面就行了。 参考文章：https://blog.csdn.net/u012702547/article/details/81027421https://www.jianshu.com/p/2b09821a365dhttp://c.biancheng.net/view/6558.html","tags":[]},{"title":"MongoDB-分片片键","date":"2020-05-03T14:44:00.000Z","path":"post/1182994018.html","text":"1．分片 分片是什么？分片就是将数据存储在多个机器上。当数据集超过单台服务器的容量，服务器的内存，磁盘IO都会有问题，即超过单台服务器的性能瓶颈。此时有两种解决方案，垂直扩展和水平扩展（分片）。 垂直扩展就是增加CPU，增加容量，但高性能系统的CPU和容量不成比例，这样扩展成本大，并且有上限。 水平扩展分片，将数据分发到多个服务器，每个服务器是一个单独的数据库，各个服务器加起来组成一个逻辑数据库，把写压力和操作分流到不同服务器，提高容量和吞吐量。 MongoDB的文档是无模式的，不固定结构，因此只能进行水平分片。当块超过指定大小或者文档数超过最大文档数，MongoDB尝试分割这个块，若分割成功，把它标记为一个大块避免重复分割。拆分块的关键就是片键，下面介绍常见片键的种类。 2．片键种类 片键是文档的一个属性字段或者一个复合索引字段，一旦建立不能改变。片键是分片拆分数据的关键，片键的选择直接影响集群的性能。 MongoDB首先根据片键划分块chunks当块超过指定大小（默认64M），然后把块分到其他的分片上，片键类型主要有以下几种： 注意：片键也是查询时常用的一个索引。 （1） 递增片键 这类片键比较常见，比如使用时间戳，日期，自增的主键，ObjectId，_id等，此类片键的写入操作集中在一个分片服务器上，写入不具有分散性，这会导致单台服务器压力较大，但分割比较容易，这台服务器可能会成为性能瓶颈。 递增片键的创建，对foo数据库的bar集合使用timestamp时间戳分片 123456mongos&gt; use foomongos&gt; db.bar.ensureIndex(&#123;\"timestamp\":1&#125;)mongos&gt; sh.enableSharding(\"foo\")&#123; \"ok\" : 1 &#125;mongos&gt; sh.shardCollection(\"foo.bar\",&#123;\"timestamp\":1&#125;)&#123; \"collectionsharded\" : \"foo.bar\", \"ok\" : 1 &#125; （2） 哈希片键 使用一个哈希索引字段作为片键，优点是使数据在各节点分布比较均匀，数据写入可随机分发到每个分片服务器上，把写入的压力分散到了各个服务器上。但是读也是随机的，可能会命中更多的分片，一般具有随机性的片键（如密码，哈希，MD5）查询隔离性能比较差。 哈希片键的创建，对GridFS的chunks集合使用files_id哈希分片 12345mongos&gt; db.bar.ensureIndex(&#123;\"files_id\":\"hashed\"&#125;)mongos&gt; sh.enableSharding(\"foo\")&#123; \"ok\" : 1 &#125;mongos&gt; sh.shardCollection(\"foo.fs.chunks\",&#123;\"files_id\":\"hashed\"&#125;)&#123; \"collectionsharded\" : \" foo.fs.chunks \", \"ok\" : 1 &#125; （3） 组合片键 数据库中没有比较合适的片键供选择，或者是打算使用的片键基数太小（即变化少如星期只有7天可变化），可以选另一个字段使用组合片键，甚至可以添加冗余字段来组合。一般是粗粒度+细粒度进行组合。 组合片键的创建，对GridFS的chunks集合使用files_id和n组合分片 1234mongos&gt; sh.enableSharding(\"foo\")&#123; \"ok\" : 1 &#125;mongos&gt; sh.shardCollection(\"foo.fs.chunks\",&#123;\"files_id\":1, \"n\":1&#125;)&#123; \"collectionsharded\" : \" foo.fs.chunks \", \"ok\" : 1 &#125; （4） 标签分片 数据存储在指定的分片服务器上，可以为分片添加tag标签，然后指定相应的tag，比如让10...(T)出现在shard0000上，11...(Q)出现在shard0001或shard0002上，就可以使用tag让均衡器指定分发。 标签分片的创建 12345mongos &gt; sh.addShardTag(\"shard0000\", \"T\")mongos &gt; sh.addShardTag(\"shard0001\", \"Q\")mongos &gt; sh.addShardTag(\"shard0002\", \"Q\")mongos&gt; sh.addTagRange(\"foo.ips\",&#123; \"ip\": \"010.000.000.000 \", … , \"ip\": \"011.000.000.000 \"&#125;&#125;, \"T\")mongos&gt; sh.addTagRange(\"foo.ips\",&#123; \"ip\": \"011.000.000.000 \", … , \"ip\": \"012.000.000.000 \"&#125;&#125;, \"Q\") 3．片键选择策略 大致了解了片键的种类，那么怎么选择片键呢？无非从两个方面考虑，数据的查询和写入，最好的效果就是数据查询时能命中更少的分片，数据写入时能够随机的写入每个分片，关键在于如何权衡性能和负载。 如何选择片键主要从下面几个问题考虑：（1）首先确定一个经常性查询的字段（2）找到影响这些操作性能的关键点（3）如果选的字段基数比较小，添加一个粒度细的字段 怎么选择，如何权衡，跟具体的业务以及数据类型都有关系，具体问题具体分析。","tags":[]},{"title":"MongoDB之分片集群与复制集","date":"2020-05-03T13:15:00.000Z","path":"post/3134727742.html","text":"分片集群1.1、概念分片集群是将数据存储在多台机器上的操作，主要由查询路由mongos、分片、配置服务器组成。●查询路由根据配置服务器上的元数据将请求分发到相应的分片上，本身不存储集群的元数据，只是缓存在内存中。●分片用来存储数据块。数据集根据分片键将集合分割为数据块，存储在不同的分片上。在生产环境下，通常一个分片由一个复制集组成。●配置服务器存储集群的元数据，包括数据与分片的映射关系，配置服务器一旦挂掉，集群将无法工作。注意：●当mongos重启时，会从配置服务器读取元数据更新自己缓存的元数据●当分割数据时或者在分片间移动数据时会写配置服务器。●在分片集群中，配置服务器可以采用复制集的架构，但复制集中不允许有仲裁节点和延时节点，且buildindexes必须设为true。●集合的数据分布在多个分片上，如果某个分片失效，查询会返回错误，可以通过为查询指定partial选项，允许接受不完整的数据作用单台机器无法满足存储需求，内存、磁盘空间不够，读写吞吐量不够。 1.2、如何维护数据均衡分布集群使用分割器和平衡器两个后台进程维护数据均匀分布。 分割器●分割器的作用是防止数据块变大，数据块大小默认是64MB，当超过64MB时，分割器会将其一分为二。●分割的对象不是实际的数据，而是元数据，只是在逻辑上进行逻辑块的划分，不会影响到实际数据的分布●数据块太小会产生大量块，容易使集群不平衡，导致数据块频繁移动，降低集群性能，元数据增加，降低查询效率●数据块太大，会减小移动频率，元数据少，有利于数据查询，但一旦移动，会花费很长时间●并不是所有的集合都会分片，没有被分片的集合都存储在同一个主分片上●只有对数据库和集合开启分片后，数据才会在不同分片上分布，否则只存储在主分片上●插入和更新操作都有可能引发分割 平衡器●平衡器的作用是管理数据块的移动。●当集群中数据块的分布达到移动阈值时，平衡器会移动数据块。●增加或减少分片或增删数据也会使平衡器移动数据块 1.3数据块如何存储在相应分片上每个需要被分片的集合都需要指定索引字段作为分片键，mongodb使用区间分区或哈希分区算法根据分片键将数据分割为数据块。 区间分区数据块覆盖一段子区间，任何分片键都会被某一段覆盖优缺点区间分区支持更好的range查询，通过分片键查询，查询路由可以很容易的判断出哪些数据块含有查询需要数据，并将请求分配到的分片上。区间分区使数据分布不均匀 哈希分区根据分片键的哈希值进行数据的分配。优缺点数据随机分配到不同的数据块在进行range查询时，由于相邻数据分布在不同分片上，导致访问很多分片注意●分片键不能是多键索引，即索引字段的值不能是数组●分片键一旦被指定，不能被修改为其他字段，同时分片键的字段值也不能被修改●如果集群的写操作比较多，可以使用哈希分区，将数据均匀分配到节点上，将写操作均匀应用与集群，如果集群读操作比较多，可以使用区间分区，将相邻数据分到同一节点上，便于查询●如果查询时没有指定索引字段，查询路由会将请求分发到所有节点上，等待返回结果，查询效率低如果查询时指定了索引字段，查询路由会将请求分发到少数节点上，查询效率高 1.4、数据迁移过程●平衡器向源节点发送movechunk指令●源节点移动指定数据块，在迁移期间，数据块的读写操作仍路由到源节点●目的节点如果没有需要的索引，此时会构建索引●目的节点开始请求数据块中的数据，保存在本地●在迁移期间，源节点上的数据如果发生变化，在迁移完之后，目的节点会同步源节点上变更的数据●同步结束后，目的节点会与配置服务器建立连接，配置服务器更新元数据，此期间源节点阻塞写操作●源节点上的旧数据被删除 1.5、备份数据12mongodump -h dbhost -d dbname -o directory 命令格式mongodump -h 127.0.0.1：28002 -d test -o /home/backup 将本机数据库test中数据备份到/home/backup下恢复数据mongorestore -h dbhost -d dbname –directoryperdb dbdirectory dbdirectory为备份数据所在位置 复制集2.1、概念与特性概念复制集是一组具有相同数据的mongod实例，包含主节点以及从节点。集群中任何时候只有一个主节点，主节点将数据变更操作写到oplog（封顶表）中，从节点读取oplog，并将oplog中的操作应用的本地数据，从而实现数据同步。 特性●异步复制从节点并不是实时复制主节点中的数据●自动容灾主节点宕机，主动发起选举●读操作从从节点上读到的数据可能并不是最新的 2.2、复制集成员复** 制集最多包含50个节点，最多只能有7个可以投票。包含以下节点类型●主节点primary**可以执行读写操作，所有节点均可以执行读操作。默认情况下，读请求只会发送给主节点，可以通过read preference设置。主节点的优先级priority至少为1。●从节点secondary只可以执行读操作。从节点通过与主节点同步，实现备份数据的功能，复制集至少有一个从节点。通过配置复制集的配置文件可以设置从节点是否参与选举（vote=0）以及是否可以被选举为主节点（priority=0）优先级priority为0的节点不能发起选举，不能被选举为主节点，但可以投票。●隐藏节点通过设置从节点的hidden属性，可以对客户端隐藏节点，不接受读写请求，无法被选举为主节点（priority=0），只能投票，主要用于备份数据。●延时节点通过设置隐藏节点的slaveDelay属性可以使节点延时一定时间从主节点复制数据，可以起到保护数据的作用。延时节点是在隐藏节点的基础上，多了一个延时属性。●仲裁节点Arbiter本身不存储数据，不能被选举为主节点，只能投票，仲裁节点主要用于使复制集中节点个数为奇数，从而容易达到多数派。仲裁节点只消耗极少的资源，但不要与主节点、从节点部署在同一个物理节点上。●非投票节点不参与投票，但存储数据，可以接受读操作 2.3、复制集管理●use admin切换到admin数据库●config={_id:”myset”,members:[{“_id”:0,”host”:”127.0.0.1:28001”,”priority”:2},{“_id”:1,”host”:”127.0.0.1:28002”,”priority”:1}]}●rs.initiate(config)修改复制集配置●cfg=rs.conf()●cfg.members[0].priority=1●rs.reconfig(cfg)复制集维护将配置文件中的replset注释掉，从而以单机模式启动复制集，维护完毕后再加入复制集。 2.4、大多数原则概念如果复制集中的节点个数为N，则大多数为N/2+1（N/2向下取整），当复制集中存活节点数小于大多数时，不存在主节点，无法提供写服务。 作用大多数原则保证了，在任何时刻复制集中的主节点个数不会超过一个。比如复制集部署在两个机房，两个机房通信发生故障，不含有主节点的机房会选举出一个主节点，等到故障恢复，复制集就会存在两个主节点，无法保证数据的一致性。 2.5、选举选举的前提条件复制集满足大多数原则。在选举的过程中，复制集无法进行写操作。 何时会引发选举●复制集初始化时或被重新配置后●主节点宕机或主节点网络不可达，即大多数节点无法连接主节点●人为将主节点降为从节点，执行rs.stepDown(n)命令●有更高优先级的节点加入复制集 选举特点●优先级高的节点优先被选为主节点●具有最高optime的节点被选为主节点●如果优先级高的节点不具有最新的optime，那么首先会同步主节点的oplog●优先级为0的节点无法发起选举，且无法成为主节点，只能投票。●所有成员都可以否决选举，包括不投票的节点Non-voting 何时否决选举●发起选举的节点不包含最新数据●发起选举的节点优先级比其他节点低●发起选举的节点没有持有最高的optime 2.6、数据回滚概念：在主节点失效之前，从节点并未全部复制主节点上的数据，原先的主节点在选举出新的主节点后重新加入复制集，会导致旧主节点与新主节点数据不一致，旧主节点会将不一致的数据回滚，从而与主节点数据保持一致。 避免数据回滚默认情况下，在主节点上写入成功后，就会向客户端返回结果，可能造成回滚，客户端可以修改写策略writeconcern为向大多数节点写入成功后才返回结果。 2.7、读写策略writeconcern：不等待主节点写入成功，客户端就返回结果；等待主节点写入成功，就返回结果；等到大多数节点写入成功，才返回结果readconcern：只读主节点、只读从节点、优先主节点、优先从节点、读网络延迟最小的节点 2.8、复制集优缺点优点●自动容灾。主节点宕机，通过投票选举主节点，保证数据安全●自动备份数据，无需人工干预●易于扩展●数据可靠性高缺点●消耗资源高●不能解决负载均衡的问题●客户端读到的数据可能并未持久化 ，比如：客户端可以读到最新写入的数据，但数据有可能存在磁盘写入失败的可能；客户端读到的数据可能发生rolled back","tags":[]},{"title":"vagrant虚拟机共享目录加速","date":"2020-04-25T13:13:00.000Z","path":"post/1735609695.html","text":"vagrant一般都是搭配VirtualBox虚拟机的，但是vagrant默认启动VirtualBox虚拟机的目录共享方式是VirtualBox方式，这种方式性能差，如果文件夹里面的文件数量不多的情况下影响还不是很大，如果数量多的话会很慢，网上说的可以通过安装vagrant一款插件使共享目录以”nfs”方式，速度会变快很多 1vagrant plugin install vagrant-winnfsd 但是我实际上发现还有另外一款vagrant插件能使共享目录性能更高。这款插件不但能使共享目录支持”nfs”方式而且还有其他系统优化，使实际共享目录性能更高。 1vagrant plugin install vagrant-vbguest 不管是哪一款vagant插件都需要在对应的共享目录后面加”, type: “nfs””才能生效 1config.vm.synced_folder \"D:/xiangmu\",\"/home/wwwroot\" , type: \"nfs\"","tags":[]},{"title":"mongodb添加账号密码","date":"2020-04-21T02:52:00.000Z","path":"post/2802551252.html","text":"添加账号密码 12345use admindb.createUser(&#123;user:\"root\",pwd:\"\",roles:[\"root\"]&#125;)use testdb.createUser(&#123;user:'root',pwd:'root',roles:['readWrite']&#125;)","tags":[]},{"title":"centos7安装mongodb和设置开机自动启动","date":"2020-04-21T02:51:00.000Z","path":"post/2911353081.html","text":"1、安装mongod123456789wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.5.tgztar -zxvf mongodb-linux-x86_64-rhel70-4.2.5.tgzmv mongodb-linux-x86_64-rhel70-4.2.5/ /usr/local/mongodbmkdir -p /usr/local/mongodb/datamkdir -p /usr/local/mongodb/logsln -s /usr/local/mongodb/bin/mongod mongodln -s /usr/local/mongodb/bin/mongo mongo 2、设置开机自动启动1、新增sh脚本添加关联mongodb.conf文件vim /etc/mongodb.conf 1234net: port: 27017 bindIp: 0.0.0.0 # Listen to local interface only, comment to listen on all interfaces. ipv6: false 新增sh脚本放在根目录的shell下面mongod_start.sh 1234#!/bin/bash# pkill -9 mongod;/usr/local/mongodb/bin/mongod --shutdown --dbpath /usr/local/mongodb/data/;nohup /usr/local/mongodb/bin/mongod -f /etc/mongodb.conf --dbpath=/usr/local/mongodb/data --logpath=/usr/local/mongodb/logs/log.txt &gt; /shell/mongod.log 2&gt;&amp;1 &amp; 设置权限777 1chmod 777 mongod_start.sh 2、添加脚本到开机自启动1vim /etc/rc.d/rc.local 文件后面追加sh /shell/mongod_start.sh 1chmod +x /etc/rc.d/rc.local 然后就搞定了","tags":[]},{"title":"submit text3批量选中指定关键词的所有行","date":"2020-04-20T09:12:00.000Z","path":"post/1152603659.html","text":"如下数据,想选中关键词为:_id: ObjectId(“,的所有行 1234567891011db.getCollection(\"goods\").insert([ &#123; _id: ObjectId(\"5e9d165dad06000091003a57\"), name: \"哈士奇饼干1\", price: 33&#125; ]);db.getCollection(\"goods\").insert([ &#123; _id: ObjectId(\"5e9d165dad06000091003a58\"), name: \"神奇宝贝一只1\", stock: 100, price: 20.58&#125; ]); 1、选择任意一个”_id: ObjectId(“”后Ctrl+F出现搜索界面，然后按下Find All,这时就会选中所有”_id: ObjectId(“”的关键词。 2、按下Ctrl+L即可选中所有包含关键词”_id: ObjectId(“”的行。","tags":[]},{"title":"MongoDB基本操作之CRUD","date":"2020-04-19T16:24:00.000Z","path":"post/1234652124.html","text":"创建文档命令有三种: 123创建单个文档：db.collection.insertOne()创建单个或多个文档：db.collection.insert()创建多个文档：db.collection.insertMany() insertOne示例： 1234db.goods.insertOne(&#123; name:\"哈士奇饼干\", price:33,&#125;) 返回结果： 1234&#123; \"acknowledged\": true, \"insertedId\": ObjectId(\"5e9c52e32a170000ea003e5a\") //5e9c544c2a170000ea003e5b为本次插入数据的主键id&#125; 插入复合主键 12345db.goods.insertOne(&#123; _id:&#123;id:123,type:'shop'&#125;, name:\"这个是复合组件\", price:20.58,&#125;) insertMany示例： 1234db.goods.insertMany([ &#123;name:\"哈士奇饼干1\",price:33,&#125;, &#123;name:\"神奇宝贝一只1\",stock:100,price:20.58,&#125;]) 返回结果： 1234567&#123; \"acknowledged\": true, \"insertedIds\": [ ObjectId(\"5e9c56b72a170000ea003e5d\"), ObjectId(\"5e9c56b72a170000ea003e5e\") ]&#125; insert示例： 1234db.goods.insert([ &#123;name:\"哈士奇饼干1\",price:33,&#125;, &#123;name:\"神奇宝贝一只1\",stock:100,price:20.58,&#125;]) 返回结果： 12345678BulkWriteResult(&#123; \"nRemoved\" : 0, \"nInserted\" : 2, //插入成功的数量 \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"writeErrors\" : [ ]&#125;) 查询文档读取全部文档既不筛选，也不投射 1db.collection.find(); 示例: 1db.goods.find(); 返回结果: 1234567891011121314151617181920// 1&#123; \"_id\": ObjectId(\"5e9c48b42a170000ea003e45\"), \"name\": \"纸巾一包\", \"price\": 100&#125;// 2&#123; \"_id\": ObjectId(\"5e9c48eb2a170000ea003e48\"), \"name\": \"奶茶一杯\", \"price\": 20.58&#125;// 3&#123; \"_id\": ObjectId(\"5e9c56b72a170000ea003e5d\"), \"name\": \"哈士奇饼干1\", \"price\": 33&#125; 匹配查询示例： 12//查询名字为\"纸巾一包\"并且价格为100元的数据db.goods.find(&#123;name:\"纸巾一包\",price:100&#125;) 返回结果 12345&#123; \"_id\": ObjectId(\"5e9c48b42a170000ea003e45\"), \"name\": \"纸巾一包\", \"price\": 100&#125; 复合主键查询1db.goods.find(&#123;\"_id.type\":\"shop\"&#125;) 操作符比较操作符{:{$:}}$eq 匹配字段值相等的文档 （可以用于string和int类型） =$ne 匹配字段值不等的文档 !=$gt 匹配字段值大于查询值的文档 &gt;$gte 匹配字段值大于或等于查询值的文档 &gt;=$lt 匹配字段值小于查询值的文档 &lt;$lte 匹配字段值小于或等于查询值的文档 &lt;=$in 匹配字段值与任意查询值相等的文档 “in”$nin 匹配字段值与任意查询值不相等的文档 “not in” 12//匹配查询db.goods.find(&#123;name:&#123;$eq:\"纸巾一包\"&#125;&#125;) 12//in查询db.goods.find(&#123;\"name\":&#123;$in:[\"纸巾一包\",\"奶茶一杯\"]&#125;&#125;) 12//读取价格大于32元且小于101元的商品db.goods.find(&#123;price:&#123;$gt:32,$lt:101&#125;&#125;) 123//复合组件查询db.goods.find(&#123;\"_id.type\":&#123;$eq:\"shop\"&#125;&#125;)db.goods.find(&#123;\"_id.type\":&#123;$in:[\"shop\"]&#125;&#125;) 逻辑操作符$not 匹配筛选条件不成立的文档$and 匹配多个筛选条件全部成立的文档$or 匹配至少一个筛选条件成立的文档$nor 匹配多个筛选条件全部不成立的文档逻辑运算符示例： 1234//查询价格不小于32元的商品db.goods.find(&#123;price:&#123;$not:&#123;$lt:32&#125;&#125;&#125;)//相当于下面的取反db.goods.find(&#123;price:&#123;$lt:32&#125;&#125;) 123456789//获取价格为100，并且名称为\"纸巾一包\"的商品db.goods.find(&#123; $and:[ &#123;price:&#123;$eq:100&#125;&#125;, &#123;name:\"纸巾一包\"&#125; ]&#125;)//可以简写如下db.goods.find(&#123;price:&#123;$eq:100&#125;,name:\"纸巾一包\"&#125;) 12345678//获取价格不是100，并且名称不为\"纸巾一包\"的商品db.goods.find(&#123; $nor:[ &#123;price:&#123;$eq:100&#125;&#125;, &#123;name:\"纸巾一包\"&#125; ]&#125;)注意：nor也会筛选出并不包含查询字段的文档！！比如会把没有price和name字段的文档也查出来！ 字段操作符12$exists 匹配包含查询字段的文档 $type 匹配字段符合查询值的文档 $type对应的类型和BSON类型序号 12345678910111213141516171819Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1.Max key 127 示例 12//查询复合主键中存在type字段的数据db.goods.find(&#123;\"_id.type\":&#123;$exists:true&#125;&#125;) 12//查询存在name字段的数据db.goods.find(&#123;name:&#123;$exists:true&#125;&#125;) 12//查询类型为普通主键和复合主键的数据db.goods.find(&#123;_id:&#123;$type:[\"objectId\",\"object\"]&#125;&#125;) 12//查询类型为string的数据db.goods.find(&#123;name:&#123;$type:[\"string\"]&#125;&#125;) 数组操作符12$all 匹配数组字段中包含所有查询值的文档$elemMatch 匹配数组字段中至少存在一个值满足筛选条件的文档 示例 123456789101112131415先插入数据db.goods.insert( [ &#123; name:\"皮卡丘一只\", price:100, contact:[\"111111\",\"Alabama\",\"US\"] &#125;, &#123; name:\"小火龙一只\", price:120, contact:[[\"222222\",\"333333\"],\"Beijing\",\"China\"] &#125; ]) 12//查询contact字段中同时包含\"China\"和\"Beijing\"字段的文档db.goods.find(&#123;contact:&#123;$all:[\"China\",\"Beijing\"]&#125;&#125;) 12//查询联系方式中包含\"222222\",\"333333\"的文档，注意，这里的数组如果只有\"222222\"是查询不到的，这里是数组全等的关系db.goods.find(&#123;contact:&#123;$all:[[\"222222\",\"333333\"]]&#125;&#125;) 12//查询电话号码范围在大于111110和小于222222之间的数据db.goods.find(&#123;contact:&#123;$elemMatch:&#123;$gt:\"111110\",$lt:\"222222\"&#125;&#125;&#125;) 1234567//查询电话号码范围在\"大于111110和小于222222之间\"并且\"大于211111和小于444444之间\"的数据db.goods.find(&#123; contact:&#123;$all:[ &#123;$elemMatch:&#123;$gt:\"111111\",$lt:\"222222\"&#125;&#125;, &#123;$elemMatch:&#123;$gt:\"211111\",$lt:\"444444\"&#125;&#125; ]&#125;&#125;) 运算操作符1234&#123;&lt;field&gt;:&#123;:/pattern/,:'&lt;options&gt;'&#125;&#125;&#123;&lt;field&gt;:&#123;:/pattern/&lt;options&gt;&#125;&#125;$regex 在和$in操作符一起使用时，只能使用/pattern/&lt;options&gt; 12345//读取name字段以\"皮\"或\"j\"开头的文档数据db.goods.find(&#123;name:&#123;$in:[/^皮/,/^j/]&#125;&#125;)//读取name字段包含LIE（不区分大小写）的文档数据db.goods.find(&#123;name:&#123;$regex:/LIE/,$options:'i'&#125;&#125;) 游标游历完游标中所有文档之后，或者在10分钟之后，游标便会自动关闭可以使用noCursorTimeout()函数来保持游标一直有效 1var myCursor=db.goods.find().noCursorTimeout() 在这之后，在不遍历游标的情况下，你需要主动关闭游标 1myCursor.close() 游标函数1234567cursor.hasNext() //当还有没遍历完的游标文档时，返回truecursor.next() //获取下一次遍历的游标文档cursor.forEach(&lt;function&gt;) //遍历游标中所有指向的文档cursor.limit(&lt;number&gt;) //返回指定条数cursor.skip(&lt;offest&gt;) //跳过文档中指定数量的文档（传入1表示跳过第一篇文档）cursor.count(&lt;applySkipLimit&gt;) //默认情况下，&lt;applySkipLimit&gt;为false，即cursor.count()不会考虑cursor.skip()和cursor.limit()的效果cursor.sort(&lt;document&gt;) //这里的&lt;document&gt;定义了排序的要求（1从小到大排序，-1从大到小排序） 12345678var myCursor=db.goods.find();while(myCursor.hasNext())&#123; printjson(myCursor.next());&#125;var myCursor=db.goods.find();myCursor.forEach(printjson) 12345db.goods.find().limit(1)db.goods.find().skip(1)db.goods.find().limit(1).count() //返回所有文档总数db.goods.find().limit(1).count(true) //返回一篇文档 12//price字段从大到小排序，并且name字段由小到大排序 （相当于mysql中同时两个排序条件的规则）db.goods.find().sort(&#123;price:-1,name:1&#125;) 注意事项cursor.skip(),cursor.limit(),cursor.count()优先级：count()-&gt;skip()-&gt;limit() 123cursor.skip()在cursor.limit()之前执行db.goods.find().limit(5).skip(3)结果返回的是5篇文章，从第4篇到第9篇文章 12cursor.count()在cursor.skip()和cursor.limit()之前执行db.goods.find().limit(5).skip(3).sort(&#123;price:-1&#125;) 文档投影123db.goods.find(&lt;query&gt;,&lt;projection&gt;)不使用投影时，db.goods.find()返回符合筛选条件的完整文档使用投影可以只返回指定的字段 123456&#123;field:inclusion&#125;1表示返回部分字段，0表示不返回字段，（1和0不可组合使用，_id字段除外）//只返回name字段db.goods.find(&#123;&#125;,&#123;name:1,_id:0&#125;)//返回除name之外的字段db.goods.find(&#123;&#125;,&#123;name:0&#125;) 12//$slide:2,表示返回前2条，-2表示返回倒数2条，[1,2]表示返回第二条到第三条db.goods.find(&#123;&#125;,&#123;name:1,content:&#123;$slide:[1,2]&#125;&#125;) $elemMatch和$操作符可以返回数组字段中满足筛选条件的第一个元素 12345//返回content数组字段中第一个排序大于\"Alabama\"的数据，（没content字段的文档也会被返回）db.goods.find(&#123;&#125;,&#123;name:1,content:&#123;$elemMatch:&#123;$gt:\"Alabama\"&#125;&#125;&#125;)//返回content数组字段中第一个排序大于\"Alabama\"的数据db.goods.find(&#123;content:&#123;$gt:\"Alabama\"&#125;&#125;,&#123;name:1,\"content.$\":1,&#125;) 更新操作注意：1、 db.goods.update(where查询条件,更新的值,其它条件) db.goods.update({“uid”:3},{$rename:{“name”:”alias”}},{multi:true})2、文档更新操作只会更新一篇文档，即使条件符合多篇文档，也只会更新一篇，如果想要更新所有符合条件的文档，需要添加第三个参数{multi:true} 文档更新操作符1234567$set 更新或新增字段$unset 删除字段$rename 重命名字段 &#123;$rename:&#123;&lt;field1&gt;:&lt;newName1&gt;,&lt;field2&gt;:&lt;newName2&gt;&#125;&#125;$inc 加减字段值 (字段不存在时，会默认创建且值为加减的值)$mul 相乘字段值 (字段不存在时，会默认创建且值为0 )$min 比较减少字段值 (保留最小的值)(字段不存在会自动创建且值为指定的值)(类型不一致按BSON数据类型排序规则比较)$max 比较增大字段值 (保留最大的值)(字段不存在会自动创建且值为指定的值)(类型不一致按BSON数据类型排序规则比较) 12//（$rename）重命名写法db.goods.update(&#123;\"uid\":3&#125;,&#123;$rename:&#123;\"name\":\"alias\"&#125;&#125;) 12//（$rename）将数组字段content中的name字段迁移到最外面的name字段db.goods.update(&#123;\"uid\":3&#125;,&#123;$rename:&#123;\"content.name\":\"name\"&#125;&#125;) 12//（$rename）将最外面的name字段迁移到数组字段content中的name字段db.goods.update(&#123;\"uid\":3&#125;,&#123;$rename:&#123;\"name\":\"content.name\"&#125;&#125;) 12//（$inc）将条件uid=3的文档，price字段加一db.goods.update(&#123;\"uid\":3&#125;,&#123;$inc:&#123;\"price\":1&#125;&#125;) 12//（$min）源字段大于50时，修改成50db.goods.update(&#123;\"uid\":3&#125;,&#123;$min:&#123;\"price\":50&#125;&#125;) （源price值为30时，不变，保留30） 12345678910111213BSON数据类型排序规则最小 Null Numbers(ints,longs,doubles,decimals) Symbol,String Object Array BinData ObjectId Boolean Date最大 Regular Expression 数组更新操作符12345$addToSet 向数组中增添元素$pop 从数组中移除元素$pull 从数组中移除指定元素$pullAll 从数组中有选择性地移除元素$push 向数组中增添元素 12//($addToSet)将content数组字段添加\"nihao\",\"wohao\"两个值db.goods.update(&#123;\"uid\":3&#125;,&#123;$addToSet:&#123;\"content\":&#123;$each:[\"nihao\",\"wohao\"]&#125;&#125;&#125;) 12//$pull删除content数组中包含\"皮\"字的字段db.goods.update(&#123;\"uid\":3&#125;,&#123;$pull:&#123;\"content\":&#123;$regex:/皮/&#125;&#125;&#125;) 123&#123;$pullAll:&#123;&lt;field&gt;:[&lt;vaule1&gt;,&lt;vaule2&gt;]&#125;&#125;相当于&#123;$pull:&#123;&lt;field&gt;:&#123;$in:[&lt;vaule1&gt;,&lt;vaule2&gt;]&#125;&#125;&#125; 更新操作符12$ 第一个符合条件的占位符$[] 数组中的所有元素 更新数组中的特定元素$是数组中第一个符合筛选条件的数组元素的占位符，搭配更新操作符使用，可以对满足筛选条件的数组元素进行更新 1db.goods.update(&#123;&lt;array&gt;:&lt;query selector&gt;&#125;,&lt;update operator&gt;:&#123;\"&lt;array&gt;.$\",vaule&#125;) $[]指代数组字段中的所有元素，搭配更新操作符使用，可以对数组中的所有元素进行更新 1db.goods.update(&#123;&lt;array&gt;:&lt;query selector&gt;&#125;,&lt;update operator&gt;:&#123;\"&lt;array&gt;.$[]\",vaule&#125;) 123456789101112//源数据&#123; \"_id\": ObjectId(\"5e9f08904757000020000235\"), \"content\": [ \"nihao\", \"我很好\" ], \"uid\": 3, \"name\": \"nihao\", \"num\": 1, \"num1\": 0&#125; 123456789//将content数组中值为\"nihao\"的替换成\"updated\"db.goods.update(&#123; uid:3, content:\"nihao\"&#125;, &#123; $set: &#123; \"content.$\":\"updated\" &#125;&#125;) 12345678将content数组中所有字段替换成\"updated\"db.goods.update(&#123; uid:3&#125;, &#123; $set: &#123; \"content.$[]\":\"updated\" &#125;&#125;) 更新文档选项{multi:}更新多个文档到目前为止，我们在update命令中使用的筛选条件只对应一篇文档在默认情况下，即使筛选条件对应了多篇文档，update命令仍然只会更新一篇文档 1234将所有name值为\"nihao\"的文档num值改成10db.goods.update(&#123; name:\"nihao\"&#125;, &#123;$set: &#123;\"num\":10&#125;&#125;,&#123;multi:true&#125;) 原子性在MongoDB中，更新单个的文档操作是原子性的。默认情况下，如果一个update()更新多个文档，那么对每个文档的更新是原子性的，但是对整个update而言则不是原子性的。有可能存在前一个文档更新成功，后面的文档更新失败的情况。由于单个文档的更新是原子性的，如果两个更新同时发生，就会出现阻塞，先到的先执行，所以文档最终结果由靠后的操作决定。 **简单的说就是对同一篇文档进行更新，文档最终结果以最后的更新操作为结果**删除命令12db.collection.remove() 删除文档db.collection.drop() 删除集合 注：1、删除文档默认是删除所有符合条件的文档，和update操作不一样，如果需要指定只删除一篇文档，加上第二个参数（{justOne:true}） 删除文档1234db.&lt;collection&gt;.remove(&lt;query&gt;,&lt;options&gt;)&lt;options&gt;声明了一些删除操作的参数db.goods.remove() 12//删除name值为\"nihao\"的所有文档db.goods.remove(&#123;name:\"nihao\"&#125;) 12//删除name值为\"nihao\"的一篇文档（&#123;justOne:true&#125;）db.goods.remove(&#123;name:\"nihao\"&#125;,&#123;justOne:true&#125;) 12//删除集合内的所有文档db.goods.remove(&#123;&#125;) 删除集合12db.&lt;collection&gt;.drop(&lt;writeConcern&gt;,&lt;document&gt;)db.goods.drop() 这里的writeConcern文档定义了本次集合删除操作的安全写级别、drop命令可以删除整个集合，包括集合中的所有文档，以及集合的索引","tags":[]},{"title":"使用docker容器运行mongodb","date":"2020-04-19T00:49:00.000Z","path":"post/2627105888.html","text":"使用docker容器运行mongodb 1、下载Mongodb的官方docker镜像1docker pull mongo:latest 2、启动一个Mongodb服务器容器1docker run --name mongo -p 27017:27017 --restart=always -v /mongodb/data:/data/db -d mongo:latest –name mongodb 容器名称-v /mongodb/data:/data/db –&gt;挂载数据目录-d –&gt;后台运行容器 3、添加用户和设置密码，并且尝试连接12345docker exec -it mongo mongo admin# 创建一个名为 admin，密码为 123456 的用户。&gt; db.createUser(&#123; user:'admin',pwd:'123456',roles:[ &#123; role:'userAdminAnyDatabase', db: 'admin'&#125;,\"readWriteAnyDatabase\"]&#125;);# 尝试使用上面创建的用户信息进行连接。&gt; db.auth('admin', '123456') 查看mongodb容器日志 1docker logs mongodb","tags":[]},{"title":"swoole两种运行模式BASE和PROCESS的区别","date":"2020-04-13T10:01:00.000Z","path":"post/570064033.html","text":"Server的两种运行模式介绍单线程模式（SWOOLE_BASE）这种模式就是传统的异步非阻塞Server。与Nginx和Node.js等程序是完全一致的。 在时间循环中直接回调PHP的函数，而不是dispatch投递任务。如果回调函数中有阻塞操作会导致Server退化为同步模式。worker_num参数对与BASE模式仍然有效，会启动多个Worker进程。 BASE模式下没有Master进程的角色 每个Worker进程同时承担了Process模式下Reactor线程和Worker进程两部分职责 BASE模式下Manager进程是可选的，当设置了worker_num=1，并且没有使用Task和MaxRequest特性时，底层将直接创建一个单独的Worker进程，不创建Manager进程 BASE模式的优点： BASE模式没有IPC开销，性能更好 BASE模式代码更简单，不容易出错 BASE模式的缺点： TCP连接是在Worker进程中维持的，所以当某个Worker进程挂掉时，此Worker内的所有连接都将被关闭 少量TCP长连接无法利用到所有Worker进程 TCP连接与Worker是绑定的，长连接应用中某些连接的数据量大，这些连接所在的Worker进程负载会非常高。但某些连接数据量小，所以在Worker进程的负载会非常低，不同的Worker进程无法实现均衡。BASE模式的适用场景： 如果客户端连接之间不需要交互，可以使用BASE模式。如Memcache、Http服务器等。 进程模式（SWOOLE_PROCESS）多进程模式是最复杂的方式，用了大量的进程间通信、进程管理机制。适合业务逻辑非常复杂的场景。Swoole提供了完善的进程管理、内存保护机制。 在业务逻辑非常复杂的情况下，也可以长期稳定运行。 Swoole在Reactor线程中提供了Buffer的功能，可以应对大量慢速连接和逐字节的恶意客户端。另外也提供了CPU亲和设置选项，使程序运行的效率更好。 进程模式的优点： 连接与数据请求发送是分离的，不会因为某些连接数据量大某些连接数据量小导致Worker进程不均衡 Worker进程发送致命错误时，连接并不会被切断 可实现单连接并发，仅保持少量TCP连接，请求可以并发地在多个Worker进程中处理 进程模式的缺点： 存在2次IPC的开销，master进程与worker进程需要使用UnixSocket进行通信 不支持某些高级功能，如sendwait、pause、resume等操作 原文链接：https://wiki.swoole.com/wiki/page/353.htmlhttps://wiki.swoole.com/wiki/diff/?id=353&amp;version=2&amp;compare=current","tags":[]},{"title":"Swoole 如何处理高并发以及异步 I/O 的实现","date":"2020-04-13T09:15:00.000Z","path":"post/3001131064.html","text":"Swoole 介绍1.swoole提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步MySQL，异步Redis， 数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole还内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。 2.Swoole可以广泛应用于互联网、移动通信、企业软件、网络游戏、物联网、车联网、智能家庭等领域。 使用PHP+Swoole作为网络通信框架， 可以使企业IT研发团队的效率大大提升，更加专注于开发创新产品。 3.Swoole底层内置了异步非阻塞、多线程的网络IO服务器。PHP程序员仅需处理事件回调即可，无需关心底层。与Nginx/Tornado/Node.js等全异步的框架不同，Swoole既支持全异步，也支持同步。 Swoole 如何处理高并发①对Reactor模型介绍我们都知道IO复用异步非阻塞程序使用的是经典的Reactor模型，Reactor就是反应堆的意思，也就是说它本身不处理任何数据收发。只是可以监视一个socket(比如管道、eventfd、信号)句柄的事件变化。Reactor只作为一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close等都是在callback中完成的。看看下面图片就可以了解到。 ②swoole的架构咱们再来看看swoole的架构，我们也可以从以下借鉴的图片可以看出，swoole采用的架构模式：多线程Reactor+多进程Worker，因为reactor是基于epoll的，所以不难看出每个reactor，它可以用来处理无数个连接请求。 如此，swoole就轻松的实现了高并发的处理。这里对高并发还不清楚的话，请自行网上看看教程，这里就不多做解释了。 Swoole的处理连接流程图如下： 当请求到达时，Swoole是这样处理的： Swoole 如何实现异步I/O 基于上面的Swoole结构图，我们可以知道：Swoole的worker进程有2种类型：一种是普通的worker进程，一种是task worker进程。这两种类型分别用来处理什么呢？ worker进程：用来处理普通的耗时不是太长的请求 task worker进程：用来处理耗时较长的请求，比如数据库的I/O操作 我们再以异步MySQL举例，不难看出通过worker、task worker结合的方式，我们就实现了异步I/O。 参考原文：https://baijiahao.baidu.com/s?id=1648878759459418111&amp;wfr=spider&amp;for=pc","tags":[]},{"title":"RabbitMq常用命令","date":"2020-04-10T09:18:00.000Z","path":"post/77993866.html","text":"一、消息对列常用命令 1、启插件 1rabbitmq-plugins enable rabbitmq_management 2、移除服务 1rabbitmq-service remove 3、安装服务 1rabbitmq-service install 4、重启服务 1rabbitmq-server restart 5、启用RabbitMq服务 1rabbitmq-server start 6、停止应用程序 1rabbitmqctl stop_app 7、启用运用 1rabbitmqctl start_app 8、重置清除节点的配置(先stop_app，后reset节点) 12rabbitmqctl stop_apprabbitmqctl rest 9、启用日志插件命令 1rabbitmq-plugins enable rabbitmq_tracing 二、消息集群常用命令1、加入集群[–ram添加内存模式 默认disk模式] 1rabbitmqctl join_cluster --ram rabbit@mq01 2、查看集群状态 1rabbitmqctl cluster_status 3、更改节点模式[顺序 关闭运用－〉更改类型-&gt;开启运用] 123rabbitmqctl stop_app –停止运用服务rabbitmqctl change_cluster_node_type disc/ram –更改节点为磁盘或内存节点rabbitmqctl start_app –开启运用服务 4、创建策略(集群同步策略……) 1set_policy [-p vhostpath] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125; [priority] 5、查看策略 1rabbitmqctl list_policies 6、移除远程offline的节点1.节点2停掉应用 1rabbitmqctl stop_app 2.节点1执行删除 1rabbitmqctl forget_cluster_node rabbit@mq02 7、设置集群名称 1rabbitmqctl set_cluster_name cluster_name 8、设置镜像模式 123456789101112131415Rabbit提供镜像功能，需要基于rabbitmq策略来实现，政策是用来控制和修改群集范围的某个vhost队列行为和Exchange行为 set_policy [-p vhostpath] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125; [priority]rabbitmqctl set_policy ha-all \"^ha.\" \"&#123;\"\"ha-mode\"\":\"\"all\"\"&#125;\"rabbitmqctl set_policy ha-all \"^\" \"&#123;\"\"ha-mode\"\":\"\"all\"\",\"\"ha-sync-mode\"\":\"\"automatic\"\"&#125;\"rabbitmqctl set_policy -p jjw-uplus ha-all \"^\" \"&#123;\"\"ha-mode\"\":\"\"all\"\",\"\"ha-sync-mode\"\":\"\"automatic\"\"&#125;\"下面的例子将“two.”开头的queue mirror到cluster中两个节点，且自动同步rabbitmqctl rabbitmqctl set_policy ha-two \"^two\\.\" '&#123;\"ha-mode\":\"exactly\",\"ha-params\":2,\"ha-sync-mode\":\"automatic\"&#125;'pattern 是匹配队列名称的正则表达式 , 进行区分哪些队列使用哪些策略definition 其实就是一些arguments, 支持如下参数：ha-mode：One of all, exactly or nodes (the latter currently not supported by web UI).ha-params：Absent if ha-mode is all, a number if ha-mode is exactly, or an array of strings if ha-mode is nodes.ha-sync-mode：One of manual or automatic. //如果不指定该参数默认为manual,这个在高可用集群测试的时候详细分析 federation-upstream-set：A string; only if the federation plugin is enabled.可通过如下命令确认哪些salve在同步rabbitmqctl list_queues name slave_pids synchronised_slave_pids 9、手动同步queue 1rabbitmqctl sync_queue name 10、取消queue同步 1rabbitmqctl cancel_sync_queue name 11、查看所有队列信息 1rabbitmqctl list_queues 12、获取队列信息 12rabbitmqctl list_queues[-p vhostpath] [queueinfoitem ...]Queueinfoitem可以为：name，durable，auto_delete，arguments，messages_ready，messages_unacknowledged，messages，consumers，memory。 13、获取Exchange信息 12rabbitmqctl list_exchanges[-p vhostpath] [exchangeinfoitem ...]Exchangeinfoitem有：name，type，durable，auto_delete，internal，arguments。 14、获取Binding信息 12rabbitmqctl list_bindings[-p vhostpath] [bindinginfoitem ...] Bindinginfoitem有：source_name，source_kind，destination_name，destination_kind，routing_key，arguments。 15、获取Connection信息 12rabbitmqctl list_connections [connectioninfoitem ...]Connectioninfoitem有：recv_oct，recv_cnt，send_oct，send_cnt，send_pend等。 16、获取Channel信息 12rabbitmqctl list_channels[channelinfoitem ...]Channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked。","tags":[]},{"title":"rabbitmq management新建账号","date":"2020-04-10T03:33:00.000Z","path":"post/545059273.html","text":"123rabbitmqctl add_user test test rabbitmqctl set_user_tags test administrator rabbitmqctl set_permissions -p / test \".*\" \".*\" \".*\"","tags":[]},{"title":"composer切换国内源","date":"2020-04-07T15:51:00.000Z","path":"post/186457038.html","text":"调用方式以阿里云为例，全局模式（推荐）： 1$ composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 单独项目使用： 1$ composer config repo.packagist composer https://mirrors.aliyun.com/composer/ https://learnku.com/php/wikis/30594https://www.uedbox.com/post/58890/","tags":[]},{"title":"AOP的定义和原理","date":"2020-04-05T14:47:00.000Z","path":"post/1167956631.html","text":"一、本课目标理解Spring AOP的原理掌握Spring AOP的七个术语 二、面向切面编程一、本课目标理解Spring AOP的原理掌握Spring AOP的七个术语 二、面向切面编程（AOP）在上面这个图中的代码中，业务代码就红框中的那些，其他的代码都是做一些其他的事情，但是这些代码还不得不写，并且这些代码散布在我们系统的各处。我们把这样的的代码叫做横切逻辑，也叫横切关注点；把我们的业务代码叫做核心关注点。但是我们构建系统的目的是为了解决业务问题，现在却要维护多个方面的事情，怎么样才能“专心”做事情？这就是AOP的目标：让我们“专心做事”。 2.1AOP原理第一、将复杂的需求分解出不同的方面，将公共功能集中解决。在上图中，中间的是我们的代码，AOP就是将这些分离，包括权限，日志和持久化等等。 第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能综上、所谓面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术。 2.2AOP相关术语1、增强处理：前置增强、后置增强、环绕增强、异常抛出增强、最终增强等类型2、切入点3、连接点4、切面5、目标对象6、AOP代理7、织入 1、增强处理 2、切入点通过一个表达式告诉SpringAOP去哪个地方进行增强。也可以把这个表达式理解为一个查询条件，系统会根据这个查询条件查询到我们要进行增强的代码位置。 3、连接点就是SpringAOP通过告诉它的切入点的位置找的的具体的要增强的代码的位置，这个代码位置就是连接点。 4、切面切面由一组（增强处理和切入点）共同构成。 5、目标对象目标对象就是被增强的目标类。我们也称之为委托类。 6、AOP代理 代理类就是AOP代理，里面包含了目标对象以及一些增强处理。系统会用AOP代理类代替委托类去执行功能。 7、织入织入就是将我们的增强处理增强到指定位置的过程。（AOP）在上面这个图中的代码中，业务代码就红框中的那些，其他的代码都是做一些其他的事情，但是这些代码还不得不写，并且这些代码散布在我们系统的各处。我们把这样的的代码叫做横切逻辑，也叫横切关注点；把我们的业务代码叫做核心关注点。但是我们构建系统的目的是为了解决业务问题，现在却要维护多个方面的事情，怎么样才能“专心”做事情？这就是AOP的目标：让我们“专心做事”。 2.1AOP原理第一、将复杂的需求分解出不同的方面，将公共功能集中解决。在上图中，中间的是我们的代码，AOP就是将这些分离，包括权限，日志和持久化等等。 第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能综上、所谓面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术。 2.2AOP相关术语1、增强处理：前置增强、后置增强、环绕增强、异常抛出增强、最终增强等类型2、切入点3、连接点4、切面5、目标对象6、AOP代理7、织入 1、增强处理 2、切入点通过一个表达式告诉SpringAOP去哪个地方进行增强。也可以把这个表达式理解为一个查询条件，系统会根据这个查询条件查询到我们要进行增强的代码位置。 3、连接点就是SpringAOP通过告诉它的切入点的位置找的的具体的要增强的代码的位置，这个代码位置就是连接点。 4、切面切面由一组（增强处理和切入点）共同构成。 5、目标对象目标对象就是被增强的目标类。我们也称之为委托类。 6、AOP代理 代理类就是AOP代理，里面包含了目标对象以及一些增强处理。系统会用AOP代理类代替委托类去执行功能。 7、织入织入就是将我们的增强处理增强到指定位置的过程。 原文链接：https://www.jianshu.com/p/469540f13f5f","tags":[]},{"title":"常用的几个vagrant命令","date":"2020-03-25T15:54:00.000Z","path":"post/2828478489.html","text":"1234567891011121314151617$ vagrant init # 初始化$ vagrant up # 启动虚拟机$ vagrant halt # 关闭虚拟机$ vagrant reload # 重启虚拟机$ vagrant ssh # SSH 至虚拟机$ vagrant suspend # 挂起虚拟机$ vagrant resume # 唤醒虚拟机$ vagrant status # 查看虚拟机运行状态$ vagrant destroy # 销毁当前虚拟机#box管理命令$ vagrant box list # 查看本地box列表$ vagrant box add # 添加box到列表$ vagrant box remove # 从box列表移除 原文链接：https://www.cnblogs.com/think-a-lot/p/7754328.html","tags":[]},{"title":"go-grpc调试工具grpcui","date":"2020-03-25T05:06:00.000Z","path":"post/2929107307.html","text":"写Grpc服务端接口的时候有个麻烦的地方就是如何调试的问题，不像http接口直接用Postman进行接口调试，可以借助第三方调试工具grpcui来实现类似的调试效果 github源码地址：https://github.com/fullstorydev/grpcui grpcui 使用安装根据官方 README.md 文档安装即可。 12go get github.com/fullstorydev/grpcuigo install github.com/fullstorydev/grpcui/cmd/grpcui 这时，在 $GOPATH/bin 目录下，生成一个 grpcui 可执行文件。 执行个命令，验证下： 1grpcui -help 输出： 1234Usage: grpcui [flags] [address] ...... 表示安装成功了。 运行grpcui -plaintext grpc项目域名/ip+端口号 1grpcui -plaintext 127.0.0.1:50051 例如我本地启动的grpc服务端如下端口为50051 直接在window运行如下命令 1grpcui -plaintext 127.0.0.1:50051 浏览器打开即可看到如下效果 因为grpcui给出的ui端口是随机的，我本地是采用vagrant+VirtualBox，端口映射需要启动的时候就指定了，所以我这里服务端的项目依旧在linux下运行，但是grpcui命令我就直接在window（宿主机运行），把编译好的grpcui二进制文件直接放在window的Path环境变量目录即可","tags":[]},{"title":"为什么一定要用MQ中间件？","date":"2020-03-21T15:01:00.000Z","path":"post/1626959203.html","text":"这篇文章我们会把消息中间件这块高频的面试问题来给大家说一下，也会涵盖一些 MQ 中间件常见的技术问题。 假如说面试官看你简历里写了 MQ 中间件的使用经验，很可能会有如下的问题： 你们公司生产环境用的是什么消息中间件?为什么要在系统架构中引入消息中间件?引入消息中间件之后会有什么好处以及坏处?好，下面我们一个个的来分析! 你们公司生产环境用的是什么消息中间件? 这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是 RabbitMQ，然后可以初步给一些你对不同 MQ 中间件技术的选型分析。 举个例子：比如说 ActiveMQ 是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 但是问题在于没法确认 ActiveMQ 可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用 ActiveMQ 做异步调用和系统解耦。 然后你可以说说 RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模 RabbitMQ 集群支撑自身业务的 case 较多，国内各种中小型互联网公司使用 RabbitMQ 的实践也比较多。 除此之外，RabbitMQ 的开源社区很活跃，较高频率的迭代版本，来修复发现的 Bug 以及进行各种优化，因此综合考虑过后，公司采取了 RabbitMQ。 但是 RabbitMQ 也有一点缺陷，就是他自身是基于 Erlang 语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的 Erlang 语言功底才可以。 然后可以聊聊 RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 而且 RocketMQ 是基于 Java 语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 另外就是 Kafka。Kafka 提供的消息中间件的功能明显较少一些，相对上述几款 MQ 中间件要少很多。 但是 Kafka 的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。 因此 Kafka 在大数据领域中配合实时计算技术(比如 Spark Streaming、Storm、Flink)使用的较多。但是在传统的 MQ 中间件使用场景中较少采用。 PS：如果大家对上述一些 MQ 技术还没在自己电脑部署过，没写几个 helloworld 体验一下的话，建议先上各个技术的官网找到 helloworld demo，自己跑一遍玩玩。 为什么在你们系统架构中要引入消息中间件? 回答这个问题，其实就是让你先说说消息中间件的常见使用场景。然后结合你们自身系统对应的使用场景，说一下在你们系统中引入消息中间件解决了什么问题。 1. 系统解耦 假设你有个系统 A，这个系统 A 会产出一个核心数据，现在下游有系统 B 和系统 C 需要这个数据。那简单，系统 A 就是直接调用系统 B 和系统 C 的接口发送数据给他们就好了。 整个过程，如下图所示：但是现在要是来了系统 D、系统 E、系统 F、系统 G，等等，十来个其他系统慢慢的都需要这份核心数据呢?如下图所示： 大家可别以为这是开玩笑，一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应 N 多个服务，这些系统与系统之间有着错综复杂的关系网络。 如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。 此时如果你要是采取上面那种模式来设计系统架构，那么绝对你负责系统 A 的同学要被烦死了。 先是来一个人找他要求发送数据给一个新的系统 H，系统 A 的同学要修改代码，然后在那个代码里加入调用新系统 H 的流程。 一会那个系统 B 是个陈旧老系统要下线了，告诉系统 A 的同学：别给我发送数据了，接着系统 A 再次修改代码不再给这个系统 B。 然后如果要是某个下游系统突然宕机了呢?系统 A 的调用代码里是不是会抛异常? 那系统A的同学会收到报警说异常了，结果他还要去 care 是下游哪个系统宕机了。 所以在实际的系统架构设计中，如果全部采取这种系统耦合的方式，在某些场景下绝对是不合适的，系统耦合度太严重。 并且互相耦合起来并不是核心链路的调用，而是一些非核心的场景(比如上述的数据消费)导致了系统耦合，这样会严重的影响上下游系统的开发和维护效率。 因此在上述系统架构中，就可以采用 MQ 中间件来实现系统解耦。系统 A 就把自己的一份核心数据发到 MQ 里，下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费，如下图所示： 2. 异步调用 假设你有一个系统调用链路，是系统 A 调用系统 B，一般耗时 20ms;系统 B 调用系统 C，一般耗时 200ms;系统 C 调用系统 D，一般耗时 2s，如下图所示： 现在最大的问题就是：用户一个请求过来巨慢无比，因为走完一个链路，需要耗费 20ms + 200ms + 2000ms(2s) = 2220ms，也就是 2 秒多的时间。 但是实际上，链路中的系统 A 调用系统 B，系统 B 调用系统 C，这两个步骤起来也就 220ms。 就因为引入了系统 C 调用系统 D 这个步骤，导致最终链路执行时间是 2 秒多，直接将链路调用性能降低了 10 倍，这就是导致链路执行过慢的罪魁祸首。 那此时我们可以思考一下，是不是可以将系统 D 从链路中抽离出去做成异步调用呢?其实很多的业务场景是可以允许异步调用的。 举个例子，你平时点个外卖，咔嚓一下子下订单然后付款了，此时账户扣款、创建订单、通知商家给你准备菜品。 接着，是不是需要找个骑手给你送餐?那这个找骑手的过程，是需要一套复杂算法来实现调度的，比较耗时。 但是其实稍微晚个几十秒完成骑手的调度都是 ok 的，因为实际并不需要在你支付的一瞬间立马给你找好骑手，也没那个必要。 那么我们是不是就可以把找骑手给你送餐的这个步骤从链路中抽离出去，做成异步化的，哪怕延迟个几十秒，但是只要在一定时间范围内给你找到一个骑手去送餐就可以了。 这样是不是就可以让你下订单点外卖的速度变得超快?支付成功之后，直接创建好订单、账户扣款、通知商家立马给你准备做菜就 ok 了，这个过程可能就几百毫秒。 然后后台异步化的耗费可能几十秒通过调度算法给你找到一个骑手去送餐，但是这个步骤不影响我们快速下订单。 当然我们不是说那些大家熟悉的外卖平台的技术架构就一定是这么实现的，只不过是用一个生活中常见的例子给大家举例说明而已。 所以上面的链路也是同理，如果业务流程支持异步化的话，是不是就可以考虑把系统 C 对系统 D 的调用抽离出去做成异步化的，不要放在链路中同步依次调用。 这样，实现思路就是系统 A→系统 B→系统 C，直接就耗费 220ms 后直接成功了。 然后系统 C 就是发送个消息到 MQ 中间件里，由系统 D 消费到消息之后慢慢的异步来执行这个耗时 2s 的业务处理。通过这种方式直接将核心链路的执行性能提升了 10 倍。 整个过程，如下图所示： 3. 流量削峰 假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在 8 核 16G 的机器的上，正常处理都是 ok 的，每秒几百请求是可以轻松抗住的。 但是如下图所示，在高峰期一下子来了每秒钟几千请求，瞬时出现了流量高峰，此时你的选择是要搞 10 台机器，抗住每秒几千请求的瞬时高峰吗? 那如果瞬时高峰每天就那么半个小时，接着直接就降低为了每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗? 大部分时候，每秒几百请求，一台机器就足够了，但是为了抗那每天瞬时的高峰，硬是部署了 10 台机器，每天就那半个小时有用，别的时候都是浪费资源的。但是如果你就部署一台机器，那会导致瞬时高峰时，一下子压垮你的系统，因为绝对无法抗住每秒几千的请求高峰。 此时我们就可以用 MQ 中间件来进行流量削峰。所有机器前面部署一层 MQ，平时每秒几百请求大家都可以轻松接收消息。 一旦到了瞬时高峰期，一下涌入每秒几千的请求，就可以积压在 MQ 里面，然后那一台机器慢慢的处理和消费。 等高峰期过了，再消费一段时间，MQ 里积压的数据就消费完毕了。 这个就是很典型的一个 MQ 的用法，用有限的机器资源承载高并发请求。 如果业务场景允许异步削峰，高峰期积压一些请求在 MQ 里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。 引入消息中间件之后会有什么好处以及坏处? 如果你在系统架构里引入了消息中间件之后，会有哪些缺点? 1. 系统可用性降低 首先是你的系统整体可用性绝对会降低，给你举个例子，我们就拿之前的一幅图来说明。 比如说一个核心链路里面，系统 A→系统 B→系统 C，然后系统 C 是通过 MQ 异步调用系统 D 的。看起来很好，你用这个 MQ 异步化的手段解决了一个核心链路执行性能过差的问题。 但是你有没有考虑另外一个问题，就是万一你依赖的那个 MQ 中间件突然挂掉了怎么办? 这个还真的不是异想天开，MQ、Redis、MySQL 这些组件都有可能会挂掉。一旦你的 MQ 挂了，就导致你的系统的核心业务流程中断了。 本来你要是不引入 MQ 中间件，那其实就是一些系统之间的调用，但是现在你引入了 MQ，就导致你多了一个依赖。一旦多了一个依赖，就会导致你的可用性降低。 因此，一旦引入了 MQ 中间件，你就必须去考虑这个 MQ 是如何部署的，如何保证高可用性。 甚至在复杂的高可用的场景下，你还要考虑如果 MQ 一旦挂了以后，你的系统有没有备用兜底的技术方案，可以保证系统继续运行下去。 2. 系统稳定性降低 还是上面那张图，大家再来看一下： 不知道大家有没有发现一个问题，这个链路除了 MQ 中间件挂掉这个可能存在的隐患之外，可能还有一些其他的技术问题。 比如说，莫名其妙的，系统 C 发了一个消息到 MQ，结果那个消息因为网络故障等问题，就丢失了。这就导致系统 D 没有收到那条消息。 这可就惨了，这样会导致系统 D 没完成自己该做的任务，此时可能整个系统会出现业务错乱，数据丢失，严重的 Bug，用户体验很差等各种问题。 这还只是其中之一，万一说系统 C 给 MQ 发送消息，不小心一抽风重复发了一条一模一样的，导致消息重复了，这个时候该怎么办? 可能会导致系统 D 一下子把一条数据插入了两次，导致数据错误，脏数据的产生，最后一样会导致各种问题。 或者说如果系统 D 突然宕机了几个小时，导致无法消费消息，结果大量的消息在 MQ 中间件里积压了很久，这个时候怎么办? 即使系统 D 恢复了，也需要慢慢的消费数据来进行处理。所以这就是引入 MQ 中间件的第二个大问题，系统稳定性可能会下降，故障会增多，各种各样乱七八糟的问题都可能产生。 而且一旦产生了一个问题，就会导致系统整体出问题。你就需要为了解决各种 MQ 引发的技术问题，采取很多的技术方案。 关于这个，我们后面会用专门的文章聊聊 MQ 中间件的这些问题的解决方案，包括： 消息高可靠传递(0 丢失) 消息幂等性传递(绝对不重复) 百万消息积压的线上故障处理 3. 分布式一致性问题 引入消息中间件，还有分布式一致性的问题。举个例子，比如说系统 C 现在处理自己本地数据库成功了，然后发送了一个消息给 MQ，系统 D 也确实是消费到了。 但是结果不幸的是，系统 D 操作自己本地数据库失败了，那这个时候咋办? 系统 C 成功了，系统 D 失败了，会导致系统整体数据不一致了啊。所以此时又需要使用可靠消息最终一致性的分布式事务方案来保障。 关于这个，可以参考之前的一篇文章：最终一致性分布式事务如何保障实际生产中 99.99% 高可用? 我们在里面详细阐述了系统之间异步调用场景下，如何采用分布式事务方案保证其数据一致性。 总结 最后，我们来做一个简单的小结。在面试中要答好这个问题，首先一定要熟悉 MQ 这个技术的优缺点。了解清楚把他引入系统是为了解决哪些问题的，但是他自身又会带来哪些问题。 此外，对于引入 MQ 以后，是否对他自身可能引发的问题有一些方案的设计，来保证你的系统高可用、高可靠的运行，保证数据的一致性。这个也要做好相应的准备。 原文链接：https://blog.csdn.net/u011277123/article/details/87803486","tags":[]},{"title":"yii2简单实现redis消息队列","date":"2020-03-16T11:06:00.000Z","path":"post/1297686480.html","text":"生产者代码示例1234567public function producer()&#123; $data=[]; //组装要推送队列的业务逻辑数据 $key='redisKey'; $redis=Yii::$app-&gt;redis; $redis-&gt;lpush($key,json_encode($data)); $redis-&gt;expire($key, 60*60*24); &#125; 消费者代码示例123456789101112131415161718192021222324252627282930public function consumer()&#123; $redis=Yii::$app-&gt;redis; //限制本次队列只有一个进程在操作 self::lockLimit(self::FUEL_LIST_RECORD_LOCK_KEY,2,60*30); //获取当前队列长度 $length = $redis-&gt;llen(self::FUEL_LIST_RECORD_LOG_KEY); for($i=0;$i&lt;$length;$i++)&#123; try&#123; $record = $redis-&gt;rpop(self::FUEL_LIST_RECORD_LOG_KEY); if(!empty($record))&#123; //处理业务逻辑 $record_decode=json_decode($record,true); &#125; &#125;catch(\\Throwable $e)&#123; //判断重试次数，这里设置超过3次重试就不再重试 if(!isset($record_decode['try_count']))$record_decode['try_count']=0; if(isset($record_decode['try_count']) &amp;&amp; $record_decode['try_count']&lt;3 )&#123; ++$record_decode['try_count']; $redis-&gt;lpush(self::FUEL_LIST_RECORD_LOG_KEY,json_encode($record_decode)); $redis-&gt;expire(self::FUEL_LIST_RECORD_LOG_KEY, 60*60*24); &#125; //打个日志记录 CoreHelper::write(json_encode(['handleRecordLogNew',$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE)); &#125; &#125; Yii::$app-&gt;redis-&gt;del(self::FUEL_LIST_RECORD_LOCK_KEY); //业务逻辑处理完毕，解锁&#125; 消费者取数据处理有另一种省性能的方案即Lrange+Lrem，这个具体还没实践过，逻辑上能减少redis连接次数，从而提高程序执行效率，等有空实践再补上。","tags":[{"name":"redis","slug":"redis","permalink":"https://yzdzh.github.io/tags/redis/"}]},{"title":"Redis实现消息队列","date":"2020-03-15T16:01:00.000Z","path":"post/4033908611.html","text":"队列本身其实是个有序的列表，而Redis是支持list的，可以利用redis的列表(List)来实现简单队列。 一般有两种方式：1、LPUSH(头部插入)和RPOP(尾部弹出)2、RPUSH(尾部插入)和LPOP(头部弹出)两种均可，下面示例使用的是：第一种：LPUSH和RPOP。 一般开发的时候我们会分为生产者和消费者，生产者生产消息，消费者获取消息进行处理。 1234Producer: redis-&gt;lpush(‘joblist’, ‘this is Job-1’); redis-&gt;lpush(‘joblist’, ‘this is Job-2’); …. 12345Cosumer: job = redis-&gt;rpop(‘joblist’);// return Job-1 done the job…. job = redis-&gt;rpop(‘joblist’);// return Job-2 done the job… 需要注意的是redis实现的消息队列功能本身存在一些缺陷，这也是redis本身的限制，一个重要的缺陷在于没有类似RabbitMQ那样成熟的ACK消息确认机制（虽然redis也可以通过代码层自己封装写个ack消息确认机制，但相对比较繁杂。一般常见的思路是POP时将pop出的数据放到备份的地方，当有ACK请求（确认消息被消耗）后将备份的信息删除掉；每次在pop前需要检查备份队列中有没有过期的数据没有ack的，如果有则PUSH到list中后再从list中POP出来。）一般来说如果对数据没有极高要求的又不想搭建其他QM组件的话可以直接用redis的list功能实现，如果对数据幂等性、一致性有要求的话建议使用RabbitMQ（目前功能最完善的企业级MQ产品，虽然吞吐量不是最强的，但足以应付绝大多数公司的流量）或者不想自己搭建的话也可以直接使用第三方的消息队列产品，比如阿里云的消息队列，安全性能均有保障。","tags":[]},{"title":"php之yii2简单分布式redis锁限制和缓存设置","date":"2020-03-05T10:21:00.000Z","path":"post/2709942805.html","text":"yii2框架简单加锁锁定本次任务没执行完之前不允许再请求本次方法，注意这只是简单实现能应对几乎所有并发场景。 12345678910111213141516171819202122232425262728293031323334353637/** * 具体业务逻辑代码 */ public function business()&#123; $key ='redis_key_name：'.'订单id或其他本次锁的唯一值'; self::lockLimit($key);// //这里需要用try catch，防止中途出异常，导致没解锁 try &#123; //具体处理的业务逻辑代码 Yii::$app-&gt;redis-&gt;del($key); //业务逻辑处理完毕，解锁 &#125; catch (\\Throwable $e) &#123; Yii::$app-&gt;redis-&gt;del($key); //业务逻辑处理失败，还是解锁 //日志方法，具体自己实现 CoreHelper::write(json_encode(['eventName','order_id'=&gt;$order-&gt;order_id??'',$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE)); &#125; &#125; /** * redis锁限制（设置锁的时间，具体看自己的业务场景，如果是限制手速的一般设置1秒，如果是限制本次情况处理完前不接受其他请求的一般设置120秒（一个接口请求一般不超过120秒）） * $key 要限制的用户或订单唯一key值 （$key='redis_key_name：'.'订单id或其他本次锁的唯一值';） * $scene 场景 1、手速限制 2、处理事务限制 * $expire 锁有效期，默认是有1和120秒的设置 */ public static function lockLimit($key,$scene=2,$expire=0)&#123; $redis=Yii::$app-&gt;redis; $lock_result = $redis-&gt;setnx($key,1); if($scene==1)$redis-&gt;expire($key, empty($expire)?1:$expire); //判断不是空直接中断本次操作 if (!$lock_result) &#123; //随便你们return或其他友好输出，下面的输出只是个人示例 throw new Exception('-1000', \"亲，太过频繁对身体不好\"); &#125; if($scene==2)$redis-&gt;expire($key, empty($expire)?120:$expire); &#125; 缓存设置1234567891011121314151617181920$key='redis_key_name'; $key_data=Yii::$app-&gt;redis-&gt;get($key); //判断不是空直接中断本次操作 if(!empty($key_data))&#123; //随便你们return或其他友好输出，下面的输出只是个人示例 retrun json_decode($key_data,true); &#125; //这里需要用try catch，防止中途出异常，导致没解锁 try &#123; //具体处理的业务逻辑代码 $data=['内容']; //确定没锁后先赋值redis，锁上先 Yii::$app-&gt;redis-&gt;set($key,json_encode($data)); Yii::$app-&gt;redis-&gt;expire($key, 300); &#125; catch (\\Throwable $e) &#123; //日志方法，具体自己实现 CoreHelper::write(json_encode(['eventName','order_id'=&gt;$order-&gt;order_id??'',$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE)); &#125; 注意：1、Throwable为php7及以上版本的万能捕获任何异常，php7以下版本用：Exception2、请确定自己已经在配置文件配置redis配置 找到config/development.php(开发环境)或config/production.php(生产环境)，在’components’ =&gt; []中加入，如: 1234567'components' =&gt; [ 'redis' =&gt; [ 'class' =&gt; 'BaseComponents\\base\\RedisConn', 'hostname' =&gt; '127.0.0.1', 'port' =&gt; 6379, ],] 3、Yii如果找不到请在命名空间后加 use Yii;","tags":[]},{"title":"CentOS -- 添加开机自启动 命令 脚本","date":"2019-12-03T08:31:00.000Z","path":"post/2362243123.html","text":"如果只是添加一条开机启动的命令: chmod +x /etc/rc.d/rc.local 将命令写到 /etc/rc.d/rc.local 这个文件中 reboot 一、添加开机自启服务 在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)： 1$ systemctl enable jenkins.service #设置jenkins服务为自启动服务 1$ sysstemctl start jenkins.service #启动jenkins服务 二、添加开机自启脚本 在centos7中增加脚本有两种常用的方法，以脚本hexo-sever.sh为例（脚本文件）： 123#!/bin/bashcd /www/wwwroot/hexonohup hexo s &gt; test.log 2&gt;&amp;1 &amp; 具体操作范例（添加脚本自启动）： 1、赋予脚本可执行权限（/www/wwwroot/hexo/hexo-sever.sh是你的脚本路径） 1$ chmod +x /www/wwwroot/hexo/hexo-sever.sh 2、打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加如下内容su - user -c ‘/www/wwwroot/hexo/hexo-sever.sh’ 12$ vim /etc/rc.local$ su - user -c '/www/wwwroot/hexo/hexo-sever.sh' 3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限 1$ chmod +x /etc/rc.d/rc.local 具体参考原文：https://www.cnblogs.com/mafeng/p/10697303.html","tags":[{"name":"linux","slug":"linux","permalink":"https://yzdzh.github.io/tags/linux/"}]},{"title":"linux修改时区","date":"2019-11-15T07:19:00.000Z","path":"post/95235842.html","text":"在.bash_profile里面设置 TZ=’Asia/Shanghai’ 1$ vim .bash_profile 最后date查看时区是否改变了 1$ source .bash_profile","tags":[{"name":"linux","slug":"linux","permalink":"https://yzdzh.github.io/tags/linux/"}]},{"title":"php捕获异常方法","date":"2019-11-05T09:07:00.000Z","path":"post/3232863668.html","text":"12345678php捕获异常try &#123; //希望被捕获的代码&#125; catch (\\Throwable $e) &#123; //日志方法，具体自己实现 CoreHelper::write(json_encode(['eventName','order_id'=&gt;$order-&gt;order_id??'',$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE)); &#125; 注意：Throwable为php7及以上版本的万能捕获任何异常，php7以下版本用：Exception","tags":[]},{"title":"TCP和UDP的区别和优缺点","date":"2019-07-29T14:37:00.000Z","path":"post/3905120281.html","text":"1、TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP对系统资源要求较多，UDP对系统资源要求较少。 2、为什么UDP有时比TCP更有优势?UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。 （1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。 （2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。 采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 3、UDP和TCP编程步骤也有些不同，如下：TCP:TCP编程的服务器端一般步骤是： 1、创建一个socket，用函数socket() 2、设置socket属性，用函数setsockopt(); * 可选 3、绑定IP地址、端口等信息到socket上，用函数bind(); 4、开启监听，用函数listen()； 5、接收客户端上来的连接，用函数accept()； 6、收发数据，用函数send()和recv()，或者read()和write(); 7、关闭网络连接； closesocket(SocketListen);closesocket(SocketWaiter); 8、关闭监听；SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的。 TCP编程的客户端一般步骤是： 1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 4、设置要连接的对方的IP地址和端口等属性； 5、连接服务器，用函数connect()； 6、收发数据，用函数send()和recv()，或者read()和write(); 7、关闭网络连接； UDP:与之对应的UDP编程步骤要简单许多，分别如下： UDP编程的服务器端一般步骤是： 1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind(); 4、循环接收数据，用函数recvfrom(); 5、关闭网络连接； UDP编程的客户端一般步骤是： 1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 4、设置对方的IP地址和端口等属性; 5、发送数据，用函数sendto(); 6、关闭网络连接； 原文链接：https://blog.csdn.net/xiaobangkuaipao/article/details/76793702","tags":[]},{"title":"TCP粘包，产生的原因以及解决方案","date":"2019-07-29T14:12:00.000Z","path":"post/144770649.html","text":"1、粘包的概念粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 TCP粘包：指发送方发送的若干数据包在接收方接收时粘成一团，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾 2、出现粘包的原因出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。 发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。 接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。 3、粘包的处理方式：（1）当时短连接的情况下，不用考虑粘包的情况（2）如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包（3）如果双方建立长连接，需要在连接后一段时间内发送不同结构数据 接收方创建预处理线程，对接收到的数据包进行预处理，将粘连的包分开； 分包是指在出现粘包的时候我们的接收方要进行分包处理。（在长连接中都会出现） 数据包的边界发生错位，导致读出错误的数据分包，进而曲解原始数据含义。 粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。 如何处理TCP粘包和TCP拆包问题？无论是TCP拆包还是TCP粘包本质问题都在于无法区分包的界限，可以采用以下三种方式来区分包的界限 1.消息数据固定长度，但是浪费存储和网络资源 2.使用分割符来区分包的界限 3.数据包的头部中增加数据包长度字段 参考文章：https://blog.csdn.net/Nice07/article/details/83515660https://www.cnblogs.com/yinbiao/p/11015039.html","tags":[]},{"title":"Elasticsearch的功能、适用场景以及特点介绍","date":"2019-05-25T14:52:00.000Z","path":"post/3482167954.html","text":"学习了什么是Elasticsearch之后，针对工程而言，我们更加关心的是Elasticsearch它能干什么？能在什么地方发挥作用？跟其它类似的东西相比它不同的地方在哪里?归纳起来就是Elasticsearch在什么场景下，相比于其他类似的技术而言，它更适合做什么 1、Elasticsearch的功能（1）分布式的搜索引擎和数据分析引擎搜索：百度，网站的站内搜索，IT系统的检索数据分析：电商网站，最近7天牙膏这种商品销量排名前十的商家有哪些； 新闻网站，最近一个月访问量排名前3的新闻板块是哪些 （2）全文检索，结构化检索，数据分析全文检索：我想搜索商品名称包含牙膏的商品，select * from products where product_name like “%牙膏%”结构化检索：我想搜索商品分类为日化用品的商品有哪些，select * from products where category_id=”日化用品”数据分析：我们分析每一个商品分类下有多少个商品，select category_id,count(*) from products group by category_id （3）对海量数据进行近实时的处理分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了近实时：检索个数据要花费1个小时（这就不叫做近实时，叫做离线批处理，batch-processing）;在秒级别对数据进行搜索和分析才叫做近实时 2、Elasticsearch的适用场景国外：（1）维基百科 全文检索、高亮、搜索推荐（2）The Guardian(国外新闻网站) 用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他们知道他的文章的公众反馈（好、坏、热门。。。）（3）Stack Overflow(国外程序异常讨论论坛)，全文检索，搜索到相关问题和答案，如果程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案（4）github，搜索上千亿行的代码（5）电商网站，检索商品（6）日志数据的分析 elk技术（7）商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户（8）BI系统，商业智能Business Intelligence。比如有个大型商场集团，BI，分析一下某某地区最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表。 国内站内搜索（电商、招聘、门户等等）IT系统搜索（OA、CRM、ERP等等）数据分析 3、Elasticsearch的特点（1）可以作为大型分布式集群（数百台服务器）技术，处理PB级的数据，服务大公司；也可以运行在单机上服务于小公司（2）Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES：lucene(全文检索)，商用的数据分析软件，分布式数据库（3）对用户而言，是开箱即用的，非常简单，作为中小型应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，此时的场景是数据量不大，操作不是太复杂（4）数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理，Elasticsearch作为传统数据库的一个补充，提供了数据库所不能提供的很多功能 原文链接：https://segmentfault.com/a/1190000018876875","tags":[]},{"title":"Elasticsearch之curl操作PUT和POST区别","date":"2019-05-22T12:30:00.000Z","path":"post/1704684589.html","text":"1.更新：PUT会将新的json值完全替换掉旧的；而POST方式只会更新相同字段的值，其他数据不会改变，新提交的字段若不存在则增加。 2.PUT和DELETE操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有什么不同，DELETE也是一样。 3.POST操作不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建了若干的资源。 4.创建操作可以使用POST，也可以使用PUT，区别就在于POST是作用在一个集合资源(/articles)之上的，而PUT操作是作用在一个具体资源之上的(/articles/123)。 原文链接：https://blog.csdn.net/kaaosidao/article/details/77489373","tags":[]},{"title":"win10设置开机自动启动vagrant虚拟机","date":"2019-04-08T01:30:00.000Z","path":"post/3932398064.html","text":"1、自制bat脚本将下面的命令复制到.bat后缀的文件中，如start_vagrant.bat 1cmd /k \"cd /d D: &amp;&amp; vagrant up\" cmd /k “cd /d (vagrant虚拟机所在目录) &amp;&amp; vagrant up” 2、设置bat脚本开机自动启动1、设置bat脚本开机自动启动”窗口+R”打开命令窗口，并且输入命令Shell:startup，点击确定按钮运行该命令2、将自制的bat启动脚本快捷方式放入文件夹中","tags":[]},{"title":"php根据当前定位经纬度排序","date":"2019-03-16T18:21:00.000Z","path":"post/1713014064.html","text":"php根据当前定位经纬度排序直接贴代码 12345678910111213141516171819202122/** * 计算两组经纬度坐标 之间的距离 * params ：lat1 纬度1； lng1 经度1； lat2 纬度2； lng2 经度2； len_type （1:m or 2:km); * return m or km */ public static function GetDistance($lat1, $lng1, $lat2, $lng2, $len_type = 1, $decimal = 2) &#123; defined('EARTH_RADIUS') || define('EARTH_RADIUS', 6378.137); // 地球半径 defined('PI') || define('PI', 3.1415926); $radLat1 = $lat1 * PI / 180.0; $radLat2 = $lat2 * PI / 180.0; $a = $radLat1 - $radLat2; $b = ($lng1 * PI / 180.0) - ($lng2 * PI / 180.0); $s = 2 * asin(sqrt(pow(sin($a / 2), 2) + cos($radLat1) * cos($radLat2) * pow(sin($b / 2), 2))); $s = $s * EARTH_RADIUS; $s = round($s * 1000); if ($len_type &gt; 1) &#123; $s /= 1000; &#125; return round($s, $decimal); &#125; 两组经纬度对比中间的距离 lat1 纬度1； lng1 经度1为第一组，lat2 纬度2； lng2 经度2为第二组，不管两组顺序怎么调换，结果距离都是一样。另外还有mysql版根据当前定位经纬度排序在我的博客中也有写，文章地址：https://wangzhuanglin.gitee.io/post/2178671104.html","tags":[]},{"title":"mysql根据当前定位经纬度排序","date":"2019-03-15T18:11:00.000Z","path":"post/2178671104.html","text":"网上流行的大概有两种sql写法，发现两种计算的结果不一样，也就是有一种不是很准确，试了下百度在线api计算结果，发现第二种和百度在线api计算结果一致，应该是最正确的。这里简单的整理下这种。 用户当前定位经纬度 纬度:$lat (23.100571) ,经度:$lng (113.389937) 12345678910111213SELECT id, latitude, longitude round(( 2 * 6378.137 * ASIN( SQRT( POW( SIN( PI()*( $lat- latitude )/ 360 ), 2 )+ COS( PI()* $lat / 180 )* COS( latitude * PI()/ 180 )* POW( SIN( PI()*( $lng- longitude )/ 360 ), 2 )))) * 1000 ) AS juli FROM table(表名)ORDER BY `juli` 这里的计算结果是米为单位，如果想要km为单位的话直接去掉最后面的 “1000”,这里我是做了四拾伍入，不保留小数点，直接取整数米，如果只是排序的话建议不加round和1000，提高sql执行效率。 另外还有php版的根据当前定位经纬度排序具体文章地址：https://wangzhuanglin.gitee.io/post/1713014064.html","tags":[]},{"title":"PhpStorm配置使用phpunit单元测试","date":"2019-03-13T10:49:00.000Z","path":"post/2488698508.html","text":"本人的php本地开发环境是vagrant+VirtualBox，php7.0版本 phpunit6.5.3版本学会php用单元测试调试对于代码后期调试还是很有帮助的，这里直接简单介绍本人的安装配置过程，不一定适合每个人，但是逻辑都差不多。本人的本地php版本是7.0，所以安装了phpunit6.5.3版本（再高就不支持了），如果php版本高的同学可以安装更高的phpunit版本。 1、安装phpunit这里有两种方式，全局安装和局部安装，本人直接用局部安装 1.全局安装phpunit命令脚本12345$ wget https://phar.phpunit.de/phpunit-6.5.3.phar$ chmod +x phpunit-6.5.3.phar$ sudo mv phpunit-6.5.3.phar /usr/local/bin/phpunit$ phpunit --versionPHPUnit x.y.z by Sebastian Bergmann and contributors. 2.全局安装安装phpunit代码123$ wget https://phar.phpunit.de/phpunit-6.5.3.phar$ php phpunit-6.5.3.phar --versionPHPUnit x.y.z by Sebastian Bergmann and contributors. 下载phpunit.phar文件包，linux直接下载命令 1wget https://phar.phpunit.de/phpunit-6.5.3.phar 或者直接简单暴力直接下载我直接归类将phpunit6.5.3.phar放在下面的目录： 123[root@localhost /]# cd /home/dev_tool/php/[root@localhost php]# lsphpunit-6.5.3.phar 2、Phpstorm配置phpunit话不多说，直接上截图吧！ 到了这来就配置完毕！ 3、phpstrom直接生成单元测试case1、直接点击对应要生成的单元测试的方法一键生成 2、这里安装的PHPUnit是6.5版本，所以要选择PHPUint6+ 3、直接对着单元测试方法点击运行即可第三点也可以直接在命令行执行，具体命令如下：具体测试命令phpunit –filter methodName ClassName path/to/file.phpphpunit –filter 模块名 类名 具体单元测试所在文件phpunit –filter testTwo StackTest TestController.php","tags":[]},{"title":"php计算两个日期相隔多少年，多少月，多少天","date":"2019-03-05T08:24:00.000Z","path":"post/2705668210.html","text":"123456789101112131415161718192021222324252627/**function：计算两个日期相隔多少年，多少月，多少天*param string $date1[格式如：2011-11-5]*param string $date2[格式如：2012-12-01]*return array array('年','月','日');*/function diffDate($date1,$date2)&#123; if(strtotime($date1)&gt;strtotime($date2))&#123; $tmp=$date2; $date2=$date1; $date1=$tmp; &#125; list($Y1,$m1,$d1)=explode('-',$date1); list($Y2,$m2,$d2)=explode('-',$date2); $Y=$Y2-$Y1; $m=$m2-$m1; $d=$d2-$d1; if($d&lt;0)&#123; $d+=(int)date('t',strtotime(\"-1 month $date2\")); $m--; &#125; if($m&lt;0)&#123; $m+=12; $Y--; &#125; return array('year'=&gt;$Y,'month'=&gt;$m,'day'=&gt;$d);&#125; 示例： 123456789print_r(diffDate(&#39;2020-03-02&#39;,&#39;2020-03-10&#39;));exit;结果：Array( [year] &#x3D;&gt; 0 [month] &#x3D;&gt; 0 [day] &#x3D;&gt; 8)","tags":[]},{"title":"docker批量删除镜像或容器","date":"2019-01-12T09:03:00.000Z","path":"post/3458257055.html","text":"docker批量删除容器、镜像 1、删除所有容器 1docker rm `docker ps -a -q` 2、删除所有镜像 1docker rmi `docker images -q` 3、按条件删除镜像 没有打标签 1docker rmi `docker images -q | awk '/^&lt;none&gt;/ &#123; print $3 &#125;'` 镜像名包含关键字 1docker rmi --force `docker images | grep doss-api | awk '&#123;print $3&#125;'` //其中doss-api为关键字 原文链接：https://www.cnblogs.com/yanyouqiang/p/8301856.html","tags":[]},{"title":"Centos下安装docker","date":"2019-01-10T14:06:00.000Z","path":"post/1001383450.html","text":"1、卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 3、设置yum源（设置稳定的仓库） 123456789阿里云地址$ sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo源地址，不建议使用$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 4、安装最新版本的 Docker Engine-Community 和 containerd 1$ sudo yum install docker-ce docker-ce-cli containerd.io 5、启动并加入开机启动 12$ sudo systemctl start docker$ sudo systemctl enable docker 6、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) 1$ docker version 参考文章：https://www.runoob.com/docker/centos-docker-install.htmlhttps://www.cnblogs.com/yufeng218/p/8370670.html","tags":[]},{"title":"hexo添加百度统计","date":"2018-12-03T15:11:00.000Z","path":"post/193856365.html","text":"环境操作系统： win10 前提已经利用hexo3搭建好了个人博客网站。 步骤主题next官网地址 ①先在百度统计官网，注册一个账号，并且绑定好域名。 ②再复制hm.js后面的字符串如图： ③编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 至此完成。 接下来使用：① hexo clean 清除已经生成的静态文件②hexo g 生成静态文件③hexo d 把静态文件部署到GitHub page 刚开始我以为是我的网站上可以看到百度统计的结果。原本是要到百度统计官网去看。 原文链接：https://blog.csdn.net/u013066244/article/details/71056834","tags":[]},{"title":"vagrant package 打包自己的box镜像","date":"2018-11-08T22:38:00.000Z","path":"post/299409888.html","text":"关于如何在win下使用Vagrant和Virtual Box创建一台CentOS7虚拟机我的博客中有教程介绍：https://wangzhuanglin.gitee.io/post/2370098709.html 搭建完毕后等虚拟机的细节都调整好后强烈建议打包成自己的镜像，以后需要在其他电脑安装虚拟机环境或者电脑的虚拟机出问题的时候可以直接一键还原，不然要重新搭建有点繁琐。 1、查看虚拟机名称去到虚拟机安装目录，执行命令： 1vboxmanage list vms 这里有可能提示：’vboxmanage’ 不是内部或外部命令，也不是可运行的程序或批处理文件。那是因为VirtualBox安装的时候没有将vboxmanage自动放入环境变量中，我们可以直接进入VirtualBox的安装目录执行这句命令，也就是VirtualBox.exe这个文件的同级目录 _default_1583637544209_19565 就是我本地的虚拟机名称，复制下这个名字，后面打包box镜像需要用到。 2、执行打包命令vagrant自带打包命令，需要去到你的vagrant目录下，也就是vagrantFile文件目录下执行 12$ vagrant package –-base _default_1583637544209_19565 –-output CentOS20180119.box vagrant package –-base [虚拟机名称] –-output [打包后的box名称] 3、部署回自己的box环境到上面第二步的时候已经打包完毕了，如果想在其他电脑部署自己的box很简单先把box文件和Vagrantfile文件放到需要部署的磁盘目录下。执行以下操作命令：1、将box安装到vagrant容器 1$ vagrant box add -name xuni CentOS20180119.box vagrant box add -name [虚拟机名称] [box放置的位置] 2、然后直接启动即可 1$ vagrant up","tags":[]},{"title":"Vagrant在win7/win10系统下搭建使用","date":"2018-11-08T21:32:00.000Z","path":"post/2370098709.html","text":"vagrant是什么？ vagrant是一个操作虚拟机的工具. 通过命令和配置文件来管理虚拟机,很快就能完成一套开发环境的部署,并可以打包传播,统一了开发环境,也解决了重复配置环境的麻烦. Vargant的好处1.统一开发环境。 一次配置打包，统一分发给团队成员，统一团队开发环境，解决诸如“编码问题”，“缺少模块”，“配置文件不同”带来的问题； 2.避免重复搭建开发环境。 新员工加入，不用浪费时间搭建开发环境，快速加入开发，减少时间成本的浪费； 3.多个相互隔离开发环境。 可以在不用box里跑不同的语言，或者编译安装同一语言不同版本，搭建多个相互隔离的开发环境，卸载清除时也很快捷轻松。 win7/win10系统下使用流程1、安装VirtualBox、vagrant两款软件 直接到官网下载安装即可官网如下： https://www.virtualbox.org https://www.vagrantup.com 官网范围速度比较慢，而且这两位软件不同版本可能会造成兼容问题，也就是有可能导致你的vagrant用起来出现一些莫名其妙的问题，所以最好是制定两款的版本安装。 win10版本为： VirtualBox-5.2.12-122591-Win.exe vagrant_2.2.7_x86_64.msi 2、下载一个box镜像文件安装后需要下载一个box镜像文件，也就是linux的镜像（其实也可以在vagrant add安装的时候直接指定官方的镜像名称就会自动下载安装，但鉴于国内下载官方的速度太慢了，所以强烈鉴于先用迅雷之类的工具加速下载下来再本地安装） 下载官网地址如下： https://app.vagrantup.com/boxes/search 如果是安装centos的话直接点击下面的链接直达： https://app.vagrantup.com/centos/boxes/7 3、将镜像加载到vagrant容器中特别注意的前置操作：必须将.vagrant.d和VirtualBox VMs虚拟机迁移出C盘，因为默认都是放在C盘的，占用空间非常大。.vagrant.d迁移方法：window下我的电脑右键属性环境变量添加：VAGRANT_HOME = D:.vagrant.d VirtualBox VMs虚拟机迁移方法：打开VirtualBox软件，选择”管理-&gt;全局设定”,修改默认虚拟机位置。如下图： 执行如下命令： 1 vagrant box add -name [虚拟机名称] [box放置的位置] centos/7是虚拟机名称 最后的box放置位置直接写你下载后返的根目录即可，如果没指定的话，默认会自己从官网下载 如：vagrant box add -name ‘centos/7’ [box放置的位置] 下面是我自己放置的位置习惯： 1$ vagrant box add xuni CentOS20200119.box 4、初始化虚拟机1$ vagrant init xuni vagrant init命令就是初始话命令xuni 是指box的名称（也就是第三步[虚拟机名称]那个位置） 5、启动虚拟机初始话之后，就可以开始启动虚拟机，运行如下命令： 1$ vagrant up 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152D:\\&gt;vagrant upBringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...&#x3D;&#x3D;&gt; default: Importing base box &#39;xuni&#39;...&#x3D;&#x3D;&gt; default: Matching MAC address for NAT networking...&#x3D;&#x3D;&gt; default: Setting the name of the VM: _default_1583637544209_19565Vagrant is currently configured to create VirtualBox synced folders withthe &#96;SharedFoldersEnableSymlinksCreate&#96; option enabled. If the Vagrantguest is not trusted, you may want to disable this option. For moreinformation on this option, please refer to the VirtualBox manual: https:&#x2F;&#x2F;www.virtualbox.org&#x2F;manual&#x2F;ch04.html#sharedfoldersThis option can be disabled globally with an environment variable: VAGRANT_DISABLE_VBOXSYMLINKCREATE&#x3D;1or on a per folder basis within the Vagrantfile: config.vm.synced_folder &#39;&#x2F;host&#x2F;path&#39;, &#39;&#x2F;guest&#x2F;path&#39;, SharedFoldersEnableSymlinksCreate: false&#x3D;&#x3D;&gt; default: Vagrant has detected a configuration issue which exposes a&#x3D;&#x3D;&gt; default: vulnerability with the installed version of VirtualBox. The&#x3D;&#x3D;&gt; default: current guest is configured to use an E1000 NIC type for a&#x3D;&#x3D;&gt; default: network adapter which is vulnerable in this version of VirtualBox.&#x3D;&#x3D;&gt; default: Ensure the guest is trusted to use this configuration or update&#x3D;&#x3D;&gt; default: the NIC type using one of the methods below:&#x3D;&#x3D;&gt; default:&#x3D;&#x3D;&gt; default: https:&#x2F;&#x2F;www.vagrantup.com&#x2F;docs&#x2F;virtualbox&#x2F;configuration.html#default-nic-type&#x3D;&#x3D;&gt; default: https:&#x2F;&#x2F;www.vagrantup.com&#x2F;docs&#x2F;virtualbox&#x2F;networking.html#virtualbox-nic-type&#x3D;&#x3D;&gt; default: Clearing any previously set network interfaces...&#x3D;&#x3D;&gt; default: Preparing network interfaces based on configuration... default: Adapter 1: nat default: Adapter 2: hostonly&#x3D;&#x3D;&gt; default: You are trying to forward to privileged ports (ports &lt;&#x3D; 1024). Most&#x3D;&#x3D;&gt; default: operating systems restrict this to only privileged process (typically&#x3D;&#x3D;&gt; default: processes running as an administrative user). This is a warning in case&#x3D;&#x3D;&gt; default: the port forwarding doesn&#39;t work. If any problems occur, please try a&#x3D;&#x3D;&gt; default: port higher than 1024.&#x3D;&#x3D;&gt; default: Forwarding ports... default: 22 (guest) &#x3D;&gt; 2222 (host) (adapter 1)&#x3D;&#x3D;&gt; default: Running &#39;pre-boot&#39; VM customizations...&#x3D;&#x3D;&gt; default: Booting VM...&#x3D;&#x3D;&gt; default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127.0.0.1:2222 default: SSH username: vagrant default: SSH auth method: password default: Warning: Connection reset. Retrying... default: Warning: Connection aborted. Retrying...&#x3D;&#x3D;&gt; default: Machine booted and ready!&#x3D;&#x3D;&gt; default: Checking for guest additions in VM...&#x3D;&#x3D;&gt; default: Configuring and enabling network interfaces...&#x3D;&#x3D;&gt; default: Mounting shared folders... default: &#x2F;vagrant &#x3D;&gt; D:&#x2F; 看到这段内容时说明你的虚拟机已经正常安装启动完毕了！ 6、连接虚拟机如果是使用官方基础镜像的话一开始是连不上的，需要先用ssh命令进入修改配置后才能连接修改配置如下1、修改sshd_config配置进入虚拟机中，登录的账号密码均为：vagrant进入文件夹/etc/ssh，修改配置文件sshd_configcd /etc/sshvi sshd_config 重启sshd.service服务 1systemctl restart sshd.service 本地使用Xshell连接虚拟机，运行命令如下： 1ssh 127.0.0.1 2200 在弹出的窗口，输入用户名和密码就进入了虚拟机。ssh表示连接的命令，127.0.0.1 2200可以从vagrant up的时候的输出命令中找到。 7、使用xshell工具连接虚拟机也可以直接用官网的ssh命令直接连接，不过在win用ssh命令连接后还是在cmd窗口，以后开发不太方便，最好是用xshell工具连接。 账号密码默认直接都是：vagrant 即可，（个人改成账号 root登录，密码还是vagrant） 到此就结束了，之后等镜像调整细节完毕后直接打包成自己的镜像，以后在其他电脑用或者本电脑虚拟机出问题的话，可以直接一键安装（相当于还原）具体打包自己box的方法我博客中也有教程介绍 http://tiance.club/post/299409888.html","tags":[]},{"title":"PHP动态模式和静态模式区别","date":"2018-08-05T16:26:00.000Z","path":"post/3986490219.html","text":"php-fpm的进程数可以根据设置分为动态和静态。 静态：直接开启指定数量的php-fpm进程，不再增加或者减少；动态：开始的时候开启一定数量php-fpm进程，当请求变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲进程数到一个下限。这两种不同的执行方式，可以根据服务器实际需求来进行调整。 这里先说一下涉及到这个的几个参数，他们分别是pm\\pm.max_children\\pm.start_servers\\pm.min_spare_servers和pm.max_spare_servers。 pm表示用哪种方式，有两个值可以选择，就是static静态或者dynamic动态。在老一些的版本中，dynamic又被称作apache-like。这个要注意看配置文件给出的说明了。 下面4个参数的意思分别为： pm.max_children静态方式下开启的php-fpm进程数量；pm.start_servers动态方式下的起始php-fpm进程数量；pm.min_spare_servers动态方式下的最小php-fpm进程数量；pm.max_spare_servers动态方式下的最大php-fpm进程数量。如果将dm设置为static，那么就只有pm.max_children这个参数生效。系统会开启设置的数量个php-fpm进程。 如果将dm设置为dynamic，那么pm.max_children参数会失效，后面3个参数生效。系统会在php-fpm运行开始的时候启动pm.start_servers个php-fpm进程，然后根据系统需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数。 那么，对于我们的服务器，选择哪种执行方式比较好呢？事实和Apache一样，我们运行的PHP程序在执行完成后，或多或少都会有内存泄露的问题。这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20到30M的原因。所以，动态方式因为会结束掉多余进程，可以回收释放一些内存，所以推荐在内存较少的服务器上使用。具体最大数量根据物理内存总大小除以20M得到。比如说512M的VPS，建议pm.max_spare_servers值设置为20。而至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5到10之间。 对比较大内存的服务器来说，设置为静态的话会提高效率。因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量可以根据物理内存总大小除以30M得到。比如说2GB内存的服务器，可以设置为50；4GB内存可以设置为100等。","tags":[]},{"title":"Centos防火墙命令","date":"2018-06-24T02:56:00.000Z","path":"post/3949464474.html","text":"centos7以上版本（firewalld）查看防火墙状态：systemctl status firewalld.service关闭防火墙命令：systemctl stop firewalld.service开启防火墙：systemctl start firewalld.service关闭开机自启动：systemctl disable firewalld.service开启开机启动：systemctl enable firewalld.service centos7以下版本（iptables）查看防火墙状态：service iptables status 停止防火墙：service iptables stop 启动防火墙：service iptables start 重启防火墙：service iptables restart 永久关闭防火墙：chkconfig iptables off 永久关闭后重启：chkconfig iptables on 2、开启80端口 vim /etc/sysconfig/iptables加入如下代码-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT保存退出后重启防火墙","tags":[]},{"title":"Markdown基本语法","date":"2018-06-04T07:26:00.000Z","path":"post/1563885333.html","text":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。相比WYSIWYG编辑器优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。示例： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题效果如下：这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个 ~~ 号包起来 示例： 1234**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 效果如下：![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 上传本地图片直接点击导航栏的图片标志，选择图片即可markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。markdown图床 六、超链接语法： 1![超链接名](超链接地址 \"超链接title\") title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1&lt;a href=\"超链接地址\" target=\"_blank\"&gt;超链接名&lt;/a&gt; 示例 1&lt;a href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\"&gt;简书&lt;/a&gt; 七、列表无序列表语法：无序列表用 - + * 任何一种都可以 123- 列表内容+ 列表内容* 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 1231. 列表内容2. 列表内容3. 列表内容 注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 效果如下： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 八、表格语法： 1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 效果如下： 表头 表头 表头 内容 内容 内容 内容 内容 内容 对齐方式我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。实例如下： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例：单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo \"这是一句非常牛逼的代码\"; &#125; fun();(```) 效果如下：单行代码 1create database hero; 代码块 1234function fun()&#123; echo \"这是一句非常牛逼的代码\";&#125;fun(); 借鉴于原文：https://www.jianshu.com/p/191d1e21f7ed/","tags":[]},{"title":"PHP常见数学函数及BC高精度数学函数用法示例","date":"2018-05-09T10:31:00.000Z","path":"post/968766046.html","text":"本文实例讲述了PHP常见数学函数及BC高精度数学函数用法。分享给大家供大家参考，具体如下： bcadd 任意精度数的相加 bcsub 任意精度数的减法 bcmul 乘法， bcdiv除法 bcmod 取余数。 （比%功能更强大） bcpow 幂函数运算 bcsqrt 平方根 sqrt 平方根运算 pow求幂 abs 求绝对值 pi 得到圆周率数值 三角函数sin cos tan asin acos atan（用弧度表达）deg2rad 角度转换成弧度rad2deg 弧度转换成角度 指数log 求自然对数， log10 求10位底的对数exp 以e为底的幂 各种数制转换base_convert 通用的任意数制转换bindec 二进制转换成十进制decbin 十进制转换成二进制dechex 十进制转换成十六进制decoct 十进制转换成八进制hexdec 十六进制转换成十进制octdec 八进制转换成十进制 BC高精确度函数用法示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?php /*************************************************************************************** *php BC高精确度函数库 *php bc math 包含了：相加，比较，相除，相减，求余，相乘，n次方，配置默认小数点数目，求平方 *这些函数在涉及到有关金钱的计算时比较有用 *************************************************************************************** *两个高精度数比较 *工作中遇到一种情况，0.00 ！= 0 *int bccomp ( string $left_operand , string $right_operand [, int $scale ] ) *$left=$right 返回 0 *$left&lt;$right 返回 -1 *$left&gt;$right 返回 1 *$scale 小数点位数 ***************************************************************************************/$a = 4.45;$b = 5.54;if(bccomp($a, $b, 2) == 0)&#123; echo \"完全相等\";&#125;/*************************************************************************************** *两个高精度数相加 *string bcadd ( string $left_operand , string $right_operand [, int $scale ] ) *$scale 返回的小数点个数 ***************************************************************************************/$a = 1.0321456;$b = 0.0123456;$c = bcadd($a, $b, 2);var_dump($c);/*************************************************************************************** *两个高精度数相减 *sstring bcsub ( string $left_operand , string $right_operand [, int $scale ] ) *$scale 返回的小数点个数 ***************************************************************************************/$a = 1.0321456;$b = 3.0123456;$c = bcsub($a, $b, 2);var_dump($c);/******************************************************** *两个高精度数求余/取模 *string bcmod ( string $left_operand , string $modulus ) *******************************************************/$a = 6;$b = 4;$c = bcmod($a, $b);var_dump($c);/*************************************************************************************** *两个高精度数相除 *string bcdiv ( string $left_operand , string $right_operand [, int $scale ] ) *$scale小数点位数默认为 0 ***************************************************************************************/ $a = 6; $b = 5; $c = bcdiv($a, $b, 3); var_dump($c);/*************************************************************************************** *两个高精度数相乘 *string bcmul ( string $left_operand , string $right_operand [, int $scale ] ) *$scale小数点位数默认为 0 ***************************************************************************************/$a = 3.1415926;$b = 2.4569874566;$c = bcmul($a, $b, 6);var_dump($c);/*************************************************************************************** *两个高精度数的次方值 *string bcpow ( string $left_operand , string $right_operand [, int $scale ] ) *$scale小数点位数默认为 0 ***************************************************************************************/$a = 3.1415926;$b = 2;$c = bcpow($a, $b, 3);var_dump($c);/************************************************** *求高精度数的平方根 *string bcsqrt ( string $operand [, int $scale ] ) *$scale小数点位数默认为 0 ***************************************************/$b = bcsqrt($a, 6);var_dump($b);/****************************** *设置bc函数的小数点位数 *bool bcscale ( int $scale ) *$scale小数点位数默认为 0 ******************************/bcscale(2);?&gt; 运行结果： 1234567string(4) \"1.04\"string(5) \"-1.98\"string(1) \"2\"string(5) \"1.200\"string(8) \"7.718853\"string(5) \"9.869\"string(8) \"1.772453\"","tags":[]},{"title":"Hexo | 博客文章链接优化之abbrlink","date":"2018-04-04T15:08:00.000Z","path":"post/4194944743.html","text":"前言hexo的默认永久链接是在_config.yml里的配置permalink: :year/:month/:day/:title/。这种默认配置有个很不能接受的缺点，文件名为中文，会导致url链接里面出现中文。这次我来介绍一个比较方便好用的解决方案hexo-abbrlink插件。 安装hexo-abbrlink插件1npm install hexo-abbrlink --save 然后在 Hexo 的根目录的配置文件_config.yml 中修改： 站点配置文件(_config.yml)里: 1234permalink: post&#x2F;:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 使用hexo g 会自动在你的文章中加上abbrlink: fbf5310d","tags":[]},{"title":"Hexo 集成 Gitalk 评论系统","date":"2018-04-04T14:34:00.000Z","path":"post/1180153653.html","text":"什么是 GitalkGitalk 利用了 GithubAPI 基于 GitHub Issue 和 Preact 开发的评论插件，官方网址： https://gitalk.github.io官方中文文档： https://github.com/gitalk/gitalk/blob/master/readme-cn.md Gitalk 特性1、使用 GitHub 登录2、支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]3、支持个人或组织4、无干扰模式（设置 distractionFreeMode 为 true 开启）5、快捷键提交评论 （cmd|ctrl + enter） 集成流程Hexo主题基本都继承Gitalk我们只需在在github上面注册对应的秘钥填入hexo主题的_config.yml配置即可。 *1、在GitHub上注册新应用，链接：https://github.com/settings/applications/new * 参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://wangzhuanglin.gitee.ioApplication description # 描述，随意Authorization callback URL：# 网站URL，https://wangzhuanglin.gitee.io 点击注册后，页面跳转如下，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可： 2、申请一个仓库做评论存储 需要记住的是仓库名，到时需要填入hexo的_config.yml配置中 3、打开对应hexo主题的_config.yml添加如下内容：gitalk: enable: true githubID: github帐号 # 例：asdfv1929 repo: 仓库名称 # 例：blog ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true","tags":[]},{"title":"linux压缩和解压缩命令","date":"2018-03-09T14:55:00.000Z","path":"post/3363811620.html","text":"tar 12解包：tar zxvf filename.tar 打包：tar czvf filename.tar dirname gz命令 123解压1：gunzip filename.gz 解压2：gzip -d filename.gz 压缩：gzip filename .tar.gz 和 .tgz 123解压：tar zxvf filename.tar.gz 压缩：tar zcvf filename.tar.gz dirname 压缩多个文件：tar zcvf filename.tar.gz dirname1 dirname2 dirname3..... bz2命令 123解压1：bzip2 -d filename.bz2 解压2：bunzip2 filename.bz2 压缩：bzip2 -z filename .tar.bz2 12解压：tar jxvf filename.tar.bz2 压缩：tar jcvf filename.tar.bz2 dirname bz命令 12解压1：bzip2 -d filename.bz 解压2：bunzip2 filename.bz .tar.bz 1解压：tar jxvf filename.tar.bz z命令 12解压：uncompress filename.z 压缩：compress filename .tar.z 12解压：tar zxvf filename.tar.z 压缩：tar zcvf filename.tar.z dirname zip命令 12解压：unzip filename.zip 压缩：zip -r filename.zip dirname","tags":[]},{"title":"在linux终端下快速删除输错的命令小技巧","date":"2018-03-06T05:32:00.000Z","path":"post/2329327795.html","text":"有时候在linux终端中执行某个命令时，往往会输错命令，想删除掉重敲可以按backspace键，但这样较慢，一种简便技巧是，按住esc键同时按backspace键会较快删除【esc+backspace】组合键。或者【ctrl+u】组合键 当然，直接回车更直接，但可能会产生一堆的错误提示。","tags":[]},{"title":"Linux对一个目录及其子目录所有文件添加权限","date":"2018-01-04T08:46:00.000Z","path":"post/1952161873.html","text":"chmod -R 修改成的权限 要修改哪个文件夹 1chmod -R 777 /home/linux","tags":[]},{"title":"PHP 单例模式","date":"2017-05-04T22:01:00.000Z","path":"post/1062235890.html","text":"单例模式也称单态，是23种设计模式中最简单的一种，从他的名字就可以知道他的核心思想，单例模式就是系统中只有一个这样的对象，对象只有一个，在Java或者C#中，单例模式一般有两种，分别是懒汉式、饿汉式，但是在PHP中常用的就是懒汉式，由于PHP是单线程的，懒汉式也不存在双重验证。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/** * Created by PhpStorm. * User: LYL * Date: 2015/4/21 * Time: 21:25 */ /**懒汉式 * Class Singleton */class Singleton&#123; //创建静态对象变量 private static $instance=null; public $age; //构造函数私有化，防止外部调用 private function __construct() &#123; &#125; //克隆函数私有化，防止外部克隆对象 private function __clone() &#123; &#125; //实例化对象变量方法，供外部调用 public static function getInstance() &#123; if(empty(self::$instance)) &#123; self::$instance=new Singleton(); &#125; return self::$instance; &#125;&#125; 测试代码： 1234567891011121314151617181920212223&lt;?php/** * Created by PhpStorm. * User: wuzz * Date: 2018/12/24 * Time: 4:10 PM */require_once \"../Singleton/Singleton.php\";$single1=Singleton::getInstance();$single1-&gt;age=22;$single2=Singleton::getInstance();$single2-&gt;age=24;echo \"变量1的age:&#123;$single1-&gt;age&#125;&lt;br/&gt;\";echo \"变量2的age:&#123;$single2-&gt;age&#125;&lt;br/&gt;\";结果两个echo输出都是：24 我们可以看到，变量single2的age都是24，说明变量single2是一个变量，类Singleton是单例的。 通过以上代码，我可以整理编写单例模式的三个步骤： 1.创建一个类静态变量 2.私有化构造函数与克隆函数，防止外部调用 3.提供一个外部可以调用的静态方法，实例化第一步创建的静态变量 很明显，单例模式的适用场景就是系统中的对象只需要一个就可以的时候，例如，Java中Spring的Bean工厂，PHP中的数据库连接等等，只要有这种需求就首先单例模式。","tags":[]},{"title":"PHP 状态模式","date":"2017-05-04T13:40:00.000Z","path":"post/1157327802.html","text":"1.概述在软件开发过程中，应用程序可能会根据不同的情况作出不同的处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到。然后使用if… ellse语句来做状态判断来进行不同情况的处理。但是对复杂状态的判断就显得“力不从心了”。随着增加新的状态或者修改一个状体（if else(或switch case)语句的增多或者修改）可能会引起很大的修改，而程序的可读性，扩展性也会变得很弱。维护也会很麻烦。那么我就考虑只修改自身状态的模式。 例子1：按钮来控制一个电梯的状态，一个电梯开们，关门，停，运行。每一种状态改变，都有可能要根据其他状态来更新处理。例如，开门状体，你不能在运行的时候开门，而是在电梯定下后才能开门。 例子2：我们给一部手机打电话，就可能出现这几种情况：用户开机，用户关机，用户欠费停机，用户消户等。 所以当我们拨打这个号码的时候：系统就要判断，该用户是否在开机且不忙状态，又或者是关机，欠费等状态。但不管是那种状态我们都应给出对应的处理操作。 2.问题对象如何在每一种状态下表现出不同的行为？ 3.解决方案状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。 4.适用性在下面的两种情况下均可使用State模式:if else(或switch case)语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 5.结构 6.模式的组成环境类（Context）: 定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。抽象状态类（State）: 定义一个接口以封装与Context的一个特定状态相关的行为。具体状态类（ConcreteState）: 每一子类实现一个与Context的一个状态相关的行为。 7.效果State模式有下面一些效果:状态模式的优点：1 、 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来: State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让 Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件if else语句或switch case语句。增加一个新的状态可能需要改变若干个操作, 这就使得维护变得复杂了。State模式避免了这个问题, 但可能会引入另一个问题, 因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些, 否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 i f或s w i t c h语句中, 而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。2、它使得状态转换显式化: 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值 3、 State对象可被共享 如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象。 状态模式的缺点: 1) 状态模式的使用必然会增加系统类和对象的个数。2) 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 8.实现我们用电梯的例子来说明： 简单地实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;?php abstract class ILift &#123; //电梯的四个状态 const OPENING_STATE = 1; //门敞状态 const CLOSING_STATE = 2; //门闭状态 const RUNNING_STATE = 3; //运行状态 const STOPPING_STATE = 4; //停止状态； //设置电梯的状态 public abstract function setState($state); //首先电梯门开启动作 public abstract function open(); //电梯门有开启，那当然也就有关闭了 public abstract function close(); //电梯要能上能下，跑起来 public abstract function run(); //电梯还要能停下来，停不下来那就扯淡了 public abstract function stop(); &#125; /** * 电梯的实现类 */ class Lift extends ILift &#123; private $state; public function setState($state) &#123; $this-&gt;state = $state; &#125; //电梯门关闭 public function close() &#123; //电梯在什么状态下才能关闭 switch($this-&gt;state)&#123; case ILift::OPENING_STATE: //如果是则可以关门，同时修改电梯状态 $this-&gt;setState(ILift::CLOSING_STATE); break; case ILift::CLOSING_STATE: //如果电梯就是关门状态，则什么都不做 //do nothing; return ; break; case ILift::RUNNING_STATE: //如果是正在运行，门本来就是关闭的，也说明都不做 //do nothing; return ; break; case ILift::STOPPING_STATE: //如果是停止状态，本也是关闭的，什么也不做 //do nothing; return ; break; &#125; echo 'Lift colse &lt;br&gt;'; &#125; //电梯门开启 public function open() &#123; //电梯在什么状态才能开启 switch($this-&gt;state)&#123; case ILift::OPENING_STATE: //如果已经在门敞状态，则什么都不做 //do nothing; return ; break; case ILift::CLOSING_STATE: //如是电梯时关闭状态，则可以开启 $this-&gt;setState(ILift::OPENING_STATE); break; case ILift::RUNNING_STATE: //正在运行状态，则不能开门，什么都不做 //do nothing; return ; break; case ILift::STOPPING_STATE: //停止状态，淡然要开门了 $this-&gt;setState(ILift::OPENING_STATE); break; &#125; echo 'Lift open &lt;br&gt;'; &#125; ///电梯开始跑起来 public function run() &#123; switch($this-&gt;state)&#123; case ILift::OPENING_STATE: //如果已经在门敞状态，则不你能运行，什么都不做 //do nothing; return ; break; case ILift::CLOSING_STATE: //如是电梯时关闭状态，则可以运行 $this-&gt;setState(ILift::RUNNING_STATE); break; case ILift::RUNNING_STATE: //正在运行状态，则什么都不做 //do nothing; return ; break; case ILift::STOPPING_STATE: //停止状态，可以运行 $this-&gt;setState(ILift::RUNNING_STATE); &#125; echo 'Lift run &lt;br&gt;'; &#125; //电梯停止 public function stop() &#123; switch($this-&gt;state)&#123; case ILift::OPENING_STATE: //如果已经在门敞状态，那肯定要先停下来的，什么都不做 //do nothing; return ; break; case ILift::CLOSING_STATE: //如是电梯时关闭状态，则当然可以停止了 $this-&gt;setState(ILift::CLOSING_STATE); break; case ILift::RUNNING_STATE: //正在运行状态，有运行当然那也就有停止了 $this-&gt;setState(ILift::CLOSING_STATE); break; case ILift::STOPPING_STATE: //停止状态，什么都不做 //do nothing; return ; break; &#125; echo 'Lift stop &lt;br&gt;'; &#125; &#125; $lift = new Lift(); //电梯的初始条件应该是停止状态 $lift-&gt;setState(ILift::STOPPING_STATE); //首先是电梯门开启，人进去 $lift-&gt;open(); //然后电梯门关闭 $lift-&gt;close(); //再然后，电梯跑起来，向上或者向下 $lift-&gt;run(); //最后到达目的地，电梯挺下来 $lift-&gt;stop(); 显然我们已经完成了我们的基本业务操作，但是，我们在程序中使用了大量的switch…case这样的判断（if…else也是一样),首先是程序的可阅读性很差，其次扩展非常不方便。一旦我们有新的状态加入的话，例如新加通电和断点状态。我们势必要在每个业务方法里边增加相应的case语句。也就是四个函数open，close，run，stop都需要修改相应case语句。 状态模式：把不同状态的操作分散到不同的状态对象里去完成。看看状态类的uml类图： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214&lt;?php /** * * 定义一个电梯的接口 */ abstract class LiftState&#123; //定义一个环境角色，也就是封装状态的变换引起的功能变化 protected $_context; public function setContext(Context $context)&#123; $this-&gt;_context = $context; &#125; //首先电梯门开启动作 public abstract function open(); //电梯门有开启，那当然也就有关闭了 public abstract function close(); //电梯要能上能下，跑起来 public abstract function run(); //电梯还要能停下来，停不下来那就扯淡了 public abstract function stop(); &#125; /** * 环境类:定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。 */ class Context &#123; //定义出所有的电梯状态 static $openningState = null; static $closeingState = null; static $runningState = null; static $stoppingState = null; public function __construct() &#123; self::$openningState = new OpenningState(); self::$closeingState = new ClosingState(); self::$runningState = new RunningState(); self::$stoppingState = new StoppingState(); &#125; //定一个当前电梯状态 private $_liftState; public function getLiftState() &#123; return $this-&gt;_liftState; &#125; public function setLiftState($liftState) &#123; $this-&gt;_liftState = $liftState; //把当前的环境通知到各个实现类中 $this-&gt;_liftState-&gt;setContext($this); &#125; public function open()&#123; $this-&gt;_liftState-&gt;open(); &#125; public function close()&#123; $this-&gt;_liftState-&gt;close(); &#125; public function run()&#123; $this-&gt;_liftState-&gt;run(); &#125; public function stop()&#123; $this-&gt;_liftState-&gt;stop(); &#125; &#125; /** * 在电梯门开启的状态下能做什么事情 */ class OpenningState extends LiftState &#123; /** * 开启当然可以关闭了，我就想测试一下电梯门开关功能 * */ public function close() &#123; //状态修改 $this-&gt;_context-&gt;setLiftState(Context::$closeingState); //动作委托为CloseState来执行 $this-&gt;_context-&gt;getLiftState()-&gt;close(); &#125; //打开电梯门 public function open() &#123; echo 'lift open...', '&lt;br/&gt;'; &#125; //门开着电梯就想跑，这电梯，吓死你！ public function run() &#123; //do nothing; &#125; //开门还不停止？ public function stop() &#123; //do nothing; &#125; &#125; /** * 电梯门关闭以后，电梯可以做哪些事情 */ class ClosingState extends LiftState &#123; //电梯门关闭，这是关闭状态要实现的动作 public function close() &#123; echo 'lift close...', '&lt;br/&gt;'; &#125; //电梯门关了再打开，逗你玩呢，那这个允许呀 public function open() &#123; $this-&gt;_context-&gt;setLiftState(Context::$openningState); //置为门敞状态 $this-&gt;_context-&gt;getLiftState()-&gt;open(); &#125; //电梯门关了就跑，这是再正常不过了 public function run() &#123; $this-&gt;_context-&gt;setLiftState(Context::$runningState); //设置为运行状态； $this-&gt;_context-&gt;getLiftState()-&gt;run(); &#125; //电梯门关着，我就不按楼层 public function stop() &#123; $this-&gt;_context-&gt;setLiftState(Context::$stoppingState); //设置为停止状态； $this-&gt;_context-&gt;getLiftState()-&gt;stop(); &#125; &#125; /** * 电梯在运行状态下能做哪些动作 */ class RunningState extends LiftState &#123; //电梯门关闭？这是肯定了 public function close() &#123; //do nothing &#125; //运行的时候开电梯门？你疯了！电梯不会给你开的 public function open() &#123; //do nothing &#125; //这是在运行状态下要实现的方法 public function run() &#123; echo 'lift run...', '&lt;br/&gt;'; &#125; //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 public function stop() &#123; $this-&gt;_context-&gt;setLiftState(Context::$stoppingState); //环境设置为停止状态； $this-&gt;_context-&gt;getLiftState()-&gt;stop(); &#125; &#125; /** * 在停止状态下能做什么事情 */ class StoppingState extends LiftState &#123; //停止状态关门？电梯门本来就是关着的！ public function close() &#123; //do nothing; &#125; //停止状态，开门，那是要的！ public function open() &#123; $this-&gt;_context-&gt;setLiftState(Context::$openningState); $this-&gt;_context-&gt;getLiftState()-&gt;open(); &#125; //停止状态再跑起来，正常的很 public function run() &#123; $this-&gt;_context-&gt;setLiftState(Context::$runningState); $this-&gt;_context-&gt;getLiftState()-&gt;run(); &#125; //停止状态是怎么发生的呢？当然是停止方法执行了 public function stop() &#123; echo 'lift stop...', '&lt;br/&gt;'; &#125; &#125; /** * 模拟电梯的动作 */ class Client &#123; public static function main() &#123; $context = new Context(); $context-&gt;setLiftState(new ClosingState()); $context-&gt;open(); $context-&gt;close(); $context-&gt;run(); $context-&gt;stop(); &#125; &#125; Client::main(); 参考文章：https://www.cnblogs.com/nnn123/p/6723729.html","tags":[]},{"title":"PHP 工厂模式","date":"2017-04-16T07:46:00.000Z","path":"post/2588474815.html","text":"一、什么是工厂模式？ 一个类通过本身的静态方法来，实例化一个类并返回一个实例对象； 二、工厂模式特点？ 类命名特点：nameFactory eg: class mysqlFactory{} 【这是为了规范，当然也去起其他任意名字】 静态方法名称：static public function factory($class_name){} 【静态方法是类与外界的接口， 返回的是一个对象】 三、优点？ 如果已经使用的类内部发生改变，哪不需要在所有的地方都改变，只需要在类工厂类里改变既可， 比如：连接数据库，可以使用mysql 、mysqli、pdo，根据不同参数配置使用不同的数据库操作类 四、应用场景做支付接口的时候，未来可能对应不同的支付网关：支付宝、财付通、网银在线等。方便未来扩展,设计成工厂模式。定一个专门生产网关接口的工厂，抽象出来,做成接口形式，让所有的子类都要实现它的接口。以后加一个支付方式，要使用哪一种支付方式，改变一下参数即可。 在为用户注册的时候，分为很多种角色的用户。比如注册用户，匿名用户、管理员用户等。完全使用可以使用工厂的思想来实现,代码也容易维护,为每种角色可以生成操作的类等等。 系统对接多个不同类型的数据库，mysql，oracle，sqlserver 五、具体示例代码1234567891011121314151617//构建接口定义interface mysql&#123; public function connect();&#125;//具体实现类class mysqli2 implements mysql&#123; public function connect()&#123; echo 'mysqli'; &#125;&#125;class pdo2 implements mysql&#123; public function connect()&#123; echo 'pdo'; &#125;&#125; 具体调用代码 12345678910public function testObserver()&#123; $factory=1; switch($factory)&#123; case 1:$class=new mysqli2();break; case 2:$class=new pdo2();break; default:throw new Exception('-1','查无此构建类'); &#125; $class-&gt;connect();&#125; 参考文章：https://www.cnblogs.com/jxkshu/p/9473710.html","tags":[]},{"title":"PHP 建造者模式","date":"2017-04-16T07:25:00.000Z","path":"post/1575233550.html","text":"建造者模式和抽象工厂模式很像，总体上，建造者模式仅仅只比抽象工厂模式多了一个“导演类”的角色。与抽象工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类 —— 导演类。也就是说，抽像工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将完整建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。 角色指挥者角色（Director）:构建一个使用Builder接口的对象抽象建造者角色（Builder）：为创建一个Product对象的各个部件指定的抽象接口具体建造者角色（ConcreteBuilder）：实现Builder接口，构造和装配各个部件产品角色（Product） 1、基础抽象类（指挥者）定义一个基础抽象类，规定所有实现者都必须实现规定的方法，比如想实现车辆的建造，首先必须规定好车辆有哪些零件，所有造车厂商都必须实现所有规定好的零件。 1234567891011121314151617181920212223242526272829303132333435abstract class carModel&#123; //这里存储所有组装车需要的零件 public $spareParts = array(); //车的名字 public $carName = \"\"; //增加轮子部件 public abstract function addLunzi($xinghao); //增加外壳部件 public abstract function addWaike($xinghao); //增加发动机部件 public abstract function addFadongji($xinghao); //获取车，并给车取名字 final public function getCar($carName) &#123; if ($this-&gt;spareParts) &#123; $this-&gt;carName = $carName; //$k 代表部件名字 //$v 代表型号 foreach ($this-&gt;spareParts as $k =&gt; $v) &#123; $actionName = \"add\" . $k; $this-&gt;$actionName($v); &#125; &#125; else &#123; throw new Exception(\"没有汽车部件\"); &#125; &#125;&#125; 2、具体实现类（产品类）即实现对应车辆根据对应的统一基础抽象类去统一实现， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//定义具体的产品class bmwCarModel extends carModel&#123; public $spareParts = array(); public $carName = \"\"; public function addLunzi($xinghao) &#123; echo \"宝马\" . $this-&gt;carName . \"的轮子，型号是\" . $xinghao . \"\\n\"; &#125; public function addWaike($xinghao) &#123; echo \"宝马\" . $this-&gt;carName . \"的外壳，型号是\" . $xinghao . \"\\n\"; &#125; public function addFadongji($xinghao) &#123; echo \"宝马\" . $this-&gt;carName . \"的发动机,型号是 \" . $xinghao . \"\\n\"; &#125;&#125;//定义具体的产品class benziCarModel extends carModel&#123; public $spareParts = array(); public $carName = \"\"; public function addLunzi($xinghao) &#123; echo \"奔驰\" . $this-&gt;carName . \"的轮子，型号是\" . $xinghao . \"\\n\"; &#125; public function addWaike($xinghao) &#123; echo \"奔驰\" . $this-&gt;carName . \"的外壳，型号是\" . $xinghao . \"\\n\"; &#125; public function addFadongji($xinghao) &#123; echo \"奔驰\" . $this-&gt;carName . \"的发动机,型号是 \" . $xinghao . \"\\n\"; &#125;&#125; 3、抽象建造者规范产品的组建，一般是由子类实现 123456//定义建造者abstract class carBuilder&#123; public abstract function setSpareParts($partsName, $xinghao); public abstract function getCarModel($name);&#125; 4、具体建造者实现抽象类定义的所有方法，并且返回一个组件好的对象。 12345678910111213141516171819202122232425262728293031323334353637383940class bmwBuilder extends carBuilder&#123; private $bmwModel; public function __construct() &#123; $this-&gt;bmwModel = new bmwCarModel(); &#125; public function setSpareParts($partsName, $xinghao) &#123; $this-&gt;bmwModel-&gt;spareParts[$partsName] = $xinghao; &#125; public function getCarModel($name) &#123; $this-&gt;bmwModel-&gt;getCar($name); &#125;&#125;class benziBuilder extends carBuilder&#123; private $benziModel; public function __construct() &#123; $this-&gt;benziModel = new benziCarModel(); &#125; public function setSpareParts($partsName, $xinghao) &#123; $this-&gt;bmwModel-&gt;spareParts[$partsName] = $xinghao; &#125; public function getCarModel($name) &#123; $this-&gt;bmwModel-&gt;getCar($name); &#125;&#125; 具体调用代码： 1234567891011121314151617181920 public function testObserver()&#123; //模拟客户端调用//创建一辆宝马车，取名字为宝马x1 $bmwBuilder = new bmwBuilder(); $bmwBuilder-&gt;setSpareParts('Lunzi', '牛逼轮子1号'); $bmwBuilder-&gt;setSpareParts('Waike', '牛逼外壳1号'); $bmwBuilder-&gt;setSpareParts('Fadongji', '牛逼发动机1号'); $bmwBuilder-&gt;getCarModel(\"宝马x1\"); $bmwBuilder-&gt;getCarModel(\"宝马x1\"); //连续创建两个宝马x1//再创建一个宝马 没有外壳 取名为 宝马s5 $bmwBuilder = new bmwBuilder(); $bmwBuilder-&gt;setSpareParts('Lunzi', '牛逼轮子2号'); $bmwBuilder-&gt;setSpareParts('Fadongji', '牛逼发动机2号'); $bmwBuilder-&gt;getCarModel(\"宝马s5\"); $bmwBuilder-&gt;getCarModel(\"宝马s5\"); //连续创建两个宝马x1 &#125; 总结优点1、客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。用户使用不同的具体建造者即可得到不同的产品对象，新增具体建造者符合“开闭原则”。2、可以更精细地控制产品的创建过程。 缺点1、不适用于内部变化复杂的产品。如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 总结建造者模式，适用于创建有复杂内部结构的对象，对象属性之间相互依赖，且又可能要使用到一些其他不易得到的对象。 参考链接：https://www.cnblogs.com/mingmingcome/p/9637343.html","tags":[]},{"title":"PHP abstract 抽象类定义与用法示例","date":"2017-04-16T03:23:00.000Z","path":"post/137974761.html","text":"PHP抽象类应用要点：1.定义一些方法，子类必须完全实现这个抽象中所有的方法2.不能从抽象类创建对象，它的意义在于被扩展3.抽象类通常具有抽象方法，方法中没有大括号 PHP抽象类应用重点：1.抽象方法不必实现具体的功能，由子类来完成2.在子类实现抽象类的方法时，其子类的可见性必须大于或等于抽象方法的定义3.抽象类的方法可以有参数，也可以为空4.如果抽象方法有参数，那么子类的实现也必须有相同的参数个数 示例： 123456789101112131415161718192021//作用：抽象类不实现具体方法，具体方法由子类完成。//定义抽象类 abstractabstract class A&#123; //abstract 定义抽象类的方法，这里没有花括号。子类必须实现这个抽象方法。 abstract public function say(); //抽象类可以有参数 abstract public function eat($argument); //在抽象类中可以定义普通的方法。 public function run()&#123; echo '这是run方法'; &#125;&#125;class B extends A&#123; //子类必须实现父类的抽象方法，否则是致命的错误。 public function say()&#123; echo '这是say方法,实现了抽象方法'; &#125; public function eat($argument)&#123; echo '抽象类可以有参数 ，输出参数：'.$argument; &#125;&#125; 具体调用代码示例： 123456$b =new B;$b-&gt;say();echo '&lt;br&gt;';$b-&gt;eat('apple');echo '&lt;br&gt;';$b-&gt;run(); 原文链接：https://www.jb51.net/article/141084.html","tags":[]},{"title":"PHP 注册树模式","date":"2017-04-16T02:58:00.000Z","path":"post/2975869525.html","text":"注册树模式介绍概念：将已经创建好的对象注册到某个容器里，在需要使用的时候直接从容器获取即可。优势：解决全局共享和交换对象，将对象注册到全局的树上任何地方直接去访问。 具体注册树和被注册类代码示例12345678910111213141516171819202122232425262728293031323334//注册树class Register&#123; protected static $objects; public static function set($alias, $object) &#123; self::$objects[$alias] = $object; &#125; public static function get($alias) &#123; return self::$objects[$alias]; &#125; public static function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125;/** * Class demo 演示类 */class demo&#123; /* * 测试方法 */ public function test() &#123; echo '看这里看这里&lt;br&gt;&lt;br&gt;'; &#125;&#125; 具体示例调用代码12345public function testObserver()&#123; $action=(new Register()); $action::set(\"demo\",new demo()); $action::get(\"demo\")-&gt;test();&#125;","tags":[]},{"title":"PHP 观察者模式","date":"2017-04-16T02:45:00.000Z","path":"post/960570916.html","text":"12345/** * 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。 * 比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 * 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 */ 一般来说有两个接口类，用以框定观察者模式： 一个被观察者接口类（一般申明有三个必须方法：1.添加观察者对象的方法，2.删除观察者对象的方法 ，3.通知观察者进行 相应执行的方法） 一个观察者接口类（一般只有一个必须方法，就是执行） 具体代码实现范例1、标题添加观察者接口和被观察者接口12345678910// 被观察者接口interface Subject&#123; public function register(Observer $observer); //添加（注册）观察者对象 public function detach(Observer $observer); //删除观察者对象 public function notify(); //通知观察者执行相应功能&#125;// 观察者接口interface Observer&#123; public function watch(); //观察者要执行的方法&#125; 2、被观察者继承类123456789101112131415161718192021222324252627282930313233// 被观察者继承类class Action implements Subject&#123; public $_observers=array(); //用于存储观察者对象 //用于添加（注册）观察者对象 public function register(Observer $observer)&#123; $this-&gt;_observers[]=$observer; &#125; //用于删除观察者对象 public function detach(Observer $observer)&#123; $index = array_search($observer, $this-&gt;_observers); if ($index === FALSE || ! array_key_exists($index, $this-&gt;_observers)) &#123; return FALSE; &#125; unset($this-&gt;_observers[$index]); return TRUE; &#125; //通知各观察者 public function notify()&#123; //****重点，其实就是循环中执行各观察这对象的watch方法，不同功能方法内容不同但方法名相同 foreach ($this-&gt;_observers as $observer) &#123; $observer-&gt;watch(); &#125; &#125;&#125; 3、观察者继承类这也是具体的业务逻辑实现代码，如注册完之后给用户发邮件短信之类的。 12345678910111213141516171819// cat观察者继承类class Cat implements Observer&#123; public function watch()&#123; echo \"Cat watches TV&lt;hr/&gt;\"; &#125;&#125;//dog观察者继承类class Dog implements Observer&#123; public function watch()&#123; echo \"Dog watches TV&lt;hr/&gt;\"; &#125;&#125;//people观察者继承类class People implements Observer&#123; public function watch()&#123; echo \"People watches TV&lt;hr/&gt;\"; &#125;&#125; 4、具体实例化调用代码123456public function testObserver()&#123; $action=(new Action()); $action-&gt;register(new Cat()); $action-&gt;register(new Dog()); $action-&gt;notify();&#125; 具体的应用场景如用户注册完后给用户发邮件和短信，这里可以通过观察者模式给通过将邮件和短信这两个观察者注册到被观察者中,判断注册完毕后直接调用notify() 方法直接通知各观察者。","tags":[]},{"title":"php定义方法属性类比普通传值的优点","date":"2017-04-15T06:11:00.000Z","path":"post/2520600556.html","text":"普通传值：是指直接将参数从一个方法传到另一个方法，最简单暴力的方式。方法属性类：将需要传递的所有值以方法属性类的方式定义出来，需要用时直接取出即可。 两者的代码实现方式1、普通传值方式1234567public function testDetail()&#123; $this-&gt;returnDetail('小李',10);&#125;private function returnDetail($name,$age)&#123; print_r([$name,$age]);exit;&#125; 2、方法属性类方式1234567891011public function testDetail()&#123; $data=(new HumanDetail()); $data-&gt;setName('小李'); $data-&gt;setAge(10); $this-&gt;returnDetail($data);&#125;private function returnDetail(HumanDetail $data)&#123; print_r([$data-&gt;getName(),$data-&gt;getAge()]);exit;&#125; HumanDreail类文件 从上面两者的实现代码可以看出普通传值方式简单简洁，方法属性类传值代码实现相对繁琐，还要多写一个类文件。既然这样的话为什么还要有方法属性类传值的方式呢？ 试想一下，当参数还少的时候没什么问题，但是当参数多的时候，这样传递代码很难看，也有人说可以直接把所有参数放到一个数组里面，然后直接传递那个数组参数即可，但是这里又有一个问题，就是你传递的数组里面有什么值其他人是无法一眼看出的，而且数组也可以传递所需参数外的其他参数，这样很不利于其他人维护。 方法属性类方式比普通传值的优点例如下面的案例： 1、普通传值1234567891011121314151617181920212223public function testDetail()&#123; $name='小李'; $age=10; $sex='男'; $type=1; $a='a'; $b='b'; $c='c'; $d='d'; $e='e'; $f='f'; $g='g'; $this-&gt;returnDetailA($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g); $this-&gt;returnDetailB($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g);&#125;private function returnDetailA($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g)&#123; print_r([$name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g]);&#125;private function returnDetailB($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g)&#123; print_r([$name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g]);exit;&#125; 2、方法属性类方式1234567891011121314151617181920212223242526public function testDetail()&#123; $data=(new HumanDetail()); $data-&gt;setName('小李'); $data-&gt;setAge(10); $data-&gt;setSex('男'); $data-&gt;setType(1); $data-&gt;setA('a'); $data-&gt;setB('b'); $data-&gt;setC('c'); $data-&gt;setD('d'); $data-&gt;setE('e'); $data-&gt;setF('f'); $this-&gt;returnDetailA($data); $this-&gt;returnDetailB($data);&#125;private function returnDetailA(HumanDetail $data)&#123; print_r([$data-&gt;getName(),$data-&gt;getAge(),$data-&gt;getSex(),$data-&gt;getA(),$data-&gt;getB(),$data-&gt;getC(), $data-&gt;getD(),$data-&gt;getE(),$data-&gt;getF()]);&#125;private function returnDetailB(HumanDetail $data)&#123; print_r([$data-&gt;getName(),$data-&gt;getAge(),$data-&gt;getSex(),$data-&gt;getA(),$data-&gt;getB(),$data-&gt;getC(), $data-&gt;getD(),$data-&gt;getE(),$data-&gt;getF()]);exit;&#125; HumanDreail类文件 并且上面的方法属性类传值方式还可以进一步优化优化如下：HumanDreail类文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace app\\components;class HumanDetail&#123; private $name=''; private $age=0; private $sex=''; private $type=0; private $a=''; private $b=''; private $c=''; private $d=''; private $e=''; private $f=''; public function __call($method,$args) &#123; $perfix=strtolower(substr($method,0,3)); $property=strtolower(substr($method,3)); if(empty($perfix) || empty($property)) return; if($perfix==\"get\" &amp;&amp; isset($this-&gt;$property)) return $this-&gt;$property; if($perfix==\"set\")$this-&gt;$property=$args[0];// if($perfix==\"set\")&#123; //开启强类型判断，对于php这种弱类型语言来说开启后对线上稳定会造成隐患// if(gettype($this-&gt;$property) == gettype($args[0]) )&#123;// $this-&gt;$property=$args[0];// &#125;else&#123;// throw new \\BaseComponents\\base\\Exception(['-1',$property.\" is wrong type, &#123;$property&#125; is \".gettype// ($this-&gt;$property).\" and args is \".gettype($args[0])]);// &#125;// &#125; &#125;&#125; 从上面可以看出，当传参参数变多了且当有多个接收方的时候，代码可维护性就变高了，接收方只需要从对应的类文件中需要自己需要的参数即可，不用这样多参数的传递，而且这还只是一层传递方式而已，如果是多层传递的话，那代码看上去就相对冗余难以维护。 总结：两者的优缺点普通传值优点：1、传值参数少，业务场景简单时，简洁明了。缺点：1、传值参数多，业务场景复杂时，代码可读性差，拓展性差。2、传递层次多时，代码可读性和拓展性差的缺点会更加明显。 方法属性类优点：1、传值参数多，业务场景复杂时，代码可读性高，便于团队开发，拓展性强。2、传递层次多时，代码可读性和拓展性强的优势会更加明显。缺点：1、传值参数少，业务场景简单时，代码量相对于普通传值方式更多。 一般来说一个业务的未来变化情况是可以预测到的，正确的选择对应的传值方式，有利于代码的可维护性和拓展性，更加有利于代码的健壮性。","tags":[]},{"title":"php 接口类与抽象类的实际作用","date":"2017-04-14T16:29:00.000Z","path":"post/4065656781.html","text":"实际作用总结:1、定义规范，方便大型项目多人开发。当有很多人一起开发一个项目时，可能都会去调用别人写的一些类，那你就会问，我怎么知道他的某个功能的实现方法是怎么命名的呢，这个时候php接口类就起到作用了，当我们定义了一个接口类时，它里面的方式是下面的子类必须实现的。 1.php 接口类:interface其实他们的作用很简单，当有很多人一起开发一个项目时，可能都会去调用别人写的一些类，那你就会问，我怎么知道他的某个功能的实现方法是怎么命名的呢，这个时候php接口类就起到作用了，当我们定义了一个接口类时，它里面的方式是下面的子类必须实现的，比如 : 代码如下: 123456interface Shop&#123; public function buy($gid); public function sell($gid); public function view($gid);&#125; 我声明一个shop接口类，定义了三个方法：买(buy),卖(sell),看(view),那么继承此类的所有子类都必须实现这3个方法少一个都不行，如果子类没有实现这些话，就无法运行。实际上接口类说白了，就是一个类的模板，一个类的规定，如果你属于这类，你就必须遵循我的规定，少一个都不行，但是具体你怎么去做，我不管，那是你的事，如：代码如下: 123456789101112131415class BaseShop implements Shop&#123; public function buy($gid) &#123; echo('你购买了ID为 :'.$gid.'的商品'); &#125; public function sell($gid) &#123; echo('你卖了ID为 :'.$gid.'的商品'); &#125; public function view($gid) &#123; echo('你查看了ID为 :'.$gid.'的商品'); &#125;&#125; 你想想，在一个多人合作的大项目里面，有了接口类是多么的方便，这样你就不用去问别人，你的某某功能的方法名是什么了，当然如果你们喜欢这样我也没有办法。结论 ： 接口类就是一个类的领导者，指明方向，子类必须完成它指定方法。 2.php 抽象类 : abstract其实抽象类和接口类有一部分很像，记得在哪里看见这样一句话，抽象类就把类像的部分抽出来，这句看上去很搞笑，其实它说出了抽象类的真理，抽象类的作用是，当你发现你的很多类里面用很多方法你不断的在重复写，那你就可以考虑使用抽象类了，你可能会说“我不是可以重写一个类每个公共类我个实例化一个这个公共类，调用相同的方法就可以了”，这里是可以，实际上抽象类做的工作也就是这个，不过他省去了你实例化的这个步骤，让你就像直接调用本类方法一样方便，而且你还可以重载这个方法。如：代码如下: 12345678910111213141516171819202122232425262728abstract class BaseShop&#123; public function buy($gid) &#123; echo('你购买了ID为 :'.$gid.'的商品'); &#125; public function sell($gid) &#123; echo('你卖了ID为 :'.$gid.'的商品'); &#125; public function view($gid) &#123; echo('你查看了ID为 :'.$gid.'的商品'); &#125;&#125; class BallShop extends BaseShop&#123; var $itme_id = null; public function __construct() &#123; $this-&gt;itme_id = 2314; &#125; public function open() &#123; $this-&gt;sell($this-&gt;itme_id); &#125;&#125; 这里是一个例子，想上面一样我定义了一个商店类，抽出了它所有像的部分，买(buy),卖(sell),看(view),并且抽象类里都实现了这些方法，那么继承它的子类就自动获得了这些方法，子类就做它自己独特的东西，介绍代码的重复，提高复用性。结论： 抽象类就是一个类的服务提供商，拥有众多服务，你不用必须用，当需要的时候你来用就可以，如果你觉得不提供服务不满意，你还可以自己来做。","tags":[]},{"title":"php中的implements 使用详解","date":"2017-04-14T16:22:00.000Z","path":"post/3630165851.html","text":"php类中接口的应用关键字是interface、implements了，接口是一种成员属性全部为抽象或常量的特殊抽象类,implements主要是对类名，类所拥有的方法，以及所传参数起约束和规范做用，有点像 abstract 抽象类。 类中接口的应用1.关键字：interface 2.关键字：implements 接口的介绍与规则接口：一种成员属性全部为抽象或常量的特殊抽象类。 规则： 1.类中全部为抽象方法。2.抽象方法前不用加abstract。3.接口抽象方法属性为public。4.成员属性必须为常量。 格式代码如下: 12345interface demo &#123; const NAME = \"常量对象属性\"; function myfun1(); //抽象方法 function myfun2(); //抽象方法,不用具体写入逻辑&#125; 一，接口的定义和调用123456789101112131415161718&lt;?phpinterface Cinema&#123; const film = '加勒比海盗'; public function show();&#125;class Order implements Cinema&#123; public function show() &#123; echo \"影院 接口开放了&lt;br&gt;\"; &#125;&#125;$face = new Order();echo $face-&gt;show(); echo Cinema::film; 说明：上面的例子要注意一点，接口的方法名是show，继承接口的类中必须有show这个方法，不然就会报错。也就是说接口的方法是假的，真正起作用的是在继承的类中的方法，这里接口和php的抽象类是不是有点像了? 二，对参数约束比较严1234567891011121314151617181920&lt;?phpinterface Cinema&#123; public function show(Order $show,$num);&#125;// 显示正常class Order implements Cinema&#123; public $number='0011排'; public function show(Order $show,$num) &#123; echo $show-&gt;number.$num; &#125;&#125;$face= new Order();$face-&gt;show(new Order,$num='3人');//输出 0011排3人 说明：上面的这个例子继承接口类中，调用接口的方法时，所传参数要和接口中的参数名要一至。不然就会报错。 三，接口间的继承和调用接口传递参数123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinterface Cinema&#123; public function show();&#125;interface Cinema1 extends Cinema&#123; public function show1(Order1 $object,$num);&#125;class Order implements Cinema1&#123; public function show() &#123; echo \"准备就绪&lt;br&gt;\"; &#125; public function show1(Order1 $object,$num) //注意:show1(Order1 $object,$num)中的Order1必须根继承类的名子要一样class Order1。如果不一样，会报fatal错误 &#123; //var_dump($object); echo $object-&gt;number.\"$num&lt;br&gt;\"; &#125;&#125;class Order1&#123; public $number=\"0012排\"; function fun()&#123; echo ' ================='; &#125;&#125;$show = new Order1;$show-&gt;fun(); $test = new Order();$test-&gt;show(); $test-&gt;show1($show,$num='6人');// 输出 ===============准备就绪0012排6人 说明：上面的例子可以看到，接口Cinemal1继承了接口Cinemal，类Order继承了接口Cinemal1。不知道你发现没有，class类Order当中包括有二个方法，一个是show，一个show1，并且一个也不能少，如果少一个，报fatal错误。show1(Order1 $object,$num)中的Order1必须根继承类的名子要一样class Order1。如果不一样，也会报fatal错误。那如果一个接口被多个类继承，并且类名又不一样，怎么办呢？那就要用self了，下面会提到：(这是官网手册的一个示例,鉴于类名的Sting与关键词冲突，我这里改成了Strings,大家可自行更改，不冲突即可)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinterface Comparable&#123; function compare(self $compare);&#125;class Strings implements Comparable&#123; private $string; function __construct($string) &#123; $this-&gt;string = $string; &#125; function compare(self $compare) &#123; return $this-&gt;string == $compare-&gt;string; &#125;&#125;class Integer implements Comparable&#123; private $integer; function __construct($int) &#123; $this-&gt;integer = $int; &#125; function compare(self $compare) &#123; return $this-&gt;integer == $compare-&gt;integer; &#125;&#125;$first_int = new Integer(999);$second_int = new Integer(999);$first_string = new Strings(\"慕容博\");$second_string = new Strings(\"慕容复\");var_dump($first_int-&gt;compare($second_int)); // bool(true)var_dump($first_string-&gt;compare($second_string)); // bool(false) 按照官网手册的意思：可以使用“self”强制对象暗示实现类的方法，但是，我们发现无论是PHP5+那个版本，都报了fatal error: 大致意思是继承类和接口方法变量兼容问题。 正确做法：去掉 self 即可或者把self 替换成 接口的Comparable名。如：function compare(Comparable $compare) 四，一个接口多个继承123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinterface demo &#123; const NAME = \"电影名称\"; function fun1(); function fun2();&#125;interface demo2 &#123; function fun3(); function fun4();&#125;interface demo3 &#123; const TEST = \"这里是测试Test\"; function fun5();&#125;class MyDemo implements demo, demo2 &#123; function fun1() &#123; echo \"你好\"; &#125; function fun2() &#123; echo \"----------\"; &#125; function fun3() &#123; echo \"我也好&lt;br /&gt;\"; &#125; function fun4() &#123; echo \"大家都好&lt;br /&gt;\"; &#125;&#125;class YourDemo extends MyDemo implements demo3 &#123; function fun5() &#123; echo \"继承类后引用接口\"; &#125;&#125;$p = new YourDemo;$p-&gt;fun1();$p-&gt;fun2();$p-&gt;fun3();$p-&gt;fun4();$p-&gt;fun5(); 以上输出 123你好----------我也好大家都好继承类后引用接口 上面的例子中我们可以看到接口都使用关键字 interface 来定义，并使用关键字 implements 来实现接口中的方法，再举个例子： 12345678910111213141516171819202122232425262728&lt;?php//定义接口interface User&#123; function getDiscount(); function getUserType();&#125;class VipUser implements User&#123; //VIP用户 接口实现 private $discount = 0.8; // VIP 用户折扣系数 function getDiscount() &#123; return $this-&gt;discount; &#125; function getUserType() &#123; return \"VIP用户\"; &#125;&#125;class Goods&#123; var $price = 88; var $vc; function run(User $vc)&#123; //定义 User 接口类型参数，这时并不知道是什么用户 $this-&gt;vc = $vc; $discount = $this-&gt;vc-&gt;getDiscount(); $usertype = $this-&gt;vc-&gt;getUserType(); echo $usertype.\"商品价格：\".$this-&gt;price*$discount; &#125;&#125;$display = new Goods();$display -&gt;run(new VipUser); //VIP用户商品价格：70.4 这个例子演示了一个 PHP 接口的简单应用。该例子中，User 接口实现用户的折扣，而在 VipUser 类里面实现了具体的折扣系数。最后商品类 Goods 根据 User 接口来实现不同的用户报价. 最后总结下： 抽象类和接口的区别 接口是特殊的抽象类，也可以看做是一个模型的规范。接口与抽象类大致区别如下： 1.一个子类如果 implements 一个接口，就必须实现接口中的所有方法（不管是否需要）；如果是继承一个抽象类，只需要实现需要的方法即可。 2.如果一个接口中定义的方法名改变了，那么所有实现此接口的子类需要同步更新方法名；而抽象类中如果方法名改变了，其子类对应的方法名将不受影响，只是变成了一个新的方法而已（相对老的方法实现）。 3.抽象类只能单继承，当一个子类需要实现的功能需要继承自多个父类时，就必须使用接口。","tags":[]},{"title":"linux安装php扩展大全","date":"2016-04-07T23:04:00.000Z","path":"post/784803616.html","text":"centos7安装php扩展大全&nbsp;&nbsp;&nbsp;有一个小想法，整理一篇linux下安装php拓展大全文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的拓展安装后就顺便更新到这篇博客文章。 1、Yaconf12345git clone https://github.com/laruence/yaconf &amp;&amp; \\cd yaconf/ &amp;&amp; \\phpize &amp;&amp; \\./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; \\make &amp;&amp; make install 12345vim /usr/local/php/etc/php.ini[Yaconf]extension=yaconf.so #扩展引用yaconf.directory=/home/www/conf #conf文件所在目录yaconf.check_delay=0 #心跳检查时间，若为0则不检查，但如果有修改，需重启PHP 12345读取值：echo Yaconf::get(\"web_env.MYSQL_ETC1_MASTER_HOST\"); //test是配置文件名字判断是否有该项设置echo Yaconf::has(\"web_env.MYSQL_ETC1_MASTER_HOST\"); //test是配置文件名字 2、xdebug123456wget http://xdebug.org/files/xdebug-2.8.1.tgz &amp;&amp; \\tar zxvf xdebug-2.8.1.tgz &amp;&amp; \\cd xdebug-2.8.1 &amp;&amp; \\phpize &amp;&amp; \\./configure --enable-xdebug --with-php-config=/usr/local/php/bin/php-config &amp;&amp; \\make &amp;&amp; make install 12345678910[Xdebug]zend_extension=xdebug.so xdebug.idekey = PHPSTROMxdebug.default_enable = 1 xdebug.remote_connect_back = 1 xdebug.remote_port = 9000 xdebug.remote_enable = 1 xdebug.remote_autostart = 1 xdebug.remote_handler=\"dbgp\"xdebug.remote_host=192.168.33.10 3、protobuf12345678wget https://github.com/allegro/php-protobuf/archive/master.zip &amp;&amp; \\unzip master.zip &amp;&amp; \\cd php-protobuf-master/ &amp;&amp; \\phpize &amp;&amp; \\./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; \\make &amp;&amp; make install然后在php.ini里面加一下extension = protobuf.so，再重启php 4、mongodb1234567wget http://pecl.php.net/get/mongodb-1.7.4.tgz &amp;&amp; \\tar -zxvf mongodb-1.7.4.tgz &amp;&amp; \\cd mongodb-1.7.4/ &amp;&amp; \\phpize &amp;&amp; \\./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; make &amp;&amp; make install &amp;&amp; \\然后在php.ini里面加一下extension = mongodb.so，再重启php 5、swoole123456wget https://github.com/swoole/swoole-src/archive/v4.4.16.tar.gz &amp;&amp; \\tar zxvf v4.4.16.tar.gz &amp;&amp; \\cd swoole-src-4.4.16 &amp;&amp; \\phpize &amp;&amp; \\./configure --enable-openssl --enable-http2 --with-php-config=/usr/local/php/bin/php-config &amp;&amp; \\make &amp;&amp; make install 123[swoole]extension=swooleswoole.use_shortname = Off 6、xlswriter1234567wget https://pecl.php.net/get/xlswriter-1.3.5.tgz &amp;&amp; \\tar zxvf xlswriter-1.3.5.tgz &amp;&amp; \\cd xlswriter-1.3.5 &amp;&amp; \\phpize &amp;&amp; ./configure --with-php-config=/usr/local/php/bin/php-config --enable-reader &amp;&amp; \\make &amp;&amp; make install然后在php.ini里面加一下extension = xlswriter.so，再重启php 7、redis1234567wget https://pecl.php.net/get/redis-5.3.4.tgz &amp;&amp; \\tar zxvf redis-5.3.4.tgz &amp;&amp; \\cd redis-5.3.4 &amp;&amp; \\phpize &amp;&amp; \\./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; make &amp;&amp; make install然后在php.ini里面加一下extension = redis.so，再重启php 8、kafka123456789101112131415161718注：php操作kafka需要安装rdkafka扩展，而rdkafka又依赖librdkafka库，因此在安装rdkafka之前，需要先安装librdkafka##1、安装 librdkafka 库git clone https://github.com/edenhill/librdkafka.git &amp;&amp; \\cd librdkafka/ &amp;&amp; \\./configure &amp;&amp; \\make &amp;&amp; make install##2、安装 php-kafka（rdkafka） 扩展git clone https://github.com/arnaud-lb/php-rdkafka.git &amp;&amp; \\cd php-rdkafka/ &amp;&amp; \\/usr/local/php/bin/phpize &amp;&amp; \\./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; \\make &amp;&amp; make install 然后在php.ini里面加一下extension = rdkafka.so，再重启php# （安装 php-kafka（rdkafka） 扩展方法二）安装好了librdkafka库之后，就可以使用pecl的方式一键安装rdkafka扩展了pecl install rdkafka # 安装rdkafka扩展","tags":[]},{"title":"悲观锁、乐观锁的区别及使用场景","date":"2016-03-29T16:05:00.000Z","path":"post/1011394230.html","text":"悲观锁悲观锁（Pessimistic Lock），顾名思义，就是很悲观， 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。 乐观锁乐观锁（Optimistic Lock），顾名思义，就是很乐观， 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁一般来说有以下2种方式： 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。 Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。 MySQL隐式和显示锁定MySQL InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。 在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。 前面描述的锁定都是隐式锁定，InnoDB会根据事务隔离级别在需要的时候自动加锁。 另外，InnoDB也支持通过特定的语句进行显示锁定，这些语句不属于SQL规范： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE 实战接下来，我们通过一个具体案例来进行分析：考虑电商系统中的下单流程，商品的库存量是固定的，如何保证商品数量不超卖？ 其实需要保证数据一致性：某个人点击秒杀后系统中查出来的库存量和实际扣减库存时库存量的一致性就可以。 假设，MySQL数据库中商品库存表tb_product_stock 结构定义如下： 123456789CREATE TABLE `tb_product_stock` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增ID', `product_id` bigint(32) NOT NULL COMMENT '商品ID', `number` INT(8) NOT NULL DEFAULT 0 COMMENT '库存数量', `create_time` DATETIME NOT NULL COMMENT '创建时间', `modify_time` DATETIME NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `index_pid` (`product_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品库存表'; 对应的POJO类： 1234567891011121314151617181920class ProductStock &#123; private Long productId; //商品id private Integer number; //库存量 public Long getProductId() &#123; return productId; &#125; public void setProductId(Long productId) &#123; this.productId = productId; &#125; public Integer getNumber() &#123; return number; &#125; public void setNumber(Integer number) &#123; this.number = number; &#125;&#125; 不考虑并发的情况下，更新库存代码如下： 123456789101112131415/** * 更新库存(不考虑并发) * @param productId * @return */ public boolean updateStockRaw(Long productId)&#123; ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;\", productId); if (product.getNumber() &gt; 0) &#123; int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;\", productId, product.getNumber()); if(updateCnt &gt; 0)&#123; //更新库存成功 return true; &#125; &#125; return false; &#125; 多线程并发情况下，会存在超卖的可能。 悲观锁 12345678910111213141516/** * 更新库存(使用悲观锁) * @param productId * @return */ public boolean updateStock(Long productId)&#123; //先锁定商品库存记录 ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125; FOR UPDATE\", productId); if (product.getNumber() &gt; 0) &#123; int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125;\", productId); if(updateCnt &gt; 0)&#123; //更新库存成功 return true; &#125; &#125; return false; &#125; 乐观锁 1234567891011121314151617181920/** * 下单减库存 * @param productId * @return */ public boolean updateStock(Long productId)&#123; int updateCnt = 0; while (updateCnt == 0) &#123; ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;\", productId); if (product.getNumber() &gt; 0) &#123; updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;\", productId, product.getNumber()); if(updateCnt &gt; 0)&#123; //更新库存成功 return true; &#125; &#125; else &#123; //卖完啦 return false; &#125; &#125; return false; &#125; 使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。 乐观锁与悲观锁的区别 乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。 悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁 （SELECT … FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。 什么场景需要使用锁，什么场景不需要使用锁？ 从中我们也可以知道只要更新数据是依赖读取的数据作为基础条件的，就会有并发更新问题，需要乐观锁或者悲观锁取解决，特别实在计数表现明显。 又比如在更新数据不依赖查询的数据的就不会有问题，例如修改用户的名称，多人同时修改，结果并不依赖于之前的用户名字，这就不会有并发更新问题。 小结这里我们通过 MySQL 乐观锁与悲观锁 解决并发更新库存的问题，当然还有其它解决方案，例如使用 分布式锁。目前常见分布式锁实现有两种：基于Redis和基于Zookeeper，基于这两种 业界也有开源的解决方案，例如 Redisson Distributed locks 、 Apache Curator Shared Lock ，这里就不细说，网上Google 一下就有很多资料。 最后个人小小总结下： 尽量少使用悲观锁和乐观锁，建议直接使用redis的分布式锁（即setnx命令），因为悲观锁会锁定数据库造成数据库的负担，乐观锁也要多建一个字段不太划算。 原文链接：https://www.cnblogs.com/shoshana-kong/p/10736797.html","tags":[]},{"title":"Linux 时间矫正命令","date":"2016-02-18T09:47:00.000Z","path":"post/1199720014.html","text":"Linux 时间矫正1sudo ntpdate -u ntp.api.bz 第一使用可能提示ntpdate没安装，用以下命令安装即可 1sudo apt install ntpdate","tags":[]},{"title":"linux查看进程命令","date":"2015-11-03T07:24:00.000Z","path":"post/2516578616.html","text":"linux查看进程命令查看进程命令 1$ ps -a 杀掉进程命令 1$ kill 进程id 监听端口命令 1$ netstat -anp | grep 4000 查看指定进程命令 1$ ps -ef | grep redis","tags":[{"name":"linux","slug":"linux","permalink":"https://yzdzh.github.io/tags/linux/"}]},{"title":"php判断变量是否为正整数","date":"2015-07-26T05:34:00.000Z","path":"post/934001781.html","text":"123456$data['recharge_price']=str_replace('.00','',$data['recharge_price']); if(preg_match(\"/^[1-9][0-9]*$/\" ,$data['recharge_price'])) &#123; echo \"是正整数\"; &#125;else&#123; echo \"不是正整数\"; &#125;","tags":[]},{"title":"php函数trim中文编码问题解决","date":"2015-04-18T02:26:00.000Z","path":"post/2735926554.html","text":"调用代码1234567891011121314151617181920212223242526272829303132mb_internal_encoding(\"UTF-8\");$encoding = mb_internal_encoding();$endData=self::mb_rtrim(\"广州市\", \"市\",$encoding);print_r($endData);exit; ``` ### 封装方法```phppublic static function mb_rtrim($string, $trim, $encoding)&#123; $mask = []; $trimLength = mb_strlen($trim, $encoding); for ($i = 0; $i &lt; $trimLength; $i++) &#123; $item = mb_substr($trim, $i, 1, $encoding); $mask[] = $item; &#125; $len = mb_strlen($string, $encoding); if ($len &gt; 0) &#123; $i = $len - 1; do &#123; $item = mb_substr($string, $i, 1, $encoding); if (in_array($item, $mask)) &#123; $len--; &#125; else &#123; break; &#125; &#125; while ($i-- != 0); &#125; return mb_substr($string, 0, $len, $encoding);&#125;","tags":[]}]