<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker安装软件环境集合</title>
    <url>/post/527254571.html</url>
    <content><![CDATA[<p>有一个小想法，整理一篇docker安装软件环境集合下安装环境文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的软件安装后就顺便更新到这篇博客文章。</p>
<h3 id="1、hexo（私有仓库，不提供开放）"><a href="#1、hexo（私有仓库，不提供开放）" class="headerlink" title="1、hexo（私有仓库，不提供开放）"></a>1、hexo（私有仓库，不提供开放）</h3><p>本人私有博客打包，仅做个人笔记记录，不提供开放</p>
<p>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>2、创建启动容器<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name hexo -it  -p 4000:4000 -w /home/wwwroot/hexo -v /home/wwwroot/hexo:/home/wwwroot/hexo  --entrypoint=<span class="string">"/home/wwwroot/hexo/hexo-sever.sh"</span> yizhidaozuihou/hexo</span><br></pre></td></tr></table></figure><br>  注：<br>   1)、第一次启动容器时需要将hexo-sever.sh中的#npm install解除注释，初始化node_modules</p>
<h3 id="2、elasticsearch"><a href="#2、elasticsearch" class="headerlink" title="2、elasticsearch"></a>2、elasticsearch</h3><p>基于elasticsearch7.12版本打包，允许跨域操作<br>1、下载镜像<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull yizhidaozuihou/es</span><br></pre></td></tr></table></figure><br>2、创建用户定义的网络（用于连接到连接到同一网络的其他服务（例如，Kibana））<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create somenetwork</span><br></pre></td></tr></table></figure><br>3、创建挂载的目录<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"></span><br><span class="line">//生产环境才需要执行以下命令（挂载配置文件和插件目录）</span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"http.host: 0.0.0.0"</span> &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">/mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">//需要设置挂载目录可读写权限，不然docker容器启动不了</span><br><span class="line">chmod -R 777 mydata/elasticsearch/</span><br></pre></td></tr></table></figure><br>4、创建容器并启动<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//测试环境docker（直接挂载数据库就行了）</span><br><span class="line">docker run -d --name es --net somenetwork -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span>  -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data yizhidaozuihou/es</span><br><span class="line"></span><br><span class="line">//生产环境docker(需要挂载配置文件和插件目录)</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300  -e <span class="string">"discovery.type=single-node"</span> -e ES_JAVA_OPTS=<span class="string">"-Xms64m -Xmx128m"</span> -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span><br></pre></td></tr></table></figure><br>其中elasticsearch.yml是挂载的配置文件，data是挂载的数据，plugins是es的插件，如ik，而数据挂载需要权限，需要设置data文件的权限为可读可写,需要下边的指令。<br>chmod -R 777 要修改的路径</p>
<p>-e “discovery.type=single-node” 设置为单节点<br>特别注意：<br>-e ES_JAVA_OPTS=”-Xms256m -Xmx256m” \ 测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES</p>
<h3 id="3、elasticsearch-head"><a href="#3、elasticsearch-head" class="headerlink" title="3、elasticsearch-head"></a>3、elasticsearch-head</h3> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//基于elasticsearch-head5版本打包，兼容elasticsearch7.X版本</span><br><span class="line">docker pull yizhidaozuihou/es-head</span><br><span class="line">docker run  -d --name es-head -p 9100:9100 yizhidaozuihou/es-head</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>docker打包自定义镜像并上传docker hub</title>
    <url>/post/1624279696.html</url>
    <content><![CDATA[<h6 id="docker打包自定义镜像并上传docker-hub"><a href="#docker打包自定义镜像并上传docker-hub" class="headerlink" title="docker打包自定义镜像并上传docker hub"></a>docker打包自定义镜像并上传docker hub</h6><p>1、使用dockers commit命令来打包</p>
<p>dockers commit 容器名 要保存成的镜像名：版本名（若没有：版本名则直接默认为latest）<br>例如 docker commit vser vs:v1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit 49ba413b3614 es</span><br></pre></td></tr></table></figure>

<p>2、将刚刚commit 的镜像名 打包成特定的格式。例如：<br>docker tag vs:v1 你docker的用户名/你dockerhub上创建的仓库名：版本号 （若无则默认为latest）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag es:v1 yizhidaozuihou/es</span><br></pre></td></tr></table></figure>

<p>3、打包好后, 将镜像拉取到仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push yizhidaozuihou/es</span><br><span class="line">注：如果未登录docker hub的话是不能push上传的，需要先 docker login 命令输入账号密码登录后才能push</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>phpstrom实用插件集合</title>
    <url>/post/1452351953.html</url>
    <content><![CDATA[<p>以下是个人在实践工作中总结的好用的phpstrom集合，持续不断更新中。。</p>
<h3 id="1、中英文转换：translation"><a href="#1、中英文转换：translation" class="headerlink" title="1、中英文转换：translation"></a>1、中英文转换：translation</h3><pre><code>快捷键 Ctrl+Shift+Y   OR 选中需要翻译的文本，然后鼠标右键选择Translate</code></pre><h3 id="2、拼写法转换：camelCase"><a href="#2、拼写法转换：camelCase" class="headerlink" title="2、拼写法转换：camelCase"></a>2、拼写法转换：camelCase</h3><pre><code>选中需要改变的变量  使用  快捷键 shift + alt + u ，变量就会改变，直到找到需要的格式。</code></pre><h3 id="3、php-注释增强工具：PHP-Annotation"><a href="#3、php-注释增强工具：PHP-Annotation" class="headerlink" title="3、php 注释增强工具：PHP Annotation"></a>3、php 注释增强工具：PHP Annotation</h3><pre><code>可以自动提示补全注解名和点击跳转追踪</code></pre><h3 id="4、自动关联数组键输入和完成：deep-assoc-completion"><a href="#4、自动关联数组键输入和完成：deep-assoc-completion" class="headerlink" title="4、自动关联数组键输入和完成：deep-assoc-completion"></a>4、自动关联数组键输入和完成：deep-assoc-completion</h3><pre><code>帮助完成数组参数 - 可以使用哪些键</code></pre><h3 id="5、proto语法高亮追踪提示：Protocol-Buffers"><a href="#5、proto语法高亮追踪提示：Protocol-Buffers" class="headerlink" title="5、proto语法高亮追踪提示：Protocol Buffers"></a>5、proto语法高亮追踪提示：Protocol Buffers</h3><pre><code>proto语法高亮追踪提示，临时看其他项目不想安装依赖包时使用 </code></pre>]]></content>
      <categories>
        <category>phpStorm</category>
      </categories>
  </entry>
  <entry>
    <title>php获取指定前缀常量便捷操作方法</title>
    <url>/post/4113924384.html</url>
    <content><![CDATA[<p>例如一张订单表的订单状态有：1待付款 2已付款 3已取消4已退款，php的常见做法都是会将这些常量的值和中文注释写在对应表的model文件，只要统一类型常量前缀都统一的话，后续操作会方便多。 </p>
<p>1、在model中定义的字段类型规范如下order_status字段的常量前缀都是ORDER_STATUS_，常量内容都是：[值，中文解释]</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅为示例代码，实际三个封装方法可以直接放在基础类BaseModel里面所有model公用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">extends</span> <span class="title">BaseModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> int 订单类型 */</span></span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_WAITING = [<span class="number">0</span>,<span class="string">'待付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_PAY_SUCCESS = [<span class="number">1</span>,<span class="string">'已付款'</span>];</span><br><span class="line">    <span class="keyword">const</span> ORDER_STATUS_REFUNDED    = [<span class="number">2</span>,<span class="string">'已退款'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组（返回无指定key的集合的二维数组）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array [[0,'待付款'],[1,'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstDesc</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[] = $v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (结果返回指定key，value字段名的二维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  二维数组，可以指定key和value的字段名 例：[['id'=&gt;0,'name'=&gt;'待付款'],['id'=&gt;1,'name'=&gt;'已付款']]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstSelect</span><span class="params">(string $key,string $key_field = <span class="string">'id'</span> , string $value_field = <span class="string">'name'</span>)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $const_list = <span class="keyword">self</span>::getConstDesc($key);</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($const_list <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            $desc[] = [</span><br><span class="line">                $key_field=&gt;$v[<span class="number">0</span>]??<span class="number">0</span>,</span><br><span class="line">                $value_field=&gt;$v[<span class="number">1</span>]??<span class="string">''</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据常量的前缀获取键值对数组 (結果返回一维数组)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key 常量下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array  一维数组，key为索引第一位数，value为索引第二位数。 例：['key'=&gt;value,0=&gt;'待付款',1=&gt;'已付款']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getConstPluck</span><span class="params">(string $key)</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $oClass = <span class="keyword">new</span> \ReflectionClass(<span class="keyword">static</span>::class);</span><br><span class="line">        $constAry = $oClass-&gt;getConstants();</span><br><span class="line">        $desc = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($constAry <span class="keyword">as</span> $const =&gt; $v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strpos($const, $key) === <span class="number">0</span>) &#123;</span><br><span class="line">                $desc[$v[<span class="number">0</span>]] = $v[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$getConstDesc = Order::getConstDesc(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstSelect = Order::getConstSelect(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line">$getConstPluck = Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>(Order::getConstPluck(<span class="string">'ORDER_STATUS_'</span>)[$params[<span class="string">'order_status'</span>]]))&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(ErrorHelper::FAIL_CODE,<span class="string">'订单类型不存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>linux设置开机服务自动启动/关闭自动启动命令</title>
    <url>/post/1924607937.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chkconfig --list 显示开机可以自动启动的服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --add *** 添加开机自动启动***服务 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --del *** 删除开机自动启动***服务</span></span><br></pre></td></tr></table></figure>

<p>参考地址：<a href="https://blog.csdn.net/weixin_34254823/article/details/92815942" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34254823/article/details/92815942</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql开启全部sql日志查询</title>
    <url>/post/2712546463.html</url>
    <content><![CDATA[<p>   本地开发调试很经常需要查看sql语句来进行分析，一般框架都有自带这种功能，不过有些框架的ORM不支持记录sql语句，最简单的方法就是mysql直接开启记录sql日志，这样本地开发调试就很方便了，当然生产环境就别用了！</p>
<h5 id="1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置"><a href="#1、打开-my-cnf-配置文件，在-mysqld-段下加入下面的配置" class="headerlink" title="1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置"></a>1、打开 my.cnf 配置文件，在[mysqld]段下加入下面的配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">general_log=on</span><br><span class="line"><span class="comment">#自动生成日志 0-不打开  1-打开</span></span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/system_log/mysql_sql.log</span><br></pre></td></tr></table></figure>


<h5 id="2、重启mysql"><a href="#2、重启mysql" class="headerlink" title="2、重启mysql"></a>2、重启mysql</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h5 id="3、查看日志是否打开"><a href="#3、查看日志是否打开" class="headerlink" title="3、查看日志是否打开"></a>3、查看日志是否打开</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">where</span> Variable_name=<span class="string">"general_log"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>golang之捕获异常</title>
    <url>/post/2798837510.html</url>
    <content><![CDATA[<p><strong>系统内部错误：捕获错误，并提示。</strong></p>
<ul>
<li>使用了defer panic 和recover关键字</li>
<li>描述：1.抛出panic异常，2.在defer通过recover捕获异常，然后正常处理　　</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> errRecover := <span class="built_in">recover</span>(); errRecover != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"errRecover "</span> , errRecover )</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang之基于zap开箱即用日志组件</title>
    <url>/post/816087200.html</url>
    <content><![CDATA[<p>logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显:</p>
<ul>
<li>优雅的代码框架设计</li>
<li>使用简单</li>
<li>组件化的开发思路</li>
<li>灵活的输出方式</li>
</ul>
<p>但是, 性能终究是忍痛舍弃 logrus 的“阿喀琉斯之踵”<br>目前 golang 日志库的大众选择主要集中在: logrus, zap, zerolog. zap 和 zerolog 的性能都是优秀的, 但是从用法习惯上我更倾向于 zap.</p>
<h3 id="简单介绍-Zap-的使用"><a href="#简单介绍-Zap-的使用" class="headerlink" title="简单介绍 Zap 的使用"></a>简单介绍 Zap 的使用</h3><p>Zap 提供三种不同方式的输出(以 Info为 例)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.Info(<span class="string">"hello zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423173.016333,"caller":"test_zap/main.go:28","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infof(<span class="string">"hello %s"</span>, <span class="string">"zap"</span>) <span class="comment">// &#123;"level":"info","ts":1576423203.056074,"caller":"test_zap/main.go:29","msg":"hello zap"&#125;</span></span><br><span class="line">log.Infow(<span class="string">"hello zap"</span>, <span class="string">"field1"</span>, <span class="string">"value1"</span>) <span class="comment">//&#123;"level":"info","ts":1576423203.0560799,"caller":"test_zap/main.go:30","msg":"hello zap","field1":"value1"&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果我们对 logrus 的 key-value 理论比较在意的话, 使用 zap infow 可以完美解决</p>
<ul>
<li>Zap 使用起来不便利的地方</li>
<li>Zap 使用上不能像 logrus 那样开箱即用</li>
<li>使用者需要自己去组装相关函数</li>
<li>Zap 同样不提供日志切割的功能, 但是想添加上这个功能没有 logrus 那样便利</li>
</ul>
<p>基于这些问题, 我封装了一套开箱即用的日志组件: <a href="https://github.com/yizhidaozuihou/log" target="_blank" rel="noopener">https://github.com/yizhidaozuihou/log</a></p>
<p>打造 Zap 开箱即用日志组件<br>提供的功能:</p>
<ul>
<li>提供的功能: 像 logrus 一样, 全局的 Debug, Info … 函数</li>
<li>日志分割功能. 默认文件大小1024M，自动压缩, 最大有3个文件备份，备份保存时间7天, 不会打印日志被调用的文文件名和位置</li>
<li>日志默认会被分成五类文件：debug、info、warn、error、panic 都会打印在xxx.log. xxx.log.Request输出 request log 的地方(如果有需要的话)</li>
</ul>
<p>使用方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/yizhidaozuihou/log</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/yizhidaozuihou/log"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// init log</span></span><br><span class="line">	<span class="comment">// set absolute path, and level</span></span><br><span class="line">	<span class="comment">// set output level</span></span><br><span class="line">	<span class="comment">// don't need request log</span></span><br><span class="line">	<span class="comment">// set log's caller using logOption</span></span><br><span class="line">	log.Init(<span class="string">"./test.log"</span>, log.DebugLevel, <span class="literal">false</span>, log.SetCaller(<span class="literal">true</span>))</span><br><span class="line">	log.Info(<span class="string">"hello george log"</span>)</span><br><span class="line">	<span class="comment">// flush</span></span><br><span class="line">	log.Sync()</span><br><span class="line">	<span class="comment">//output: &#123;"level":"info","ts":"2019-12-16T10:37:11.364+0800","caller":"example/example.go:12","msg":"hello george log"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang个人总结好用库集合</title>
    <url>/post/561152273.html</url>
    <content><![CDATA[<p>以下是个人在实践工作中总结的好用库集合，持续不断更新中。。</p>
<h3 id="一、json处理库"><a href="#一、json处理库" class="headerlink" title="一、json处理库"></a>一、json处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/3838666233.html target = _blank>http://wangzhuanglin.gitee.io/post/3838666233.html</a></p>
<h3 id="二、配置文件处理库"><a href="#二、配置文件处理库" class="headerlink" title="二、配置文件处理库"></a>二、配置文件处理库</h3><p><a href=http://wangzhuanglin.gitee.io/post/132771847.html target = _blank>http://wangzhuanglin.gitee.io/post/132771847.html</a></p>
<h3 id="三、日志库"><a href="#三、日志库" class="headerlink" title="三、日志库"></a>三、日志库</h3><p><a href=http://wangzhuanglin.gitee.io/post/816087200.html target = _blank>http://wangzhuanglin.gitee.io/post/816087200.html</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang之viper操作库</title>
    <url>/post/132771847.html</url>
    <content><![CDATA[<p>Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。</p>
<p>这里记录下viper读取.env配置文件的具体代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">".env"</span>) <span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigType(<span class="string">"env"</span>) <span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"./"</span>)   <span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">err12 := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err12 != <span class="literal">nil</span> &#123; <span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line">	<span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Fatal error config file: %s \n"</span>, err12))</span><br><span class="line">&#125;</span><br><span class="line">viper.SetDefault(<span class="string">"DB_DRIVER"</span>,<span class="number">55555</span>)</span><br><span class="line">fmt.Println(<span class="number">777</span>,viper.GetString(<span class="string">"DB_DRIVER"</span>))</span><br></pre></td></tr></table></figure>

<p>其他详细教程可以直接看go大神写的详细文章<br><a href="https://www.liwenzhou.com/posts/Go/viper_tutorial/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/viper_tutorial/</a><br><a href="https://learnku.com/articles/33908" target="_blank" rel="noopener">https://learnku.com/articles/33908</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang库集合</title>
    <url>/post/3243567407.html</url>
    <content><![CDATA[<h3 id="golang用于创建和发送电子邮件的库"><a href="#golang用于创建和发送电子邮件的库" class="headerlink" title="golang用于创建和发送电子邮件的库"></a>golang用于创建和发送电子邮件的库</h3><p>douceur - HTML 邮件中的内联 CSS<br>email - 一个健壮的、灵活的 email 库<br>Go-dkim - DKIM 库，用于对 email 进行签名和验证<br>Go-imap - IMAP 库，用于客户端和服务器<br>Go-message - 用于触雷互联网消息格式和邮件的库<br>Gomail - Gomail 是一个非常简单且强大的库，用于发送电子邮件<br>Hectane - 轻量级 SMTP 客户端，提供 HTTP API<br>hermes - 一个用于生成干净、响应式 HTML e-mail 的包<br>MailHog - Email 及 SMTP 测试工具，具有 web 及 API 接口<br>SendGrid - SendGrid 的 Go 语言库，用于发送电子邮件<br>smtp - SMTP 服务器协议状态机  </p>
<h3 id="golang处理日期和时间的库"><a href="#golang处理日期和时间的库" class="headerlink" title="golang处理日期和时间的库"></a>golang处理日期和时间的库</h3><p>carbon - 简单的时间扩展程序，有很多有用的方法，是 PHP Carbon 库的接口<br>durafmt - 持续时间格式化<br>feiertage - 一组计算德国公共假期的函数，比如复活节、感恩节等<br>Go-persian-calendar - 太阳历<br>Goweek - 处理星期的库<br>now - Now 是一个 Go 语言的时间工具集<br>NullTime -时间可以是 NULL 的库<br>timeutil - 为 Go 语言时间包扩展了有用的功能，例如时间间隔和格式化  </p>
<h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>darwin - 数据库模式进化库<br>Go-fixtures - 类似 DjanGo fixtures，用于 Golang 的內建数据库/sql 库<br>Goose - 数据库迁移工具。你可以通过编写增量 SQL 或 Go 语言脚本来管理你的数据库<br>Gormigrate - 数据库模式迁移帮助工具，用于 Gorm ORM.<br>migrate - 数据库迁移。命令行及 Go 语言库<br>pravasan - 简单的迁移，目前支持 MySQL 但是近期打算支持 Postgres, SQLite, MonGoDB 等等<br>soda - 数据库迁移、创建、 ORM等等，用于 MySQL, PostgreSQL, 以及 SQLite.<br>sql-migrate - 数据库迁移工具，允许利用 Go-bindata 将数据库迁移嵌入应用程序  </p>
<h3 id="Go-语言实现的数据库"><a href="#Go-语言实现的数据库" class="headerlink" title="Go 语言实现的数据库"></a>Go 语言实现的数据库</h3><p>BigCache - 为 gigabytes 量级数据设计的高效键/值缓存<br>bolt - 底层键值数据库<br>buntdb - 快速，可嵌入的，内存键值数据库，可定义索引及 spatial<br>cache2Go - 基于内存存储的键值缓存，支持自动基于超时的自动失效<br>cockroach - 可扩展的、一致的事务型数据库<br>couchcache - RESTful 缓存微服务，基于Couchbase<br>dgraph - 可扩展的、分布式的、低延时、高吞吐的图数据库<br>diskv - 具有 disk-backed 功能的持久化键值存储<br>eliasdb - 无依赖、事物型图数据库，支持 REST API、短语搜索以及类 SQL 的查询语言<br>forestdb - ForestDB 的 Go 语言借口<br>GCache - 支持缓存过期、 LFU、 LRU 和 ARC 的缓存库<br>geocache - 基于内存存储的缓存，适用于分布式部署的应用<br>Go-cache - 内存键值存储/缓存库，适用于单机程序<br>Goleveldb - 使用 Go 语言实现的 LevelDB<br>groupcache - Groupcache 是一个缓存及缓存填充库，在很多情况下用于替代 memcached.<br>influxdb - 用于计量、事件及实时分析的、可扩展的数据库<br>ledisdb - Ledisdb 是一个高性能 NoSQL 数据库，类似 Redi<br>leviGo - LeviGo 是 LevelDB的 Go 语言封装<br>moss - Moss 是一个简单的 LSM 键值存储引擎，100% Go 语言实现<br>piladb - 轻量级 RESTful 数据库引擎，基于堆栈结构<br>prometheus - 监控系统及时间序列数据库<br>rqlite - 基于 SQLite 的轻量级的、分布式的关系型数据库<br>Scribble - 小巧的 JSON 文件存储<br>tempdb - 临时数据的键值对存储<br>tidb - TiDB 是一个分布式的 SQL 数据库。受到了 Google F1的启发<br>tiedot - 基于 Go 语言的 NoSQL 数据库<br>Tile38 - 地理位置数据库及实时地理围栏  </p>
<h3 id="golang通用数据结构及算法"><a href="#golang通用数据结构及算法" class="headerlink" title="golang通用数据结构及算法"></a>golang通用数据结构及算法</h3><p>binpacker - 二进制数据封包拆包工具，帮你构建自定义的二进制数据流<br>bit - Go 语言集合数据结构。提供了额外的位操作功能<br>bitset - 实现了 bitset 的 Go 语言包.<br>bloom - Go 语言实现的布隆过滤器（bloom filter）<br>bloom - Go 语言实现的布隆过滤器<br>boomfilters - 概率统计数据结构，用于处理大量连续的数据。<br>count-min-log - Go 语言实现的 Count-Min-Log sketch 算法(类似 Count-Min sketch 算法，但是使用的内存更少).<br>cuckoofilter - Cuckoo 过滤器：一个用go语言实现的计数布隆过滤器的替代品<br>encoding - 整型压缩库<br>Go-adaptive-radix-tree - Go 语言实现的自适应基数树<br>Go-datastructures - 一组有用的、高性能的、线程安全的数据结构<br>Go-geoindex - 基于内存存储的地理索引<br>Go-rquad - 区域四叉树，支持有效点位置和领域发现<br>Gods - Go 语言数据结构、容器、集合、列表、栈、键值对、 BidiMaps、树、HashSet 等<br>Golang-set - 线程安全和非线程安全的高性能集合<br>Goskiplist - Go 语言实现的跳跃表<br>Gota - 为go语言实现了数据帧，序列以及数据噪音的方法<br>hilbert - 用于映射空间填充曲线（例如希尔伯特曲线和皮亚诺曲线）和数值的库。<br>hyperloglog - HyperLogLog implementation with Sparse, LogLog-Beta bias correction and TailCut space reduction.<br>levenshtein - 编辑距离（levenshtein distance）和相似性度量， 可以自定义编辑代价和and Winkler-like bonus for common prefix.<br>levenshtein - Go 语言实现计算编辑距离<br>mafsa - Go 语言实现的 MA-FSA ，包含最小完美哈希<br>merkletree - 实现了梅克尔树，提供了一种高效、安全的数据结构内容验证方法<br>roaring - 实现了压缩 bitsets 的Go语言库<br>skiplist - Go语言实现的跳跃表<br>trie - Go语言实现的Trie树<br>ttlcache - In-memory LRU string-interface{} map with expiration for Golang<br>willf/bloom - 实现了布隆过滤器的库  </p>
<h3 id="golang用于进行配置解析的库"><a href="#golang用于进行配置解析的库" class="headerlink" title="golang用于进行配置解析的库"></a>golang用于进行配置解析的库</h3><p>config - JSON 或 YAML 配置的封装，支持环境变量和标记解析<br>configure - 可以通过多种途径进行配置，包括 JSON, 标记位以及环境变量<br>env - 解析环境变量为 Go 语言结构体<br>envcfg - 解析环境变量为 Go 语言结构体<br>envconf - 通过环境变量来配置<br>envconfig - 通过环境变量读取配置<br>gcfg - 读取类 INI 类型的配置文件为 Go 语言结构体，支持自定义变量和节<br>GoConfig - 通过命令行的输入、环境变量、配置文件来初始化一个结构体兵将一个结构体解析为输入<br>Godotenv - Ruby 库 dotenv 的 Go 语言接口 (通过 .env 来获取环境变量)<br>Gofigure - 让 Go 语言应用程序配置变得简单<br>Gone/jconf - 模块化 JSON 配置工具。允许你将配置参数结构体和使用它的代码放在一起，而不需要让主配置文件了解所有子模块的细节来进行序列化<br>hjson - 人性化的 JSON，一个便于程序员使用和阅读的配置文件格式。更加轻松的语法，更少的错误和更多的注释<br>inGo - 将配置标记持久化到一个类似 ini 的文件中<br>ini - 用于读写INI 文件的库<br>joshbetz/config - 消息配置库，可以解析环境变量、JSON 文件并根据SIGHUP自动重新载入<br>mini -用于解析类 ini 文件的库<br>store - 轻量级配置管理<br>viper - 这个库名叫毒蛇 ,Go 语言配置工具<br>xdg -遵守 XDG 标准 的配置工具  </p>
<h3 id="golang认证和授权库"><a href="#golang认证和授权库" class="headerlink" title="golang认证和授权库"></a>golang认证和授权库</h3><p>authboss - 用于 web 开发的组件化认证授权系统。它尝试尽可能的移除模板代码以及硬编码，这使你每次新建 web 项目的时候，可以做到即插即用、配置并开始开发你的 web 英语，而不必每次都重新创建一个认证授权系统。<br>casbin - 一个支持接入控制模型（例如:ACL,RBAC,ABAC）的授权库<br>Go-AWS-Auth - AWS 请求签名库<br>Go-jose - Fairly complete implementation of the JOSE working group’s JSON Web Token, JSON Web 签名以及JSON Web 加密 specs.<br>Go-oauth2-server - 使用 Go 语言编写的独立、符合标准的 OAuth2 服务器<br>Go.auth - 为 Go 语言 web 应用提供的授权 API.<br>Gologin - 可以串连使用OAuth1 和 OAuth2 认证服务<br>Gorbac - 一个用 Go 语言实现的轻量级RBAC<br>Goth - 提供了一种简洁的、惯用的方式来使用OAuth 和 OAuth2.<br>httpauth - HTTP 认证中间件<br>jwt - 简单易用的一个JSON Web Tokens (JWT)的实现<br>jwt-auth - JWT 为 Go 语言 HTTP 服务器编写的 jwt 中间件，有多种配置选项<br>jwt-Go - Go 语言实现的JSON Web Tokens (JWT).<br>loginsrv - JWT 登录微服务，可以继承OAuth2 (Github), htpasswd, osiam等后端。<br>oauth2 - Goauth2的继承者。 通用 OAuth 2.0 库，集成了对JWT, Google APIs, Compute Engine 和 App Engine的支持.<br>osin - Go 语言 OAuth2 服务器库<br>permissions2 - 用于追踪用户，登录状态和许可的库。使用安全 cookies 和 bcrypt.<br>session - Go 语言会话管理(支持 Google App Engine - GAE)<br>sessions - 为 Go 语言 HTTP 服务器开发的非常简单的、高性能的、高可定制的会话服务<br>traefik - 反向代理和负载均衡库，支持多种后端<br>yubiGo - Yubikey 客户端，提供了用于在 Go 语言应用中集成Yubico   Yubikey 的 API  </p>
<h3 id="golang用于操作音频的库"><a href="#golang用于操作音频的库" class="headerlink" title="golang用于操作音频的库"></a>golang用于操作音频的库</h3><p>flac - 原生 Go FLAC 解码器<br>flac - 原生 Go FLAC 解码器<br>gaad - 原生 Go AAC 比特流解析器<br>Go-sox - libsox 的 Go 语言接口<br>Go_mediainfo - libmediainfo 的 Go 语言接口<br>Gosamplerate - libsamplerate 的 Go 语言接口<br>id3v2 - 快速且稳定的 ID3 解析及写入库<br>mix - 基于序列的 Go 语言混音器，可用于音乐 app。<br>mp3 - 原生 Go MP3 解码器<br>music-theory - Go 语言编写的音乐理论模型<br>PortAudio - 音频 I/O 库的 Go 语言接口<br>portmidi - PortMidi 的 Go 语言接口<br>taglib - taglib 的 Go 语言接口<br>vorbis - “原生” Go Vorbis 解码器 (使用 CGo, 但是没有其他依赖).<br>waveform - 一个可以通过音频流生成波形图像的包  </p>
<h3 id="golang代码中嵌入其他语言的包"><a href="#golang代码中嵌入其他语言的包" class="headerlink" title="golang代码中嵌入其他语言的包"></a>golang代码中嵌入其他语言的包</h3><p>aGora - 一种动态类型的可以嵌入 Go 中的编程语言<br>anko - Go 语言编写的解释器<br>binder - Lua 接口, 基于 Gopher-lua<br>gisp - Simple LISP<br>Go-duktape - Duktape JavaScript 引擎的 Go 语言接口<br>Go-lua - Lua 5.2 虚拟机的纯 Go 语言接口<br>Go-php - PHP 的 Go 语言接口<br>Go-python - CPython C-API 的 Go 语言接口<br>Golua - Lua C API。的 Go 语言接口<br>Gopher-lua - Go 语言编写的 Lua 5.1 虚拟机和编译器<br>ngaro - 可嵌入的 Ngaro 虚拟机实现，支持在 Retro 中使用脚步<br>otto - Go 编写的 Javascrip 解释器<br>purl - 嵌入 Go 语言的 Perl 5.18.2  </p>
<h3 id="go日志库"><a href="#go日志库" class="headerlink" title="go日志库"></a>go日志库</h3><p>glg - glg 是一个简单、快速、分级的日志库<br>glog - 分级记录日志的库<br>Go-cronowriter 对日志文件进行自动循环写入的库基于当前日期和时间，类似 cronolog.<br>Go-log - 支持多处理器及日志分级的库<br>Go-log - Go 语言实现的 Log4j<br>Go-logger - 支持日志分级的简单的日志工具<br>Gologger - 简单易用的日志库，可以在彩色控制台、简易控制的、文件或 Elasticsearch 中记录<br>Gomol - 支持多种输出，结构化的日志模块，可以扩展它的输出<br>Gone/log - 快速、可扩展、全功能、兼容标准库的日志库<br>log - 结构化日志库<br>log - 简单、可配置、可扩展的结构化日志库<br>log-voyage - 全功能日志saas 使用 Go 语言编写<br>log15 - 简单强大的日志库<br>logdump - 支持分级的日志库<br>logex - Go 语言日志库，支持追踪和分级，基于标准库进行了封装<br>logger - 一个极简的日志库<br>logrus - 支持结构化的日志工具.<br>logrusly - logrus 的插件，用于将错误发送到 Loggly.<br>logutils - 对 Go 语言标准日志工具进行了扩展，使其更好用<br>logxi - 十二要素 app 日志工具，非常快速，令你开心<br>lumberjack - 简单的循环日志工具，实现了 io.WriteCloser.<br>mlog - 一个简单的日志模块，可以分5级并有一个可选的循环日志文件记录功能，支持 stdout/stderr 输出.<br>ozzo-log - 高性能日志库，支持日志严重级别、分类及过滤。可以将过滤后的信息发送到不同的目的地(例如： 控制台、网络、邮箱).<br>seelog - 一个灵活的、解耦的、格式化的日志库<br>slf - 简单日志门面（The Structured Logging Facade (SLF) ） (类似 SLF4J，但是它是结构化的，并且专为 Go 语言设计)<br>slog - 为 Go 语言实现的结构化日志门面（Structured Logging Facade (SLF) ）<br>spew - 为 Go 语言的数据结构实现了一个整洁的打印功能，有助于调试<br>stdlog - Stdlog 是一个面向对象的库，提供了分级日志功能，对于定时任务很有用.<br>tail - 这个 Go 语言软件包力争模拟 BSD tail 的功能<br>xlog - 插件架构以及灵活的日志系统，具有日志等级控制，多日志目标以及自定义日志格式功能<br>xlog - 结构化日志 for net/context aware HTTP handlers ，可以灵活的分发<br>zap - 快速的、结构化的、分级的日志库<br>zerolog - 零分配 JSON 日志.  </p>
<h3 id="golang操作表单的库"><a href="#golang操作表单的库" class="headerlink" title="golang操作表单的库"></a>golang操作表单的库</h3><p>bind - 将表单数据绑定到任意的 Go 变量上<br>binding - 将来自 net/HTTP 请求的表单、JSON 数据绑定到结构体<br>conform - 检查用户输入并基于结构标签来清理数据<br>form - 解码 url 中的数据到 Go 语言变量中以及将 Go 语言变量编码进 url 支持Dual Array 及 Full map<br>formam - 将表单数据解码到结构体<br>forms - 框架无关的表单/JSON数据解析验证库，支持多部分表单及文件<br>Gorilla/csrf - 为 Go 语言 web 应用提供 CSRF 防御<br>nosurf - CSRF 防御中间件  </p>
<h3 id="Go实现消息系统的库"><a href="#Go实现消息系统的库" class="headerlink" title="Go实现消息系统的库"></a>Go实现消息系统的库</h3><p>CentrifuGo - 实时消息服务器<br>dbus - D-Bus的 Go 语言接口<br>drone-line - 通过软件包，docker 或是 Drone CI来发送 Line 通知<br>emitter - 通过Go语言的方式发送事件消息，可以使用通配符，断言，取消发送等优秀特性<br>EventBus - 轻量级事件库，支持异步<br>gaurun-client - Go 语言编写的 Gaurun 客户端<br>Glue - 健壮的 Go 和 Javascript Socket 库 (可以用来替代 Socket.io).<br>Go-longpoll - 支持长轮询的发布与订阅<br>Go-notify - 原生实现的桌面通知规范<br>Go-nsq - NSQ 官方 Go 语言库<br>Go-socket.io - Go 语言的 socket.io库 ,一个实时应用框架.<br>Go-vitotrol - Viessmann Vitotrol 服务的 Go 语言客户端<br>Gollum - 一个 n:m 的多路复用器，从不同的源汇聚消息并向目标进行广播<br>Golongpoll - HTTP 长轮询服务器库，让 web 发布与订阅变的更简单.<br>Goose - Go 语言实现的服务器端事件发送<br>Gopush-cluster - Gopush-cluster 是一个 Go 语言实现的支持集群的comet服务（支持 websocket，和tcp协议）<br>Gorush - 通知推送服务器，使用 APNs2 和 Google GCM.<br>guble - 一个使用通知推送(Google Firebase Cloud Messaging, Apple Push Notification services, SMS)、websockets 、REST API 的消息服务器。提供了分布式操作和消息持久化特性<br>machinery - 异步任务队列，基于分布式消息处理<br>manGos - 纯 Go 语言实现的 Nanomsg (“Scalable Protocols”)<br>melody - 用于处理 websocket 会话的一个极简框架，包括广播和自动 ping/pong 处理<br>NATS Go Client - 轻量级高性能发布订阅(publish-subscribe) 以及分布式消息队列系统，这个一个Go语言库.<br>nsq-event-bus - 针对 NSQ 的主题和频道进行了简单的封装<br>oplog - 原生的 oplog/replication 系统，用于 REST APIs<br>pubsub - 一个简单的 pubsub 软件包<br>RapidMQ - RapidMQ 是一个轻量级，可靠的本地消息队列管理库<br>sarama - 用于 Apache Kafka 的库<br>Uniqush-Push - 基于 Redis 的统一推服务，用于服务器端向移动客户端推送消息<br>zmq4 - ZeroMQ version 4的 GO 语言接口。也有适用于version 3 及 version 2的  </p>
<p>最后还有github上的类库大全：<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang之json操作库</title>
    <url>/post/3838666233.html</url>
    <content><![CDATA[<p>总结有三个非常好用的json操作库<br>1、gjson （读取json）<br>2、sjson   （增删改json）<br>3、gojsonq  （高级查询统计json数据）  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/tidwall/gjson</span><br><span class="line">$ <span class="keyword">go</span> get github.com/tidwall/sjson</span><br><span class="line">$ <span class="keyword">go</span> get github.com/thedevsaddam/gojsonq</span><br></pre></td></tr></table></figure>

<p>具体详情文章：<br>gjson ：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439052&amp;idx=4&amp;sn=4b668ec590db68ac5850e4c9eff6bfd1&amp;chksm=80bb613eb7cce828155ccfa92821b3da15f2551b8f6335bf6b8189aa9747a20c0ce1855de4f5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439052&amp;idx=4&amp;sn=4b668ec590db68ac5850e4c9eff6bfd1&amp;chksm=80bb613eb7cce828155ccfa92821b3da15f2551b8f6335bf6b8189aa9747a20c0ce1855de4f5&amp;scene=21#wechat_redirect</a><br>sjson   ：<a href="https://mp.weixin.qq.com/s/ucfJxIw_NLb6TGrhQa3UcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ucfJxIw_NLb6TGrhQa3UcQ</a><br>gojsonq  ：<a href="https://mp.weixin.qq.com/s/ZfaH6ROWiVX9IsoxJ04oXw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZfaH6ROWiVX9IsoxJ04oXw</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>go依赖管理--Go modules</title>
    <url>/post/2526408434.html</url>
    <content><![CDATA[<h2 id="一、什么是Go-Modules"><a href="#一、什么是Go-Modules" class="headerlink" title="一、什么是Go Modules?"></a>一、什么是Go Modules?</h2><p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。  </p>
<p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：  </p>
<ol>
<li>Go 语言长久以来的依赖管理问题。  </li>
<li>“淘汰”现有的 GOPATH 的使用模式。  </li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）。  </li>
</ol>
<h2 id="二、GOPATH的工作模式"><a href="#二、GOPATH的工作模式" class="headerlink" title="二、GOPATH的工作模式"></a>二、GOPATH的工作模式</h2><p>Go Modoules的目的之一就是淘汰GOPATH, 那么GOPATH是个什么?  </p>
<p>为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？  </p>
<h3 id="1-Wait-is-GOPATH"><a href="#1-Wait-is-GOPATH" class="headerlink" title="(1) Wait is GOPATH?"></a><strong>(1) Wait is GOPATH?</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line"></span><br><span class="line">GOPATH=<span class="string">"/home/itheima/go"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们输入go env命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>GOPATH目录下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放。</li>
</ul>
<blockquote>
<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。</p>
</blockquote>
<h3 id="2-GOPATH模式的弊端"><a href="#2-GOPATH模式的弊端" class="headerlink" title="(2) GOPATH模式的弊端"></a><strong>(2) GOPATH模式的弊端</strong></h3><p>在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端.</p>
<p>A. 无版本控制概念. 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。<br>B.无法同步一致第三方版本号. 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。<br>C.无法指定当前项目引用的第三方版本号. 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。  </p>
<h2 id="三、Go-Modules模式"><a href="#三、Go-Modules模式" class="headerlink" title="三、Go Modules模式"></a>三、Go Modules模式</h2><p>我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在GOPATH/src下.</p>
<h3 id="1-go-mod命令"><a href="#1-go-mod命令" class="headerlink" title="(1) go mod命令"></a>(1) go mod命令</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init：生成 <span class="keyword">go</span>.mod 文件</span><br><span class="line"><span class="keyword">go</span> mod download : 下载 <span class="keyword">go</span>.mod 文件中指明的所有依赖</span><br><span class="line"><span class="keyword">go</span> mod tidy: 整理现有的依赖</span><br><span class="line"><span class="keyword">go</span> mod graph: 查看现有的依赖结构</span><br><span class="line"><span class="keyword">go</span> mod edit : 编辑 <span class="keyword">go</span>.mod 文件</span><br><span class="line"><span class="keyword">go</span> mod vendor : 导出项目所有的依赖到vendor目录</span><br><span class="line"><span class="keyword">go</span> mod verify: 校验一个模块是否被篡改过</span><br><span class="line"><span class="keyword">go</span> mod why: 查看为什么需要依赖某模块</span><br></pre></td></tr></table></figure>

<h3 id="2-go-mod环境变量"><a href="#2-go-mod环境变量" class="headerlink" title="(2) go mod环境变量"></a>(2) go mod环境变量</h3><p>可以通过 go env 命令来进行查看</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br><span class="line">GO111MODULE=<span class="string">"auto"</span></span><br><span class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></span><br><span class="line">GONOPROXY=<span class="string">""</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GONOSUMDB=<span class="string">""</span></span><br><span class="line">GOPRIVATE=<span class="string">""</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a><strong>GO111MODULE</strong></h4><p>Go语言提供了 GO111MODULE这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<p><strong>auto：</strong>只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。<br><strong>on：</strong>启用 Go modules，推荐设置，将会是未来版本中的默认值。<br><strong>off：</strong>禁用 Go modules，不推荐设置。<br>可以通过来设置  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a><strong>GOPROXY</strong></h4><p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。</p>
<p>GOPROXY 的默认值是：<a href="https://proxy.golang.org,direct" target="_blank" rel="noopener">https://proxy.golang.org,direct</a></p>
<p>proxy.golang.org国内访问不了,需要设置国内的代理.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">阿里云</span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/goproxy/</span></span><br><span class="line"></span><br><span class="line">七牛云</span><br><span class="line">https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure>

<p>如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bash $ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,direct</span></span><br></pre></td></tr></table></figure>

<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p>
<p>如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.cn,https://mirrors.aliyun.com/goproxy/,direct</span></span><br><span class="line">direct</span><br></pre></td></tr></table></figure>

<p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p>
<p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。</p>
<h4 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a><strong>GOSUMDB</strong></h4><p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。  </p>
<p>GOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p>
<p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p>
<p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p>
<p>格式 1：<SUMDB_NAME>+<PUBLIC_KEY>。<br>格式 2：<SUMDB_NAME>+<PUBLIC_KEY> <SUMDB_URL>。<br>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p>
<p>GONOPROXY/GONOSUMDB/GOPRIVATE<br>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p>
<p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p>
<p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。</p>
<p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPRIVATE=<span class="string">"git.example.com,github.com/eddycjy/mquote"</span></span><br></pre></td></tr></table></figure>

<p>设置后，前缀为 <a href="http://git.xxx.com" target="_blank" rel="noopener">http://git.xxx.com</a> 和 <a href="http://github.com/eddycjy/mquote" target="_blank" rel="noopener">http://github.com/eddycjy/mquote</a> 的模块都会被认为是私有模块。</p>
<p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPRIVATE=<span class="string">"*.example.com"</span></span><br></pre></td></tr></table></figure>

<p>这样子设置的话，所有模块路径为 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 的子域名（例如：<a href="http://git.example.com）都将不经过" target="_blank" rel="noopener">http://git.example.com）都将不经过</a> Go module proxy 和 Go checksum database，需要注意的是不包括 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 本身。</p>
<h2 id="四、使用Go-Modules初始化项目"><a href="#四、使用Go-Modules初始化项目" class="headerlink" title="四、使用Go Modules初始化项目"></a>四、使用Go Modules初始化项目</h2><h3 id="1-开启Go-Modules"><a href="#1-开启Go-Modules" class="headerlink" title="(1) 开启Go Modules"></a>(1) 开启Go Modules</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>又或是可以通过直接设置系统环境变量（写入对应的~/.bash_profile 文件亦可）来实现这个目的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ export GO111MODULE=on</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="(2) 初始化项目"></a>(2) 初始化项目</h3><p>创建项目目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $HOME/aceld/modules_test</span><br><span class="line">$ cd $HOME/aceld/modules_test</span><br></pre></td></tr></table></figure>

<p>执行Go modules 初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init github.com/aceld/modules_test</span><br><span class="line"><span class="keyword">go</span>: creating <span class="built_in">new</span> <span class="keyword">go</span>.mod: module github.com/aceld/modules_test</span><br></pre></td></tr></table></figure>

<p>​ 在执行 go mod init 命令时，我们指定了模块导入路径为 github.com/aceld/modules_test。接下来我们在该项目根目录下创建 main.go 文件，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/aceld/zinx/znet"</span></span><br><span class="line">    <span class="string">"github.com/aceld/zinx/ziface"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ping test 自定义路由</span></span><br><span class="line"><span class="keyword">type</span> PingRouter <span class="keyword">struct</span> &#123;</span><br><span class="line">    znet.BaseRouter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Ping Handle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *PingRouter)</span> <span class="title">Handle</span><span class="params">(request ziface.IRequest)</span></span> &#123;</span><br><span class="line">    <span class="comment">//先读取客户端的数据</span></span><br><span class="line">    fmt.Println(<span class="string">"recv from client : msgId="</span>, request.GetMsgID(), </span><br><span class="line">              <span class="string">", data="</span>, <span class="keyword">string</span>(request.GetData()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再回写ping...ping...ping</span></span><br><span class="line">    err := request.GetConnection().SendBuffMsg(<span class="number">0</span>, []<span class="keyword">byte</span>(<span class="string">"ping...ping...ping"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 创建一个server句柄</span></span><br><span class="line">    s := znet.NewServer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 配置路由</span></span><br><span class="line">    s.AddRouter(<span class="number">0</span>, &amp;PingRouter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 开启服务</span></span><br><span class="line">    s.Serve()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK, 我们先不要关注代码本身,我们看当前的main.go也就是我们的aceld/modules_test项目,是依赖一个叫github.com/aceld/zinx库的. znet和ziface只是zinx的两个模块.</p>
<p>接下来我们在$HOME/aceld/modules_test,本项目的根目录执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/aceld/zinx/znet</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br><span class="line"><span class="keyword">go</span>: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure>

<p>我们会看到 我们的go.mod被修改,同时多了一个go.sum文件.</p>
<h3 id="3-查看go-mod文件"><a href="#3-查看go-mod文件" class="headerlink" title="(3) 查看go.mod文件"></a>(3) 查看go.mod文件</h3><p>aceld/modules_test/go.mod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 <span class="comment">// indirect</span></span><br></pre></td></tr></table></figure>

<p>我们来简单看一下这里面的关键字</p>
<p>module: 用于定义当前项目的模块路径</p>
<p>go:标识当前Go版本.即初始化版本</p>
<p>require: 当前项目依赖的一个特定的必须版本</p>
<p>// indirect: 示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 go get 拉取下来的，也有可能是你所依赖的模块所依赖的.我们的代码很明显是依赖的”github.com/aceld/zinx/znet”和”github.com/aceld/zinx/ziface”,所以就间接的依赖了github.com/aceld/zinx</p>
<h3 id="4-查看go-sum文件"><a href="#4-查看go-sum文件" class="headerlink" title="(4) 查看go.sum文件"></a>(4) 查看go.sum文件</h3><p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54=</span><br><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100/<span class="keyword">go</span>.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:vzj43D7+SQXF/<span class="number">4</span>pzW/hwtAqwc6iTitCiVSaWz5lYuqw=</span><br></pre></td></tr></table></figure>

<p>我们可以看到一个模块路径可能有如下两种：</p>
<p>h1:hash情况</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100 h1:Ez5iM6cKGMtqvIJ8nvR9h74Ln8FvFDgfb7bJIbrKv54=</span><br></pre></td></tr></table></figure>

<p>go.mod hash情况</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100/<span class="keyword">go</span>.mod h1:bMiERrPdR8FzpBOo86nhWWmeHJ1cCaqVvWKCGcDVJ5M=</span><br><span class="line">github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.3</span>/<span class="keyword">go</span>.mod h1:vzj43D7+SQXF/<span class="number">4</span>pzW/hwtAqwc6iTitCiVSaWz5lYuqw=</span><br></pre></td></tr></table></figure>

<p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h2 id="五、修改模块的版本依赖关系"><a href="#五、修改模块的版本依赖关系" class="headerlink" title="五、修改模块的版本依赖关系"></a>五、修改模块的版本依赖关系</h2><p>​ 为了作尝试,假定我们现在都zinx版本作了升级, 由zinx v0.0.0-20200221135252-8a8954e75100 升级到 zinx v0.0.0-20200306023939-bc416543ae24 (注意zinx是一个没有打版本tag打第三方库,如果有的版本号是有tag的,那么可以直接对应v后面的版本号即可)</p>
<p>​ 那么,我们是怎么知道zinx做了升级呢, 我们又是如何知道的最新的zinx版本号是多少呢?</p>
<p>​ 先回到$HOME/aceld/modules_test,本项目的根目录执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/aceld/zinx/znet</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br><span class="line"><span class="keyword">go</span>: found github.com/aceld/zinx/znet in github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br><span class="line"><span class="keyword">go</span>: github.com/aceld/zinx upgrade =&gt; v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br></pre></td></tr></table></figure>

<p>这样我们,下载了最新的zinx, 版本是v0.0.0-20200306023939-bc416543ae24</p>
<p>​ 然后,我么看一下go.mod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 <span class="comment">// indirect</span></span><br></pre></td></tr></table></figure>

<p>我们会看到,当我们执行go get 的时候, 会自动的将本地将当前项目的require更新了.变成了最新的依赖.</p>
<p>好了, 现在我们就要做另外一件事,就是,我们想用一个旧版本的zinx. 来修改当前zinx模块的依赖版本号.</p>
<p>目前我们在$GOPATH/pkg/mod/github.com/aceld下,已经有了两个版本的zinx库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">go</span>/pkg/mod/github.com/aceld$ ls</span><br><span class="line">zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br><span class="line">zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24</span><br></pre></td></tr></table></figure>

<p>​ 目前,我们/aceld/modules_test依赖的是<a href="mailto:zinx@v0.0.0-20200306023939-bc416543ae24">zinx@v0.0.0-20200306023939-bc416543ae24</a> 这个是最新版, 我们要改成之前的版本<a href="mailto:zinx@v0.0.0-20200306023939-bc416543ae24">zinx@v0.0.0-20200306023939-bc416543ae24</a>.</p>
<p>​ 回到/aceld/modules_test项目目录下,执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod edit -replace=zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24=zinx@v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure>

<p>​ 然后我们打开go.mod查看一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module github.com/aceld/modules_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require github.com/aceld/zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 <span class="comment">// indirect</span></span><br><span class="line"></span><br><span class="line">replace zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200306023939</span>-bc416543ae24 =&gt; zinx v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200221135252</span><span class="number">-8</span>a8954e75100</span><br></pre></td></tr></table></figure>

<p>​ 这里出现了replace关键字.用于将一个模块版本替换为另外一个模块版本。</p>
<p>文章参考：<a href="https://zhuanlan.zhihu.com/p/113506780" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113506780</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB中各种类型的索引</title>
    <url>/post/579789855.html</url>
    <content><![CDATA[<p>MongoDB 中索引的类型大致包含单键索引、复合索引、多键值索引、地理索引、全文索引、 散列索引等，下面简单介绍各类索引的用法。</p>
<h3 id="1、单字段索引"><a href="#1、单字段索引" class="headerlink" title="1、单字段索引"></a>1、单字段索引</h3><p>这个是最简单最常用的索引类型，比如我们上边的例子，为id建立一个单独的索引就是此种类型。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 为id field建立索引，1表示升序，-1表示降序，没有差别</span></span><br><span class="line">db.employee.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>需要注意的是通常MongoDB会自动为我们的文档插入’_id’ field，且已经按照升序进行索引，如果我们插入的文档中包含有’_id’ field，则MongoDB就不会自动创建’_id’ field，但是需要我们自己来保证唯一性从而唯一标识一个文档</p>
<h3 id="2、复合索引"><a href="#2、复合索引" class="headerlink" title="2、复合索引"></a>2、复合索引</h3><p><img src="https://img-blog.csdnimg.cn/20200503234104706.png" alt="在这里插入图片描述"><br>上图查询索引的时候会先查询userid，再查询score，然后就可以找到对应的文档。<br>对于复合索引需要注意以下几点：</p>
<p><strong>索引field的先后顺序很关键，影响有两方面</strong>：<br>1、MongoDB在复合索引中是根据prefix排序查询，就是说排在前面的可以单独使用。<br>我们创建一个如下的索引</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'city'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>我们如下的查询可以利用索引</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure>
<p>但是如下的查询无法利用该索引</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;<span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure>

<p>还有一种特殊的情况，就是如下查询：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;<span class="string">'id'</span>: xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure>

<p>这个查询也可以利用索引的前缀’id’来查询，但是却不能针对score进行查询，你可以说是部分利用了索引，因此其效率可能不如如下索引：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>2.过滤出的document越少的field越应该放在前面，比如此例中id如果是唯一的，那么就应该放在最前面，因为这样通过id就可以锁定唯一一个文档。而如果通过city或者score过滤完成后还是会有大量文档，这就会影响最终的性能。</p>
<p><strong>索引的排序顺序不同</strong><br>复合索引最末尾的field，其排序顺序不同对于MongoDB的查询排序操作是有影响的。<br>比如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.events.createIndex( &#123; username: <span class="number">1</span>, date: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>这种情况下， 如下的query可以利用索引：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>但是如下query则无法利用index进行排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<h3 id="3、多键值索引"><a href="#3、多键值索引" class="headerlink" title="3、多键值索引"></a>3、多键值索引</h3><p>这个主要是针对数据类型为数组的类型，如下示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span> : <span class="string">"jack"</span>, <span class="string">"age"</span> : <span class="number">19</span>, habbit: [<span class="string">"football, runnning"</span>]&#125;</span><br><span class="line">db.person.createIndex( &#123;habbit: <span class="number">1</span>&#125; )  <span class="comment">// 自动创建多key索引</span></span><br><span class="line">db.person.find( &#123;habbit: <span class="string">"football"</span>&#125; )</span><br></pre></td></tr></table></figure>

<h3 id="4、散列索引"><a href="#4、散列索引" class="headerlink" title="4、散列索引"></a>4、散列索引</h3><p>散列（Hashed）索引是指按照某个字段的散列值来建立索引，目前主要用于 MongoDB Sharded Cluster 的散列分片，散列索引只能用于字段完全匹配的查询，不能用于范围查询等。<br>散列其语法如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.collection.createlndex( &#123; _id : <span class="string">"hashed"</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>MongoDB 支持散列任何单个字段的索引，但是不支持多键（即数组）索引。</p>
<p>需要说明的是，MongoDB 在进行散列索引之前，需要将浮点数截断为 64 位整数。例如，散列将对 2.3、2.2 和 2.9 这些值产生同样的返回值。</p>
<h3 id="5、过期索引"><a href="#5、过期索引" class="headerlink" title="5、过期索引"></a>5、过期索引</h3><p>顾名思义，过期索引就是一种会过期的索引，在索引过期之后，索引对应的数据会被删除，创建方式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;time:<span class="number">1</span>&#125;,&#123;expireAfterSeconds:<span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>expireAfterSeconds表示索引的过期时间，单位为秒。time表示索引的字段，time的数据类型必须是ISODate或者ISODate数组，否则的话，当索引过期之后，time的数据就不会被删除。</p>
<h3 id="6、全文索引"><a href="#6、全文索引" class="headerlink" title="6、全文索引"></a>6、全文索引</h3><p>全文索引虽然好用，可惜不支持中文，我们这里就先做一个简单的了解。</p>
<p>比如，我的数据集如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc3189"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java C# Python PHP"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318a"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java C#"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318b"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"Java Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a3da1f9e8e181ffc318c"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"PHP Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5a4541f9e8e181ffc318d"</span>),</span><br><span class="line">    <span class="string">"x"</span> : <span class="string">"C C++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以给x字段建立一个全文索引，创建方式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:<span class="string">"text"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>MongoDB会自动对x字段的数据进行分词，然后我们就可以通过如下语句进行查询：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"Java"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>此时x中包含Java的文档都会被查询出来。如果想查询既包含Java又包含C#的文档，操作如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"\"Java C#\""</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>用一对双引号将查询条件括起来，如果想查询包含PHP或者Python的文档，操作如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想查询既有PHP，又有Python，但是又不包括Java的文档，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python -Java"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>建立了全文索引之后，我们也可以查看查询结果的相似度，使用$meta，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;,&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>此时查询结果中会多出一个score字段，该字段的值越大，表示相似度越高，我们可以根据score利用sort来对其进行排序，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:<span class="string">"PHP Python"</span>&#125;&#125;,&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;).sort(&#123;score:&#123;$meta:<span class="string">"textScore"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>全文索引目前看起来功能还是很强大，可惜暂时不支持中文，不过网上对此也有很多解决方案，小伙伴们可以自行搜索查看。</p>
<h3 id="7、地理空间索引"><a href="#7、地理空间索引" class="headerlink" title="7、地理空间索引"></a>7、地理空间索引</h3><p>地理空间索引类型<br><strong>地理空间索引可以分为两类：</strong></p>
<p>1.<strong>2d索引</strong>，可以用来存储和查找平面上的点。<br>2.<strong>2d sphere索引</strong>，可以用来存储和查找球面上的点。</p>
<h4 id="2d索引"><a href="#2d索引" class="headerlink" title="2d索引"></a><strong>2d索引</strong></h4><p>2d索引一般我们可以用在游戏地图中。<br>向集合中插入一条记录点的数据：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;x:[<span class="number">90</span>,<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>插入数据的格式为[经度,纬度]，取值范围，经度[-180,180]，纬度[-90,90]。数据插入成功之后，我们先通过如下命令创建索引：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:<span class="string">"2d"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>然后通过$near我们可以查询某一个点附近的点，如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[<span class="number">90</span>,<span class="number">0</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>默认情况下返回该点附近100个点，我们可以通过$maxDistance来设置返回的最远距离：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[<span class="number">90</span>,<span class="number">0</span>],$maxDistance:<span class="number">99</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>我们也可以通过$geoWithin查询某个形状内的点，比如查询矩形中的点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$box:[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">91</span>,<span class="number">1</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>两个坐标点用来确定矩形的位置。</p>
<p>查询圆中的点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$center:[[<span class="number">0</span>,<span class="number">0</span>],<span class="number">90</span>]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>参数分别表示圆的圆心和半径。</p>
<p>查询多边形中的点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$polygon:[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">100</span>,<span class="number">0</span>],[<span class="number">100</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里可以填入任意多个点，表示多边形中的各个点。</p>
<h4 id="2d-sphere索引"><a href="#2d-sphere索引" class="headerlink" title="2d sphere索引"></a><strong>2d sphere索引</strong></h4><p>2dsphere适用于球面类型的地图，它的数据类型是GeoJSON格式的，我们可以在<a href="http://geojson.org/地址上查看GeoJSON格式的样式，比如我们描述一个点，GeoJSON如下：" target="_blank" rel="noopener">http://geojson.org/地址上查看GeoJSON格式的样式，比如我们描述一个点，GeoJSON如下：</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e0571f9e8e181ffc3196"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"shenzhen"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"Point"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            <span class="number">90.0</span>, </span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>描述线，GeoJSON格式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e0d01f9e8e181ffc3199"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"shenzhen"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"LineString"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">0.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">1.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="number">90.0</span>, </span><br><span class="line">                <span class="number">2.0</span></span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>描述多边形，GeoJSON格式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : ObjectId(<span class="string">"59f5e3f91f9e8e181ffc31d0"</span>),</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"beijing"</span>,</span><br><span class="line">    <span class="string">"location"</span> : &#123;</span><br><span class="line">        <span class="string">"type"</span> : <span class="string">"Polygon"</span>,</span><br><span class="line">        <span class="string">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">1.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">1.0</span>, </span><br><span class="line">                    <span class="number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="number">0.0</span>, </span><br><span class="line">                    <span class="number">1.0</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他的类型，具体小伙伴们可以参考<a href="http://geojson.org/。有了数据之后，我们可以通过如下操作来创建地理空间索引了：" target="_blank" rel="noopener">http://geojson.org/。有了数据之后，我们可以通过如下操作来创建地理空间索引了：</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;location:<span class="string">"2dsphere"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>比如我想查询和深圳这个区域有交集的文档，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$geoIntersects:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里的查询结果是和深圳这个区域有交集的都会查到(比如经过深圳的高速公路、铁路等)，我们也可以只查询深圳市内的区域(比如深圳市内所有的学校)，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以查询腾讯附近的其他位置，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> QQ = db.sang_collect.findOne(&#123;name:<span class="string">"QQ"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$near:&#123;$geometry:QQ.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>复合地理空间索引<br>位置往往只是我们查询的一个条件，比如我要查询深圳市内所有的学校，那我得再增加一个查询条件，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shenzhen = db.sang_collect.findOne(&#123;name:<span class="string">"shenzhen"</span>&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;,name:<span class="string">"QQ"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>其他的查询条件跟在后面就行了。</p>
<p>参考文章：<br><a href="https://blog.csdn.net/u012702547/article/details/81027421" target="_blank" rel="noopener">https://blog.csdn.net/u012702547/article/details/81027421</a><br><a href="https://www.jianshu.com/p/2b09821a365d" target="_blank" rel="noopener">https://www.jianshu.com/p/2b09821a365d</a><br><a href="http://c.biancheng.net/view/6558.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6558.html</a></p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB-分片片键</title>
    <url>/post/1182994018.html</url>
    <content><![CDATA[<h2 id="1．分片"><a href="#1．分片" class="headerlink" title="1．分片"></a>1．分片</h2><p>   分片是什么？分片就是将数据存储在多个机器上。当数据集超过单台服务器的容量，服务器的内存，磁盘IO都会有问题，即超过单台服务器的性能瓶颈。此时有两种解决方案，垂直扩展和水平扩展（分片）。 </p>
<p>  垂直扩展就是增加CPU，增加容量，但高性能系统的CPU和容量不成比例，这样扩展成本大，并且有上限。      </p>
<p>  水平扩展分片，将数据分发到多个服务器，每个服务器是一个单独的数据库，各个服务器加起来组成一个逻辑数据库，把写压力和操作分流到不同服务器，提高容量和吞吐量。  </p>
<p>  MongoDB的文档是无模式的，不固定结构，因此只能进行水平分片。当块超过指定大小或者文档数超过最大文档数，MongoDB尝试分割这个块，若分割成功，把它标记为一个大块避免重复分割。拆分块的关键就是片键，下面介绍常见片键的种类。</p>
<h2 id="2．片键种类"><a href="#2．片键种类" class="headerlink" title="2．片键种类"></a>2．片键种类</h2><p>  片键是文档的一个属性字段或者一个复合索引字段，一旦建立不能改变。片键是分片拆分数据的关键，片键的选择直接影响集群的性能。  </p>
<p>  MongoDB首先根据片键划分块chunks当块超过指定大小（默认64M），然后把块分到其他的分片上，片键类型主要有以下几种：    </p>
<p>  注意：片键也是查询时常用的一个索引。</p>
<h3 id="（1）-递增片键"><a href="#（1）-递增片键" class="headerlink" title="（1） 递增片键"></a>（1） 递增片键</h3><p>   这类片键比较常见，比如使用时间戳，日期，自增的主键，ObjectId，_id等，此类片键的写入操作集中在一个分片服务器上，写入不具有分散性，这会导致单台服务器压力较大，但分割比较容易，这台服务器可能会成为性能瓶颈。  </p>
<p>递增片键的创建，对foo数据库的bar集合使用timestamp时间戳分片  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mongos&gt; use foo</span><br><span class="line">mongos&gt; db.bar.ensureIndex(&#123;"timestamp":1&#125;)</span><br><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.bar",&#123;"timestamp":1&#125;)</span><br><span class="line">&#123; "collectionsharded" : "foo.bar", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）-哈希片键"><a href="#（2）-哈希片键" class="headerlink" title="（2） 哈希片键"></a>（2） 哈希片键</h3><p>   使用一个哈希索引字段作为片键，优点是使数据在各节点分布比较均匀，数据写入可随机分发到每个分片服务器上，把写入的压力分散到了各个服务器上。但是读也是随机的，可能会命中更多的分片，一般具有随机性的片键（如密码，哈希，MD5）查询隔离性能比较差。   </p>
<p>哈希片键的创建，对GridFS的chunks集合使用files_id哈希分片</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mongos&gt; db.bar.ensureIndex(&#123;"files_id":"hashed"&#125;)</span><br><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.fs.chunks",&#123;"files_id":"hashed"&#125;)</span><br><span class="line">&#123; "collectionsharded" : " foo.fs.chunks ", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）-组合片键"><a href="#（3）-组合片键" class="headerlink" title="（3） 组合片键"></a>（3） 组合片键</h3><p>  数据库中没有比较合适的片键供选择，或者是打算使用的片键基数太小（即变化少如星期只有7天可变化），可以选另一个字段使用组合片键，甚至可以添加冗余字段来组合。一般是粗粒度+细粒度进行组合。 </p>
<p>组合片键的创建，对GridFS的chunks集合使用files_id和n组合分片</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.enableSharding("foo")</span><br><span class="line">&#123; "ok" : 1 &#125;</span><br><span class="line">mongos&gt; sh.shardCollection("foo.fs.chunks",&#123;"files_id":1, "n":1&#125;)</span><br><span class="line">&#123; "collectionsharded" : " foo.fs.chunks ", "ok" : 1 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）-标签分片"><a href="#（4）-标签分片" class="headerlink" title="（4） 标签分片"></a>（4） 标签分片</h3><p>  数据存储在指定的分片服务器上，可以为分片添加tag标签，然后指定相应的tag，比如让10.<em>.</em>.<em>(T)出现在shard0000上，11.</em>.<em>.</em>(Q)出现在shard0001或shard0002上，就可以使用tag让均衡器指定分发。</p>
<p>标签分片的创建</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mongos &gt; sh.addShardTag("shard0000", "T")</span><br><span class="line">mongos &gt; sh.addShardTag("shard0001", "Q")</span><br><span class="line">mongos &gt; sh.addShardTag("shard0002", "Q")</span><br><span class="line">mongos&gt; sh.addTagRange("foo.ips",&#123; "ip": "010.000.000.000 ", … , "ip": "011.000.000.000 "&#125;&#125;, "T")</span><br><span class="line">mongos&gt; sh.addTagRange("foo.ips",&#123; "ip": "011.000.000.000 ", … , "ip": "012.000.000.000 "&#125;&#125;, "Q")</span><br></pre></td></tr></table></figure>

<h3 id="3．片键选择策略"><a href="#3．片键选择策略" class="headerlink" title="3．片键选择策略"></a>3．片键选择策略</h3><p>   大致了解了片键的种类，那么怎么选择片键呢？无非从两个方面考虑，数据的查询和写入，最好的效果就是数据查询时能命中更少的分片，数据写入时能够随机的写入每个分片，关键在于如何权衡性能和负载。  </p>
<p>如何选择片键主要从下面几个问题考虑：<br>（1）首先确定一个经常性查询的字段<br>（2）找到影响这些操作性能的关键点<br>（3）如果选的字段基数比较小，添加一个粒度细的字段  </p>
<p>   怎么选择，如何权衡，跟具体的业务以及数据类型都有关系，具体问题具体分析。</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB之分片集群与复制集</title>
    <url>/post/3134727742.html</url>
    <content><![CDATA[<h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p>分片集群是将数据存储在多台机器上的操作，主要由查询路由mongos、分片、配置服务器组成。<br>●查询路由根据配置服务器上的元数据将请求分发到相应的分片上，本身不存储集群的元数据，只是缓存在内存中。<br>●分片用来存储数据块。数据集根据分片键将集合分割为数据块，存储在不同的分片上。在生产环境下，通常一个分片由一个复制集组成。<br>●配置服务器存储集群的元数据，包括数据与分片的映射关系，配置服务器一旦挂掉，集群将无法工作。<br><strong>注意：</strong><br>●当mongos重启时，会从配置服务器读取元数据更新自己缓存的元数据<br>●当分割数据时或者在分片间移动数据时会写配置服务器。<br>●在分片集群中，配置服务器可以采用复制集的架构，但复制集中不允许有仲裁节点和延时节点，且buildindexes必须设为true。<br>●集合的数据分布在多个分片上，如果某个分片失效，查询会返回错误，可以通过为查询指定partial选项，允许接受不完整的数据<br><strong>作用</strong><br><strong>单台机器无法满足存储需求，内存、磁盘空间不够，读写吞吐量不够。</strong></p>
<h3 id="1-2、如何维护数据均衡分布"><a href="#1-2、如何维护数据均衡分布" class="headerlink" title="1.2、如何维护数据均衡分布"></a>1.2、如何维护数据均衡分布</h3><p><strong>集群使用分割器和平衡器两个后台进程维护数据均匀分布。</strong></p>
<h4 id="分割器"><a href="#分割器" class="headerlink" title="分割器"></a>分割器</h4><p>●分割器的作用是防止数据块变大，数据块大小默认是64MB，当超过64MB时，分割器会将其一分为二。<br>●分割的对象不是实际的数据，而是元数据，只是在逻辑上进行逻辑块的划分，不会影响到实际数据的分布<br>●数据块太小会产生大量块，容易使集群不平衡，导致数据块频繁移动，降低集群性能，元数据增加，降低查询效率<br>●数据块太大，会减小移动频率，元数据少，有利于数据查询，但一旦移动，会花费很长时间<br>●并不是所有的集合都会分片，没有被分片的集合都存储在同一个主分片上<br>●只有对数据库和集合开启分片后，数据才会在不同分片上分布，否则只存储在主分片上<br>●插入和更新操作都有可能引发分割  </p>
<h4 id="平衡器"><a href="#平衡器" class="headerlink" title="平衡器"></a>平衡器</h4><p>●平衡器的作用是管理数据块的移动。<br>●当集群中数据块的分布达到移动阈值时，平衡器会移动数据块。<br>●增加或减少分片或增删数据也会使平衡器移动数据块  </p>
<h3 id="1-3数据块如何存储在相应分片上"><a href="#1-3数据块如何存储在相应分片上" class="headerlink" title="1.3数据块如何存储在相应分片上"></a>1.3数据块如何存储在相应分片上</h3><p>每个需要被分片的集合都需要指定索引字段作为分片键，mongodb使用<strong>区间分区</strong>或<strong>哈希分区</strong>算法根据分片键将数据分割为数据块。  </p>
<h4 id="区间分区"><a href="#区间分区" class="headerlink" title="区间分区"></a>区间分区</h4><p><strong>数据块覆盖一段子区间，任何分片键都会被某一段覆盖</strong><br><strong>优缺点</strong><br><strong>区间分区支持更好的range查询，通过分片键查询，查询路由可以很容易的判断出哪些数据块含有查询需要数据，并将请求分配到的分片上。</strong><br><strong>区间分区使数据分布不均匀</strong>  </p>
<h4 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h4><p><strong>根据分片键的哈希值进行数据的分配。<br>优缺点<br>数据随机分配到不同的数据块<br>在进行range查询时，由于相邻数据分布在不同分片上，导致访问很多分片</strong><br><strong>注意</strong><br>●分片键不能是多键索引，即索引字段的值不能是数组<br>●分片键一旦被指定，不能被修改为其他字段，同时分片键的字段值也不能被修改<br>●如果集群的写操作比较多，可以使用哈希分区，将数据均匀分配到节点上，将写操作均匀应用与集群，<br>如果集群读操作比较多，可以使用区间分区，将相邻数据分到同一节点上，便于查询<br>●如果查询时没有指定索引字段，查询路由会将请求分发到所有节点上，等待返回结果，查询效率低<br>如果查询时指定了索引字段，查询路由会将请求分发到少数节点上，查询效率高  </p>
<h3 id="1-4、数据迁移过程"><a href="#1-4、数据迁移过程" class="headerlink" title="1.4、数据迁移过程"></a>1.4、数据迁移过程</h3><p>●平衡器向源节点发送movechunk指令<br>●源节点移动指定数据块，在迁移期间，数据块的读写操作仍路由到源节点<br>●目的节点如果没有需要的索引，此时会构建索引<br>●目的节点开始请求数据块中的数据，保存在本地<br>●在迁移期间，源节点上的数据如果发生变化，在迁移完之后，目的节点会同步源节点上变更的数据<br>●同步结束后，目的节点会与配置服务器建立连接，配置服务器更新元数据，此期间源节点阻塞写操作<br>●源节点上的旧数据被删除  </p>
<h3 id="1-5、备份数据"><a href="#1-5、备份数据" class="headerlink" title="1.5、备份数据"></a>1.5、备份数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongodump -h dbhost -d dbname -o directory 命令格式</span><br><span class="line">mongodump -h 127.0.0.1：28002 -d <span class="built_in">test</span> -o /home/backup</span><br></pre></td></tr></table></figure>

<p>将本机数据库test中数据备份到/home/backup下<br>恢复数据<br>mongorestore -h dbhost -d dbname –directoryperdb dbdirectory dbdirectory为备份数据所在位置  </p>
<h2 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h2><h3 id="2-1、概念与特性"><a href="#2-1、概念与特性" class="headerlink" title="2.1、概念与特性"></a>2.1、概念与特性</h3><p><strong>概念<br>复制集是一组具有相同数据的mongod实例，包含主节点以及从节点。集群中任何时候只有一个主节点，主节点将数据变更操作写到oplog（封顶表）中，从节点读取oplog，并将oplog中的操作应用的本地数据，从而实现数据同步。</strong>  </p>
<p><strong>特性</strong><br>●<strong>异步复制</strong><br>从节点并不是实时复制主节点中的数据<br><strong>●自动容灾</strong><br>主节点宕机，主动发起选举<br><strong>●读操作</strong><br>从从节点上读到的数据可能并不是最新的  </p>
<h3 id="2-2、复制集成员"><a href="#2-2、复制集成员" class="headerlink" title="2.2、复制集成员"></a>2.2、复制集成员</h3><p>复** <strong>制集最多包含</strong>50个节点<strong>，最多</strong>只能有7个可以投票<strong>。包含以下节点类型<br>●</strong>主节点primary**<br>可以执行读写操作，所有节点均可以执行读操作。默认情况下，读请求只会发送给主节点，可以通过read preference设置。主节点的优先级priority至少为1。<br>●<strong>从节点secondary</strong><br>只可以执行读操作。从节点通过与主节点同步，实现备份数据的功能，复制集至少有一个从节点。通过配置复制集的配置文件可以设置从节点是否参与选举（vote=0）以及是否可以被选举为主节点（priority=0）优先级priority为0的节点不能发起选举，不能被选举为主节点，但可以投票。<br>●<strong>隐藏节点</strong><br>通过设置从节点的hidden属性，可以对客户端隐藏节点，不接受读写请求，无法被选举为主节点（priority=0），只能投票，主要用于备份数据。<br>●<strong>延时节点</strong><br>通过设置隐藏节点的slaveDelay属性可以使节点延时一定时间从主节点复制数据，可以起到保护数据的作用。延时节点是在隐藏节点的基础上，多了一个延时属性。<br>●<strong>仲裁节点Arbiter</strong><br>本身不存储数据，不能被选举为主节点，只能投票，仲裁节点主要用于使复制集中节点个数为奇数，从而容易达到多数派。仲裁节点只消耗极少的资源，但不要与主节点、从节点部署在同一个物理节点上。<br>●<strong>非投票节点</strong><br>不参与投票，但存储数据，可以接受读操作  </p>
<h3 id="2-3、复制集管理"><a href="#2-3、复制集管理" class="headerlink" title="2.3、复制集管理"></a>2.3、复制集管理</h3><p>●use admin切换到admin数据库<br>●config={_id:”myset”,members:[{“_id”:0,”host”:”127.0.0.1:28001”,”priority”:2},{“_id”:1,”host”:”127.0.0.1:28002”,”priority”:1}]}<br>●rs.initiate(config)<br>修改复制集配置<br>●cfg=rs.conf()<br>●cfg.members[0].priority=1<br>●rs.reconfig(cfg)<br>复制集维护<br>将配置文件中的replset注释掉，从而以单机模式启动复制集，维护完毕后再加入复制集。  </p>
<h3 id="2-4、大多数原则"><a href="#2-4、大多数原则" class="headerlink" title="2.4、大多数原则"></a>2.4、大多数原则</h3><p><strong>概念</strong><br>如果复制集中的节点个数为N，则大多数为N/2+1（N/2向下取整），当复制集中存活节点数小于大多数时，不存在主节点，无法提供写服务。    </p>
<p><strong>作用</strong><br>大多数原则保证了，在任何时刻复制集中的主节点个数不会超过一个。比如复制集部署在两个机房，两个机房通信发生故障，不含有主节点的机房会选举出一个主节点，等到故障恢复，复制集就会存在两个主节点，无法保证数据的一致性。  </p>
<h3 id="2-5、选举"><a href="#2-5、选举" class="headerlink" title="2.5、选举"></a>2.5、选举</h3><p><strong>选举的前提条件</strong><br>复制集满足大多数原则。在选举的过程中，复制集无法进行写操作。  </p>
<p><strong>何时会引发选举</strong><br>●复制集初始化时或被重新配置后<br>●主节点宕机或主节点网络不可达，即大多数节点无法连接主节点<br>●人为将主节点降为从节点，执行rs.stepDown(n)命令<br>●有更高优先级的节点加入复制集  </p>
<p><strong>选举特点</strong><br>●优先级高的节点优先被选为主节点<br>●具有最高optime的节点被选为主节点<br>●如果优先级高的节点不具有最新的optime，那么首先会同步主节点的oplog<br>●优先级为0的节点无法发起选举，且无法成为主节点，只能投票。<br>●所有成员都可以否决选举，包括不投票的节点Non-voting  </p>
<p><strong>何时否决选举</strong><br>●发起选举的节点不包含最新数据<br>●发起选举的节点优先级比其他节点低<br>●发起选举的节点没有持有最高的optime  </p>
<h3 id="2-6、数据回滚"><a href="#2-6、数据回滚" class="headerlink" title="2.6、数据回滚"></a>2.6、数据回滚</h3><p>概念：在主节点失效之前，从节点并未全部复制主节点上的数据，原先的主节点在选举出新的主节点后重新加入复制集，会导致旧主节点与新主节点数据不一致，旧主节点会将不一致的数据回滚，从而与主节点数据保持一致。  </p>
<p>避免数据回滚<br>默认情况下，在主节点上写入成功后，就会向客户端返回结果，可能造成回滚，客户端可以修改写策略writeconcern为向大多数节点写入成功后才返回结果。  </p>
<h3 id="2-7、读写策略"><a href="#2-7、读写策略" class="headerlink" title="2.7、读写策略"></a>2.7、读写策略</h3><p>writeconcern：不等待主节点写入成功，客户端就返回结果；等待主节点写入成功，就返回结果；等到大多数节点写入成功，才返回结果<br>readconcern：只读主节点、只读从节点、优先主节点、优先从节点、读网络延迟最小的节点  </p>
<h3 id="2-8、复制集优缺点"><a href="#2-8、复制集优缺点" class="headerlink" title="2.8、复制集优缺点"></a>2.8、复制集优缺点</h3><p><strong>优点</strong><br>●自动容灾。主节点宕机，通过投票选举主节点，保证数据安全<br>●自动备份数据，无需人工干预<br>●易于扩展<br>●数据可靠性高<br><strong>缺点</strong><br>●消耗资源高<br>●不能解决负载均衡的问题<br>●客户端读到的数据可能并未持久化 ，比如：客户端可以读到最新写入的数据，但数据有可能存在磁盘写入失败的可能；客户端读到的数据可能发生rolled back  </p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>vagrant虚拟机共享目录加速</title>
    <url>/post/1735609695.html</url>
    <content><![CDATA[<p>vagrant一般都是搭配VirtualBox虚拟机的，但是vagrant默认启动VirtualBox虚拟机的目录共享方式是VirtualBox方式，这种方式性能差，如果文件夹里面的文件数量不多的情况下影响还不是很大，如果数量多的话会很慢，网上说的可以通过安装vagrant一款插件使共享目录以”nfs”方式，速度会变快很多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant plugin install vagrant-winnfsd</span><br></pre></td></tr></table></figure>
<p>但是我实际上发现还有另外一款vagrant插件能使共享目录性能更高。<br>这款插件不但能使共享目录支持”nfs”方式而且还有其他系统优化，使实际共享目录性能更高。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br></pre></td></tr></table></figure>

<p>不管是哪一款vagant插件都需要在对应的共享目录后面加”, type: “nfs””才能生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config.vm.synced_folder <span class="string">"D:/xiangmu"</span>,<span class="string">"/home/wwwroot"</span> , <span class="built_in">type</span>: <span class="string">"nfs"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>mongodb添加账号密码</title>
    <url>/post/2802551252.html</url>
    <content><![CDATA[<p>添加账号密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user:<span class="string">"root"</span>,<span class="built_in">pwd</span>:<span class="string">""</span>,roles:[<span class="string">"root"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.createUser(&#123;user:<span class="string">'root'</span>,<span class="built_in">pwd</span>:<span class="string">'root'</span>,roles:[<span class="string">'readWrite'</span>]&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装mongodb和设置开机自动启动</title>
    <url>/post/2911353081.html</url>
    <content><![CDATA[<h2 id="1、安装mongod"><a href="#1、安装mongod" class="headerlink" title="1、安装mongod"></a>1、安装mongod</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.5.tgz</span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-4.2.5.tgz</span><br><span class="line">mv mongodb-linux-x86_64-rhel70-4.2.5/ /usr/<span class="built_in">local</span>/mongodb</span><br><span class="line"></span><br><span class="line">mkdir  -p  /usr/<span class="built_in">local</span>/mongodb/data</span><br><span class="line">mkdir  -p  /usr/<span class="built_in">local</span>/mongodb/logs</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/mongodb/bin/mongod mongod</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/mongodb/bin/mongo mongo</span><br></pre></td></tr></table></figure>

<h2 id="2、设置开机自动启动"><a href="#2、设置开机自动启动" class="headerlink" title="2、设置开机自动启动"></a>2、设置开机自动启动</h2><h3 id="1、新增sh脚本"><a href="#1、新增sh脚本" class="headerlink" title="1、新增sh脚本"></a>1、新增sh脚本</h3><p>添加关联mongodb.conf文件<br>vim /etc/mongodb.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net:</span><br><span class="line">  port: 27017</span><br><span class="line">  bindIp: 0.0.0.0  <span class="comment"># Listen to local interface only, comment to listen on all interfaces.</span></span><br><span class="line">  ipv6: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>新增sh脚本放在根目录的shell下面mongod_start.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># pkill -9 mongod;</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongod --shutdown --dbpath /usr/<span class="built_in">local</span>/mongodb/data/;</span><br><span class="line">nohup /usr/<span class="built_in">local</span>/mongodb/bin/mongod  -f /etc/mongodb.conf --dbpath=/usr/<span class="built_in">local</span>/mongodb/data --logpath=/usr/<span class="built_in">local</span>/mongodb/logs/log.txt  &gt; /shell/mongod.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>设置权限777</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 mongod_start.sh</span><br></pre></td></tr></table></figure>

<h3 id="2、添加脚本到开机自启动"><a href="#2、添加脚本到开机自启动" class="headerlink" title="2、添加脚本到开机自启动"></a>2、添加脚本到开机自启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p>文件后面追加<br>sh /shell/mongod_start.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p>然后就搞定了</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>submit text3批量选中指定关键词的所有行</title>
    <url>/post/1152603659.html</url>
    <content><![CDATA[<p><strong>如下数据,想选中关键词为:_id: ObjectId(“,的所有行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.getCollection("goods").insert([ &#123;</span><br><span class="line">    _id: ObjectId(<span class="string">"5e9d165dad06000091003a57"</span>),</span><br><span class="line">    <span class="keyword">name</span>: <span class="string">"哈士奇饼干1"</span>,</span><br><span class="line">    price: <span class="number">33</span></span><br><span class="line">&#125; ]);</span><br><span class="line">db.getCollection("goods").insert([ &#123;</span><br><span class="line">    _id: ObjectId(<span class="string">"5e9d165dad06000091003a58"</span>),</span><br><span class="line">    <span class="keyword">name</span>: <span class="string">"神奇宝贝一只1"</span>,</span><br><span class="line">    stock: <span class="number">100</span>,</span><br><span class="line">    price: <span class="number">20.58</span></span><br><span class="line">&#125; ]);</span><br></pre></td></tr></table></figure>

<p><strong>1、选择任意一个”_id: ObjectId(“”后Ctrl+F出现搜索界面，然后按下Find All,这时就会选中所有”_id: ObjectId(“”的关键词。</strong></p>
<p><strong>2、按下Ctrl+L即可选中所有包含关键词”_id: ObjectId(“”的行。</strong></p>
]]></content>
      <categories>
        <category>编程琐碎</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB基本操作之CRUD</title>
    <url>/post/1234652124.html</url>
    <content><![CDATA[<h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>命令有三种:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建单个文档：db.collection.insertOne()</span><br><span class="line">创建单个或多个文档：db.collection.insert()</span><br><span class="line">创建多个文档：db.collection.insertMany()</span><br></pre></td></tr></table></figure>

<h4 id="insertOne"><a href="#insertOne" class="headerlink" title="insertOne"></a>insertOne</h4><p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.goods.insertOne(&#123;</span><br><span class="line">	name:"哈士奇饼干",</span><br><span class="line">	price:33,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "acknowledged": true,</span><br><span class="line">    "insertedId": ObjectId("5e9c52e32a170000ea003e5a") //5e9c544c2a170000ea003e5b为本次插入数据的主键id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入复合主键</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.goods.insertOne(&#123;</span><br><span class="line">    _id:&#123;id:123,type:'shop'&#125;,</span><br><span class="line">	name:"这个是复合组件",</span><br><span class="line">	price:20.58,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="insertMany"><a href="#insertMany" class="headerlink" title="insertMany"></a>insertMany</h4><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.goods.insertMany([</span><br><span class="line">	&#123;name:"哈士奇饼干1",price:33,&#125;,</span><br><span class="line">	&#123;name:"神奇宝贝一只1",stock:100,price:20.58,&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "acknowledged": true,</span><br><span class="line">    "insertedIds": [</span><br><span class="line">        ObjectId("5e9c56b72a170000ea003e5d"),</span><br><span class="line">        ObjectId("5e9c56b72a170000ea003e5e")</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.goods.insert([</span><br><span class="line">	&#123;<span class="keyword">name</span>:<span class="string">"哈士奇饼干1"</span>,price:<span class="number">33</span>,&#125;,</span><br><span class="line">	&#123;<span class="keyword">name</span>:<span class="string">"神奇宝贝一只1"</span>,stock:<span class="number">100</span>,price:<span class="number">20.58</span>,&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">BulkWriteResult(&#123;</span><br><span class="line">	"nRemoved" : 0,</span><br><span class="line">	"nInserted" : 2, //插入成功的数量</span><br><span class="line">	"nUpserted" : 0,</span><br><span class="line">	"nMatched" : 0,</span><br><span class="line">	"nModified" : 0,</span><br><span class="line">	"writeErrors" : [ ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="读取全部文档"><a href="#读取全部文档" class="headerlink" title="读取全部文档"></a>读取全部文档</h4><p>既不筛选，也不投射</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.collection.find();</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.goods.find();</span><br></pre></td></tr></table></figure>
<p>返回结果:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 1</span><br><span class="line">&#123;</span><br><span class="line">    "_id": ObjectId("5e9c48b42a170000ea003e45"),</span><br><span class="line">    "name": "纸巾一包",</span><br><span class="line">    "price": 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">&#123;</span><br><span class="line">    "_id": ObjectId("5e9c48eb2a170000ea003e48"),</span><br><span class="line">    "name": "奶茶一杯",</span><br><span class="line">    "price": 20.58</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">&#123;</span><br><span class="line">    "_id": ObjectId("5e9c56b72a170000ea003e5d"),</span><br><span class="line">    "name": "哈士奇饼干1",</span><br><span class="line">    "price": 33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><p>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询名字为"纸巾一包"并且价格为100元的数据</span><br><span class="line">db.goods.find(&#123;name:"纸巾一包",price:100&#125;)</span><br></pre></td></tr></table></figure>

<p>返回结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "_id": ObjectId("5e9c48b42a170000ea003e45"),</span><br><span class="line">    "name": "纸巾一包",</span><br><span class="line">    "price": 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复合主键查询"><a href="#复合主键查询" class="headerlink" title="复合主键查询"></a>复合主键查询</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.goods.find(&#123;"_id.type":"shop"&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h5><p>{<field>:{$<operator>:<vaule>}}<br>$eq  匹配字段值相等的文档 （可以用于string和int类型） =<br>$ne  匹配字段值不等的文档 !=<br>$gt  匹配字段值大于查询值的文档 &gt;<br>$gte  匹配字段值大于或等于查询值的文档 &gt;=<br>$lt 匹配字段值小于查询值的文档  &lt;<br>$lte 匹配字段值小于或等于查询值的文档  &lt;=<br>$in 匹配字段值与任意查询值相等的文档 “in”<br>$nin  匹配字段值与任意查询值不相等的文档 “not in”</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//匹配查询</span><br><span class="line">db.goods.find(&#123;name:&#123;$eq:"纸巾一包"&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//in查询</span><br><span class="line">db.goods.find(&#123;"name":&#123;$in:["纸巾一包","奶茶一杯"]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//读取价格大于32元且小于101元的商品</span><br><span class="line">db.goods.find(&#123;price:&#123;$gt:32,$lt:101&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//复合组件查询</span><br><span class="line">db.goods.find(&#123;"_id.type":&#123;$eq:"shop"&#125;&#125;)</span><br><span class="line">db.goods.find(&#123;"_id.type":&#123;$in:["shop"]&#125;&#125;)</span><br></pre></td></tr></table></figure>


<h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><p>$not 匹配筛选条件不成立的文档<br>$and 匹配多个筛选条件全部成立的文档<br>$or 匹配至少一个筛选条件成立的文档<br>$nor 匹配多个筛选条件全部不成立的文档<br>逻辑运算符示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询价格不小于32元的商品</span><br><span class="line">db.goods.find(&#123;price:&#123;$not:&#123;$lt:32&#125;&#125;&#125;)</span><br><span class="line">//相当于下面的取反</span><br><span class="line">db.goods.find(&#123;price:&#123;$lt:32&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//获取价格为100，并且名称为"纸巾一包"的商品</span><br><span class="line">db.goods.find(&#123;</span><br><span class="line">	$and:[</span><br><span class="line">		&#123;price:&#123;$eq:100&#125;&#125;,</span><br><span class="line">		&#123;name:"纸巾一包"&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line">//可以简写如下</span><br><span class="line">db.goods.find(&#123;price:&#123;$eq:100&#125;,name:"纸巾一包"&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//获取价格不是100，并且名称不为"纸巾一包"的商品</span><br><span class="line">db.goods.find(&#123;</span><br><span class="line">	$nor:[</span><br><span class="line">		&#123;price:&#123;$eq:100&#125;&#125;,</span><br><span class="line">		&#123;name:"纸巾一包"&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line">注意：nor也会筛选出并不包含查询字段的文档！！比如会把没有price和name字段的文档也查出来！</span><br></pre></td></tr></table></figure>

<h5 id="字段操作符"><a href="#字段操作符" class="headerlink" title="字段操作符"></a>字段操作符</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$exists</span> 匹配包含查询字段的文档  </span><br><span class="line"><span class="variable">$type</span> 匹配字段符合查询值的文档</span><br></pre></td></tr></table></figure>



<p><strong>$type对应的类型和BSON类型序号</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Double	1	 </span><br><span class="line">String	2	 </span><br><span class="line">Object	3	 </span><br><span class="line">Array	4	 </span><br><span class="line">Binary data	5	 </span><br><span class="line">Undefined	6	已废弃。</span><br><span class="line">Object id	7	 </span><br><span class="line">Boolean	8	 </span><br><span class="line">Date	9	 </span><br><span class="line">Null	10	 </span><br><span class="line">Regular Expression	11	 </span><br><span class="line">JavaScript	13	 </span><br><span class="line">Symbol	14	 </span><br><span class="line">JavaScript (with scope)	15	 </span><br><span class="line">32-bit <span class="built_in">integer</span>	16	 </span><br><span class="line">Timestamp	17	 </span><br><span class="line">64-bit <span class="built_in">integer</span>	18	 </span><br><span class="line">Min key	255	Query with -1.</span><br><span class="line">Max key	127</span><br></pre></td></tr></table></figure>
<p>示例 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询复合主键中存在type字段的数据</span><br><span class="line">db.goods.find(&#123;"_id.type":&#123;$exists:true&#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询存在name字段的数据</span><br><span class="line">db.goods.find(&#123;name:&#123;$exists:true&#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询类型为普通主键和复合主键的数据</span><br><span class="line">db.goods.find(&#123;_id:&#123;$type:["objectId","object"]&#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询类型为string的数据</span><br><span class="line">db.goods.find(&#123;name:&#123;$type:["string"]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="数组操作符"><a href="#数组操作符" class="headerlink" title="数组操作符"></a>数组操作符</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$all</span> 匹配数组字段中包含所有查询值的文档</span><br><span class="line"><span class="variable">$elemMatch</span> 匹配数组字段中至少存在一个值满足筛选条件的文档</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">先插入数据</span><br><span class="line">db.goods.insert(</span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">name</span>:<span class="string">"皮卡丘一只"</span>,</span><br><span class="line">			price:<span class="number">100</span>,</span><br><span class="line">			contact:[<span class="string">"111111"</span>,<span class="string">"Alabama"</span>,<span class="string">"US"</span>]</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">name</span>:<span class="string">"小火龙一只"</span>,</span><br><span class="line">			price:<span class="number">120</span>,</span><br><span class="line">			contact:[[<span class="string">"222222"</span>,<span class="string">"333333"</span>],<span class="string">"Beijing"</span>,<span class="string">"China"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询contact字段中同时包含"China"和"Beijing"字段的文档</span><br><span class="line">db.goods.find(&#123;contact:&#123;$all:["China","Beijing"]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询联系方式中包含"222222","333333"的文档，注意，这里的数组如果只有"222222"是查询不到的，这里是数组全等的关系</span><br><span class="line">db.goods.find(&#123;contact:&#123;$all:[["222222","333333"]]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询电话号码范围在大于111110和小于222222之间的数据</span><br><span class="line">db.goods.find(&#123;contact:&#123;$elemMatch:&#123;$gt:"111110",$lt:"222222"&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//查询电话号码范围在"大于111110和小于222222之间"并且"大于211111和小于444444之间"的数据</span><br><span class="line">db.goods.find(&#123;</span><br><span class="line">	contact:&#123;$all:[</span><br><span class="line">		&#123;$elemMatch:&#123;$gt:"111111",$lt:"222222"&#125;&#125;,</span><br><span class="line">		&#123;$elemMatch:&#123;$gt:"211111",$lt:"444444"&#125;&#125;</span><br><span class="line">	]&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h5 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&lt;field&gt;:&#123;:/pattern/,:<span class="string">'&lt;options&gt;'</span>&#125;&#125;</span><br><span class="line">&#123;&lt;field&gt;:&#123;:/pattern/&lt;options&gt;&#125;&#125;</span><br><span class="line"><span class="variable">$regex</span>  </span><br><span class="line">在和<span class="variable">$in</span>操作符一起使用时，只能使用/pattern/&lt;options&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//读取name字段以"皮"或"j"开头的文档数据</span><br><span class="line">db.goods.find(&#123;name:&#123;$in:[/^皮/,/^j/]&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//读取name字段包含LIE（不区分大小写）的文档数据</span><br><span class="line">db.goods.find(&#123;name:&#123;$regex:/LIE/,$options:'i'&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>游历完游标中所有文档之后，或者在10分钟之后，游标便会自动关闭<br>可以使用noCursorTimeout()函数来保持游标一直有效  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var myCursor=db.goods.find().noCursorTimeout()</span><br></pre></td></tr></table></figure>
<p>在这之后，在不遍历游标的情况下，你需要主动关闭游标  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">myCursor.close()</span><br></pre></td></tr></table></figure>

<h5 id="游标函数"><a href="#游标函数" class="headerlink" title="游标函数"></a>游标函数</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cursor.hasNext() //当还有没遍历完的游标文档时，返回<span class="literal">true</span></span><br><span class="line">cursor.next()  //获取下一次遍历的游标文档</span><br><span class="line">cursor.forEach(&lt;<span class="keyword">function</span>&gt;) //遍历游标中所有指向的文档</span><br><span class="line">cursor.limit(&lt;number&gt;)  //返回指定条数</span><br><span class="line">cursor.skip(&lt;offest&gt;) //跳过文档中指定数量的文档（传入1表示跳过第一篇文档）</span><br><span class="line">cursor.count(&lt;applySkipLimit&gt;) //默认情况下，&lt;applySkipLimit&gt;为<span class="literal">false</span>，即cursor.count()不会考虑cursor.skip()和cursor.limit()的效果</span><br><span class="line">cursor.sort(&lt;document&gt;)  //这里的&lt;document&gt;定义了排序的要求（1从小到大排序，-1从大到小排序）</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var myCursor=db.goods.find();</span><br><span class="line">while(myCursor.hasNext())&#123;</span><br><span class="line">	printjson(myCursor.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myCursor=db.goods.find();</span><br><span class="line">myCursor.forEach(printjson)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.goods.find().limit(1)</span><br><span class="line">db.goods.find().skip(1)</span><br><span class="line"></span><br><span class="line">db.goods.find().limit(1).count() //返回所有文档总数</span><br><span class="line">db.goods.find().limit(1).count(true) //返回一篇文档</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//price字段从大到小排序，并且name字段由小到大排序 （相当于mysql中同时两个排序条件的规则）</span><br><span class="line">db.goods.find().sort(&#123;price:-1,name:1&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意事项<br>cursor.skip(),cursor.limit(),cursor.count()<br>优先级：count()-&gt;skip()-&gt;limit()</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cursor.skip()在cursor.limit()之前执行</span><br><span class="line">db.goods.find().limit(5).skip(3)</span><br><span class="line">结果返回的是5篇文章，从第4篇到第9篇文章</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">cursor.count()在cursor.skip()和cursor.limit()之前执行</span><br><span class="line">db.goods.find().limit(5).skip(3).sort(&#123;price:-1&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="文档投影"><a href="#文档投影" class="headerlink" title="文档投影"></a>文档投影</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.goods.find(&lt;query&gt;,&lt;projection&gt;)</span><br><span class="line">不使用投影时，db.goods.find()返回符合筛选条件的完整文档</span><br><span class="line">使用投影可以只返回指定的字段</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;field:inclusion&#125;</span><br><span class="line">1表示返回部分字段，0表示不返回字段，（1和0不可组合使用，_id字段除外）</span><br><span class="line">//只返回name字段</span><br><span class="line">db.goods.find(&#123;&#125;,&#123;name:1,_id:0&#125;)</span><br><span class="line">//返回除name之外的字段</span><br><span class="line">db.goods.find(&#123;&#125;,&#123;name:0&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//$slide:2,表示返回前2条，-2表示返回倒数2条，[1,2]表示返回第二条到第三条</span><br><span class="line">db.goods.find(&#123;&#125;,&#123;name:1,content:&#123;$slide:[1,2]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>$elemMatch和$操作符可以返回数组字段中满足筛选条件的第一个元素</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//返回content数组字段中第一个排序大于"Alabama"的数据，（没content字段的文档也会被返回）</span><br><span class="line">db.goods.find(&#123;&#125;,&#123;name:1,content:&#123;$elemMatch:&#123;$gt:"Alabama"&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//返回content数组字段中第一个排序大于"Alabama"的数据</span><br><span class="line">db.goods.find(&#123;content:&#123;$gt:"Alabama"&#125;&#125;,&#123;name:1,"content.$":1,&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>注意：<br>1、<br>      db.goods.update(where查询条件,更新的值,其它条件)<br>      db.goods.update({“uid”:3},{$rename:{“name”:”alias”}},{multi:true})<br>2、文档更新操作只会更新一篇文档，即使条件符合多篇文档，也只会更新一篇，如果想要更新所有符合条件的文档，需要添加第三个参数<strong>{multi:true}</strong></p>
<h4 id="文档更新操作符"><a href="#文档更新操作符" class="headerlink" title="文档更新操作符"></a>文档更新操作符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$set</span> 更新或新增字段</span><br><span class="line"><span class="variable">$unset</span> 删除字段</span><br><span class="line"><span class="variable">$rename</span> 重命名字段 &#123;<span class="variable">$rename</span>:&#123;&lt;field1&gt;:&lt;newName1&gt;,&lt;field2&gt;:&lt;newName2&gt;&#125;&#125;</span><br><span class="line"><span class="variable">$inc</span> 加减字段值  (字段不存在时，会默认创建且值为加减的值)</span><br><span class="line"><span class="variable">$mul</span> 相乘字段值 (字段不存在时，会默认创建且值为0 )</span><br><span class="line"><span class="variable">$min</span> 比较减少字段值 (保留最小的值)(字段不存在会自动创建且值为指定的值)(类型不一致按BSON数据类型排序规则比较)</span><br><span class="line"><span class="variable">$max</span> 比较增大字段值 (保留最大的值)(字段不存在会自动创建且值为指定的值)(类型不一致按BSON数据类型排序规则比较)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//（$<span class="keyword">rename</span>）重命名写法</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$<span class="keyword">rename</span>:&#123;<span class="string">"name"</span>:<span class="string">"alias"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//（$<span class="keyword">rename</span>）将数组字段<span class="keyword">content</span>中的<span class="keyword">name</span>字段迁移到最外面的<span class="keyword">name</span>字段</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$<span class="keyword">rename</span>:&#123;<span class="string">"content.name"</span>:<span class="string">"name"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//（$<span class="keyword">rename</span>）将最外面的<span class="keyword">name</span>字段迁移到数组字段<span class="keyword">content</span>中的<span class="keyword">name</span>字段</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$<span class="keyword">rename</span>:&#123;<span class="string">"name"</span>:<span class="string">"content.name"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//（$inc）将条件uid=3的文档，price字段加一</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$inc:&#123;<span class="string">"price"</span>:<span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//（$min）源字段大于50时，修改成50</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$<span class="keyword">min</span>:&#123;<span class="string">"price"</span>:<span class="number">50</span>&#125;&#125;) （源price值为<span class="number">30</span>时，不变，保留<span class="number">30</span>）</span><br></pre></td></tr></table></figure>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BSON数据类型排序规则</span><br><span class="line">最小</span><br><span class="line">	Null</span><br><span class="line">	Numbers(ints,longs,doubles,decimals)</span><br><span class="line">    Symbol,String</span><br><span class="line">	Object</span><br><span class="line">	Array</span><br><span class="line">	BinData</span><br><span class="line">	ObjectId</span><br><span class="line">	Boolean</span><br><span class="line">	Date</span><br><span class="line">最大</span><br><span class="line">	Regular Expression</span><br></pre></td></tr></table></figure>

<h4 id="数组更新操作符"><a href="#数组更新操作符" class="headerlink" title="数组更新操作符"></a>数组更新操作符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$addToSet</span> 向数组中增添元素</span><br><span class="line"><span class="variable">$pop</span> 从数组中移除元素</span><br><span class="line"><span class="variable">$pull</span> 从数组中移除指定元素</span><br><span class="line"><span class="variable">$pullAll</span> 从数组中有选择性地移除元素</span><br><span class="line"><span class="variable">$push</span> 向数组中增添元素</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//($addToSet)将content数组字段添加"nihao","wohao"两个值</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$addToSet:&#123;<span class="string">"content"</span>:&#123;$<span class="keyword">each</span>:[<span class="string">"nihao"</span>,<span class="string">"wohao"</span>]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//$pull删除content数组中包含"皮"字的字段</span><br><span class="line">db.goods.update(&#123;<span class="string">"uid"</span>:<span class="number">3</span>&#125;,&#123;$pull:&#123;<span class="string">"content"</span>:&#123;$regex:/皮/&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;$pullAll:&#123;&lt;field&gt;:[&lt;vaule1&gt;,&lt;vaule2&gt;]&#125;&#125;</span><br><span class="line">相当于</span><br><span class="line">&#123;$pull:&#123;&lt;field&gt;:&#123;$in:[&lt;vaule1&gt;,&lt;vaule2&gt;]&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 第一个符合条件的占位符</span><br><span class="line">$[] 数组中的所有元素</span><br></pre></td></tr></table></figure>

<p><strong>更新数组中的特定元素<br>$是数组中第一个符合筛选条件的数组元素的占位符，搭配更新操作符使用，可以对满足筛选条件的数组元素进行更新</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.goods.update(&#123;&lt;array&gt;:&lt;query selector&gt;&#125;,&lt;update operator&gt;:&#123;<span class="string">"&lt;array&gt;.$"</span>,vaule&#125;)</span><br></pre></td></tr></table></figure>


<p>$[]指代数组字段中的所有元素，搭配更新操作符使用，可以对数组中的所有元素进行更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.goods.update(&#123;&lt;array&gt;:&lt;query selector&gt;&#125;,&lt;update operator&gt;:&#123;<span class="string">"&lt;array&gt;.$[]"</span>,vaule&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//源数据</span><br><span class="line">&#123;</span><br><span class="line">    "_id": ObjectId("5e9f08904757000020000235"),</span><br><span class="line">    "content": [</span><br><span class="line">        "nihao",</span><br><span class="line">        "我很好"</span><br><span class="line">    ],</span><br><span class="line">    "uid": 3,</span><br><span class="line">    "name": "nihao",</span><br><span class="line">    "num": 1,</span><br><span class="line">    "num1": 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//将content数组中值为"nihao"的替换成"updated"</span><br><span class="line">db.goods.update(&#123;</span><br><span class="line">    uid:<span class="number">3</span>,</span><br><span class="line">	<span class="keyword">content</span>:<span class="string">"nihao"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    $<span class="keyword">set</span>: &#123;</span><br><span class="line">        <span class="string">"content.$"</span>:<span class="string">"updated"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">将content数组中所有字段替换成"updated"</span><br><span class="line">db.goods.update(&#123;</span><br><span class="line">    uid:<span class="number">3</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    $<span class="keyword">set</span>: &#123;</span><br><span class="line">        <span class="string">"content.$[]"</span>:<span class="string">"updated"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="更新文档选项"><a href="#更新文档选项" class="headerlink" title="更新文档选项"></a>更新文档选项</h4><p>{multi:<boolean>}<br>更新多个文档<br>到目前为止，我们在update命令中使用的筛选条件只对应一篇文档<br>在默认情况下，即使筛选条件对应了多篇文档，update命令仍然只会更新一篇文档</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">将所有name值为"nihao"的文档num值改成10</span><br><span class="line">db.goods.update(&#123;</span><br><span class="line">    <span class="keyword">name</span>:<span class="string">"nihao"</span></span><br><span class="line">&#125;, &#123;$<span class="keyword">set</span>: &#123;<span class="string">"num"</span>:<span class="number">10</span>&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><pre><code>在MongoDB中，更新单个的文档操作是原子性的。默认情况下，如果一个update()更新多个文档，那么对每个文档的更新是原子性的，但是对整个update而言则不是原子性的。有可能存在前一个文档更新成功，后面的文档更新失败的情况。由于单个文档的更新是原子性的，如果两个更新同时发生，就会出现阻塞，先到的先执行，所以文档最终结果由靠后的操作决定。
**简单的说就是对同一篇文档进行更新，文档最终结果以最后的更新操作为结果**</code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.remove() 删除文档</span><br><span class="line">db.collection.drop() 删除集合</span><br></pre></td></tr></table></figure>
<p>注：<br>1、删除文档默认是删除所有符合条件的文档，和update操作不一样，如果需要指定只删除一篇文档，加上第二个参数<strong>（{justOne:true}）</strong></p>
<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.remove(&lt;query&gt;,&lt;options&gt;)</span><br><span class="line">&lt;options&gt;声明了一些删除操作的参数</span><br><span class="line"></span><br><span class="line">db.goods.remove()</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//删除name值为"nihao"的所有文档</span><br><span class="line">db.goods.remove(&#123;name:"nihao"&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//删除name值为"nihao"的一篇文档（&#123;justOne:true&#125;）</span><br><span class="line">db.goods.remove(&#123;name:"nihao"&#125;,&#123;justOne:true&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//删除集合内的所有文档</span><br><span class="line">db.goods.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.drop(&lt;writeConcern&gt;,&lt;document&gt;)</span><br><span class="line">db.goods.drop()</span><br></pre></td></tr></table></figure>
<p>这里的writeConcern文档定义了本次集合删除操作的安全写级别、<br>drop命令可以删除整个集合，包括集合中的所有文档，以及集合的索引</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>使用docker容器运行mongodb</title>
    <url>/post/2627105888.html</url>
    <content><![CDATA[<p>使用docker容器运行mongodb</p>
<h3 id="1、下载Mongodb的官方docker镜像"><a href="#1、下载Mongodb的官方docker镜像" class="headerlink" title="1、下载Mongodb的官方docker镜像"></a>1、下载Mongodb的官方docker镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mongo:latest</span><br></pre></td></tr></table></figure>
<h3 id="2、启动一个Mongodb服务器容器"><a href="#2、启动一个Mongodb服务器容器" class="headerlink" title="2、启动一个Mongodb服务器容器"></a>2、启动一个Mongodb服务器容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongo -p 27017:27017 --restart=always -v /mongodb/data:/data/db -d mongo:latest</span><br></pre></td></tr></table></figure>
<p>–name mongodb 容器名称<br>-v /mongodb/data:/data/db –&gt;挂载数据目录<br>-d –&gt;后台运行容器  </p>
<h3 id="3、添加用户和设置密码，并且尝试连接"><a href="#3、添加用户和设置密码，并且尝试连接" class="headerlink" title="3、添加用户和设置密码，并且尝试连接"></a>3、添加用户和设置密码，并且尝试连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongo mongo admin</span><br><span class="line"><span class="comment"># 创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line">&gt;  db.createUser(&#123; user:<span class="string">'admin'</span>,<span class="built_in">pwd</span>:<span class="string">'123456'</span>,roles:[ &#123; role:<span class="string">'userAdminAnyDatabase'</span>, db: <span class="string">'admin'</span>&#125;,<span class="string">"readWriteAnyDatabase"</span>]&#125;);</span><br><span class="line"><span class="comment"># 尝试使用上面创建的用户信息进行连接。</span></span><br><span class="line">&gt; db.auth(<span class="string">'admin'</span>, <span class="string">'123456'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>查看mongodb容器日志</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs mongodb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>swoole两种运行模式BASE和PROCESS的区别</title>
    <url>/post/570064033.html</url>
    <content><![CDATA[<h2 id="Server的两种运行模式介绍"><a href="#Server的两种运行模式介绍" class="headerlink" title="Server的两种运行模式介绍"></a>Server的两种运行模式介绍</h2><h3 id="单线程模式（SWOOLE-BASE）"><a href="#单线程模式（SWOOLE-BASE）" class="headerlink" title="单线程模式（SWOOLE_BASE）"></a>单线程模式（SWOOLE_BASE）</h3><p>这种模式就是传统的异步非阻塞<strong>Server</strong>。与Nginx和Node.js等程序是完全一致的。</p>
<p>在时间循环中直接回调PHP的函数，而不是dispatch投递任务。如果回调函数中有阻塞操作会导致Server退化为同步模式。worker_num参数对与BASE模式仍然有效，会启动多个Worker进程。</p>
<ul>
<li>BASE模式下没有Master进程的角色</li>
<li>每个Worker进程同时承担了Process模式下Reactor线程和Worker进程两部分职责</li>
<li>BASE模式下Manager进程是可选的，当设置了worker_num=1，并且没有使用Task和MaxRequest特性时，底层将直接创建一个单独的Worker进程，不创建Manager进程</li>
</ul>
<p><strong>BASE模式的优点：</strong></p>
<ul>
<li>BASE模式没有IPC开销，性能更好</li>
<li>BASE模式代码更简单，不容易出错</li>
</ul>
<p><strong>BASE模式的缺点：</strong></p>
<ul>
<li>TCP连接是在Worker进程中维持的，所以当某个Worker进程挂掉时，此Worker内的所有连接都将被关闭</li>
<li>少量TCP长连接无法利用到所有Worker进程</li>
<li>TCP连接与Worker是绑定的，长连接应用中某些连接的数据量大，这些连接所在的Worker进程负载会非常高。但某些连接数据量小，所以在Worker进程的负载会非常低，不同的Worker进程无法实现均衡。<br><strong>BASE模式的适用场景：</strong></li>
</ul>
<p>如果客户端连接之间不需要交互，可以使用BASE模式。如Memcache、Http服务器等。</p>
<h3 id="进程模式（SWOOLE-PROCESS）"><a href="#进程模式（SWOOLE-PROCESS）" class="headerlink" title="进程模式（SWOOLE_PROCESS）"></a>进程模式（SWOOLE_PROCESS）</h3><p>多进程模式是最复杂的方式，用了大量的进程间通信、进程管理机制。适合业务逻辑非常复杂的场景。Swoole提供了完善的进程管理、内存保护机制。 在业务逻辑非常复杂的情况下，也可以长期稳定运行。</p>
<p>Swoole在Reactor线程中提供了Buffer的功能，可以应对大量慢速连接和逐字节的恶意客户端。另外也提供了CPU亲和设置选项，使程序运行的效率更好。</p>
<p><strong>进程模式的优点：</strong></p>
<ul>
<li>连接与数据请求发送是分离的，不会因为某些连接数据量大某些连接数据量小导致Worker进程不均衡</li>
<li>Worker进程发送致命错误时，连接并不会被切断</li>
<li>可实现单连接并发，仅保持少量TCP连接，请求可以并发地在多个Worker进程中处理</li>
</ul>
<p><strong>进程模式的缺点：</strong></p>
<ul>
<li><p>存在2次IPC的开销，master进程与worker进程需要使用UnixSocket进行通信</p>
</li>
<li><p>不支持某些高级功能，如sendwait、pause、resume等操作</p>
<p>原文链接：<br><a href="https://wiki.swoole.com/wiki/page/353.html" target="_blank" rel="noopener">https://wiki.swoole.com/wiki/page/353.html</a><br><a href="https://wiki.swoole.com/wiki/diff/?id=353&amp;version=2&amp;compare=current" target="_blank" rel="noopener">https://wiki.swoole.com/wiki/diff/?id=353&amp;version=2&amp;compare=current</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>swoole</category>
      </categories>
  </entry>
  <entry>
    <title>Swoole 如何处理高并发以及异步 I/O 的实现</title>
    <url>/post/3001131064.html</url>
    <content><![CDATA[<h2 id="Swoole-介绍"><a href="#Swoole-介绍" class="headerlink" title="Swoole 介绍"></a>Swoole 介绍</h2><p>1.swoole提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步MySQL，异步Redis， 数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole还内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。</p>
<p>2.Swoole可以广泛应用于互联网、移动通信、企业软件、网络游戏、物联网、车联网、智能家庭等领域。 使用PHP+Swoole作为网络通信框架， 可以使企业IT研发团队的效率大大提升，更加专注于开发创新产品。</p>
<p>3.Swoole底层内置了异步非阻塞、多线程的网络IO服务器。PHP程序员仅需处理事件回调即可，无需关心底层。与Nginx/Tornado/Node.js等全异步的框架不同，Swoole既支持全异步，也支持同步。</p>
<h2 id="Swoole-如何处理高并发"><a href="#Swoole-如何处理高并发" class="headerlink" title="Swoole 如何处理高并发"></a>Swoole 如何处理高并发</h2><p><strong>①对Reactor模型介绍</strong>我们都知道IO复用异步非阻塞程序使用的是经典的Reactor模型，Reactor就是反应堆的意思，也就是说它本身不处理任何数据收发。只是可以监视一个socket(比如管道、eventfd、信号)句柄的事件变化。Reactor只作为一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close等都是在callback中完成的。看看下面图片就可以了解到。</p>
<p><img src="http://images.tiance.club/resource/images/pasted1-0.png" alt="upload successful"></p>
<p><strong>②swoole的架构</strong>咱们再来看看swoole的架构，我们也可以从以下借鉴的图片可以看出，swoole采用的架构模式：多线程Reactor+多进程Worker，因为reactor是基于epoll的，所以不难看出每个reactor，它可以用来处理无数个连接请求。 如此，swoole就轻松的实现了高并发的处理。这里对高并发还不清楚的话，请自行网上看看教程，这里就不多做解释了。</p>
<p><img src="http://images.tiance.club/resource/images/pasted1-1.png" alt="upload successful"></p>
<p><strong>Swoole的处理连接流程图如下：</strong></p>
<p><img src="http://images.tiance.club/resource/images/pasted1-2.png" alt="upload successful"></p>
<p><strong>当请求到达时，Swoole是这样处理的：</strong></p>
<p><img src="http://images.tiance.club/resource/images/pasted1-3.png" alt="upload successful"></p>
<p><strong>Swoole 如何实现异步I/O</strong></p>
<p>基于上面的Swoole结构图，我们可以知道：Swoole的worker进程有2种类型：一种是普通的worker进程，一种是task worker进程。这两种类型分别用来处理什么呢？</p>
<ul>
<li>worker进程：用来处理普通的耗时不是太长的请求   </li>
<li>task worker进程：用来处理耗时较长的请求，比如数据库的I/O操作</li>
</ul>
<p>我们再以异步MySQL举例，不难看出通过worker、task worker结合的方式，我们就实现了异步I/O。</p>
<p><img src="http://images.tiance.club/resource/images/pasted1-4.png" alt="upload successful"></p>
<p>参考原文：<a href="https://baijiahao.baidu.com/s?id=1648878759459418111&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1648878759459418111&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>swoole</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMq常用命令</title>
    <url>/post/77993866.html</url>
    <content><![CDATA[<h2 id="一、消息对列常用命令"><a href="#一、消息对列常用命令" class="headerlink" title="一、消息对列常用命令"></a>一、消息对列常用命令</h2><p> 1、启插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>2、移除服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-service remove</span><br></pre></td></tr></table></figure>

<p>3、安装服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-service install</span><br></pre></td></tr></table></figure>

<p>4、重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-server restart</span><br></pre></td></tr></table></figure>

<p>5、启用RabbitMq服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-server start</span><br></pre></td></tr></table></figure>

<p>6、停止应用程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>

<p>7、启用运用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>8、重置清除节点的配置(先stop_app，后reset节点)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl rest</span><br></pre></td></tr></table></figure>

<p>9、启用日志插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_tracing</span><br></pre></td></tr></table></figure>

<p>二、消息集群常用命令<br>1、加入集群[–ram添加内存模式 默认disk模式]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl join_cluster --ram rabbit@mq01</span><br></pre></td></tr></table></figure>

<p>2、查看集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>

<p>3、更改节点模式[顺序 关闭运用－〉更改类型-&gt;开启运用]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app  –停止运用服务</span><br><span class="line">rabbitmqctl change_cluster_node_type disc/ram –更改节点为磁盘或内存节点</span><br><span class="line">rabbitmqctl start_app –开启运用服务</span><br></pre></td></tr></table></figure>

<p>4、创建策略(集群同步策略……)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">set_policy [-p vhostpath] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125; [priority]</span><br></pre></td></tr></table></figure>

<p>5、查看策略</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_policies</span><br></pre></td></tr></table></figure>

<p>6、移除远程offline的节点<br>1.节点2停掉应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>

<p>2.节点1执行删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node rabbit@mq02</span><br></pre></td></tr></table></figure>

<p>7、设置集群名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_cluster_name cluster_name</span><br></pre></td></tr></table></figure>

<p>8、设置镜像模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rabbit提供镜像功能，需要基于rabbitmq策略来实现，政策是用来控制和修改群集范围的某个vhost队列行为和Exchange行为 </span><br><span class="line">set_policy [-p vhostpath] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125; [priority]</span><br><span class="line">rabbitmqctl set_policy ha-all <span class="string">"^ha."</span> <span class="string">"&#123;"</span><span class="string">"ha-mode"</span><span class="string">":"</span><span class="string">"all"</span><span class="string">"&#125;"</span></span><br><span class="line">rabbitmqctl set_policy ha-all <span class="string">"^"</span> <span class="string">"&#123;"</span><span class="string">"ha-mode"</span><span class="string">":"</span><span class="string">"all"</span><span class="string">","</span><span class="string">"ha-sync-mode"</span><span class="string">":"</span><span class="string">"automatic"</span><span class="string">"&#125;"</span></span><br><span class="line">rabbitmqctl set_policy -p jjw-uplus  ha-all <span class="string">"^"</span> <span class="string">"&#123;"</span><span class="string">"ha-mode"</span><span class="string">":"</span><span class="string">"all"</span><span class="string">","</span><span class="string">"ha-sync-mode"</span><span class="string">":"</span><span class="string">"automatic"</span><span class="string">"&#125;"</span></span><br><span class="line">下面的例子将“two.”开头的queue mirror到cluster中两个节点，且自动同步</span><br><span class="line">rabbitmqctl   rabbitmqctl set_policy ha-two <span class="string">"^two\."</span> <span class="string">'&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;'</span></span><br><span class="line">pattern 是匹配队列名称的正则表达式 , 进行区分哪些队列使用哪些策略</span><br><span class="line">definition 其实就是一些arguments, 支持如下参数：</span><br><span class="line">ha-mode：One of all, exactly or nodes (the latter currently not supported by web UI).</span><br><span class="line">ha-params：Absent <span class="keyword">if</span> ha-mode is all, a number <span class="keyword">if</span> ha-mode is exactly, or an array of strings <span class="keyword">if</span> ha-mode is nodes.</span><br><span class="line">ha-sync-mode：One of manual or automatic. //如果不指定该参数默认为manual,这个在高可用集群测试的时候详细分析 </span><br><span class="line">federation-upstream-set：A string; only <span class="keyword">if</span> the federation plugin is enabled.</span><br><span class="line">可通过如下命令确认哪些salve在同步</span><br><span class="line">rabbitmqctl list_queues name slave_pids synchronised_slave_pids</span><br></pre></td></tr></table></figure>

<p>9、手动同步queue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl sync_queue name</span><br></pre></td></tr></table></figure>

<p>10、取消queue同步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cancel_sync_queue name</span><br></pre></td></tr></table></figure>

<p>11、查看所有队列信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_queues</span><br></pre></td></tr></table></figure>

<p>12、获取队列信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_queues[-p vhostpath] [queueinfoitem ...]</span><br><span class="line">Queueinfoitem可以为：name，durable，auto_delete，arguments，messages_ready，messages_unacknowledged，messages，consumers，memory。</span><br></pre></td></tr></table></figure>

<p>13、获取Exchange信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_exchanges[-p vhostpath] [exchangeinfoitem ...]</span><br><span class="line">Exchangeinfoitem有：name，<span class="built_in">type</span>，durable，auto_delete，internal，arguments。</span><br></pre></td></tr></table></figure>

<p>14、获取Binding信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_bindings[-p vhostpath] [bindinginfoitem ...] </span><br><span class="line">Bindinginfoitem有：source_name，source_kind，destination_name，destination_kind，routing_key，arguments。</span><br></pre></td></tr></table></figure>

<p>15、获取Connection信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_connections [connectioninfoitem ...]</span><br><span class="line">Connectioninfoitem有：recv_oct，recv_cnt，send_oct，send_cnt，send_pend等。</span><br></pre></td></tr></table></figure>

<p>16、获取Channel信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_channels[channelinfoitem ...]</span><br><span class="line">Channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>rabbitmq management新建账号</title>
    <url>/post/545059273.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user <span class="built_in">test</span> <span class="built_in">test</span> </span><br><span class="line">rabbitmqctl set_user_tags <span class="built_in">test</span> administrator </span><br><span class="line">rabbitmqctl set_permissions -p / <span class="built_in">test</span> <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>composer切换国内源</title>
    <url>/post/186457038.html</url>
    <content><![CDATA[<p>调用方式<br>以阿里云为例，全局模式（推荐）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>


<p>单独项目使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ composer config repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>

<p><a href="https://learnku.com/php/wikis/30594" target="_blank" rel="noopener">https://learnku.com/php/wikis/30594</a><br><a href="https://www.uedbox.com/post/58890/" target="_blank" rel="noopener">https://www.uedbox.com/post/58890/</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>AOP的定义和原理</title>
    <url>/post/1167956631.html</url>
    <content><![CDATA[<h2 id="一、本课目标"><a href="#一、本课目标" class="headerlink" title="一、本课目标"></a>一、本课目标</h2><p>理解Spring AOP的原理<br>掌握Spring AOP的七个术语</p>
<h2 id="二、面向切面编程"><a href="#二、面向切面编程" class="headerlink" title="二、面向切面编程"></a>二、面向切面编程</h2><h2 id="一、本课目标-1"><a href="#一、本课目标-1" class="headerlink" title="一、本课目标"></a>一、本课目标</h2><p>理解Spring AOP的原理<br>掌握Spring AOP的七个术语</p>
<h2 id="二、面向切面编程（AOP）"><a href="#二、面向切面编程（AOP）" class="headerlink" title="二、面向切面编程（AOP）"></a>二、面向切面编程（AOP）</h2><p><img src="https://img-blog.csdnimg.cn/20200405224252302.png" alt="image.png"><br><strong>在上面这个图中的代码中，业务代码就红框中的那些，其他的代码都是做一些其他的事情，但是这些代码还不得不写，并且这些代码散布在我们系统的各处。我们把这样的的代码叫做横切逻辑，也叫横切关注点；把我们的业务代码叫做核心关注点。但是我们构建系统的目的是为了解决业务问题，现在却要维护多个方面的事情，怎么样才能“专心”做事情？这就是AOP的目标：让我们“专心做事”。</strong></p>
<h3 id="2-1AOP原理"><a href="#2-1AOP原理" class="headerlink" title="2.1AOP原理"></a>2.1AOP原理</h3><h4 id="第一、将复杂的需求分解出不同的方面，将公共功能集中解决。"><a href="#第一、将复杂的需求分解出不同的方面，将公共功能集中解决。" class="headerlink" title="第一、将复杂的需求分解出不同的方面，将公共功能集中解决。"></a>第一、将复杂的需求分解出不同的方面，将公共功能集中解决。</h4><p><img src="https://img-blog.csdnimg.cn/20200405224317485.png" alt="在这里插入图片描述"><br>在上图中，中间的是我们的代码，AOP就是将这些分离，包括权限，日志和持久化等等。</p>
<h4 id="第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能"><a href="#第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能" class="headerlink" title="第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能"></a>第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能</h4><p><img src="https://img-blog.csdnimg.cn/20200405224343628.png" alt="image.png"><br>综上、所谓面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术。</p>
<h3 id="2-2AOP相关术语"><a href="#2-2AOP相关术语" class="headerlink" title="2.2AOP相关术语"></a>2.2AOP相关术语</h3><p><strong>1、增强处理：前置增强、后置增强、环绕增强、异常抛出增强、最终增强等类型<br>2、切入点<br>3、连接点<br>4、切面<br>5、目标对象<br>6、AOP代理<br>7、织入</strong></p>
<h4 id="1、增强处理"><a href="#1、增强处理" class="headerlink" title="1、增强处理"></a>1、增强处理</h4><p><img src="https://img-blog.csdnimg.cn/20200405224354319.png" alt="image.png"></p>
<h4 id="2、切入点"><a href="#2、切入点" class="headerlink" title="2、切入点"></a>2、切入点</h4><p>通过一个表达式告诉SpringAOP去哪个地方进行增强。也可以把这个表达式理解为一个查询条件，系统会根据这个查询条件查询到我们要进行增强的代码位置。</p>
<h4 id="3、连接点"><a href="#3、连接点" class="headerlink" title="3、连接点"></a>3、连接点</h4><p>就是SpringAOP通过告诉它的切入点的位置找的的具体的要增强的代码的位置，这个代码位置就是连接点。</p>
<h4 id="4、切面"><a href="#4、切面" class="headerlink" title="4、切面"></a>4、切面</h4><p>切面由一组（增强处理和切入点）共同构成。</p>
<h4 id="5、目标对象"><a href="#5、目标对象" class="headerlink" title="5、目标对象"></a>5、目标对象</h4><p>目标对象就是被增强的目标类。我们也称之为委托类。</p>
<h4 id="6、AOP代理"><a href="#6、AOP代理" class="headerlink" title="6、AOP代理"></a>6、AOP代理</h4><p><img src="https://img-blog.csdnimg.cn/20200405224405729.png" alt="image.png"></p>
<p>代理类就是AOP代理，里面包含了目标对象以及一些增强处理。系统会用AOP代理类代替委托类去执行功能。</p>
<h4 id="7、织入"><a href="#7、织入" class="headerlink" title="7、织入"></a>7、织入</h4><p>织入就是将我们的增强处理增强到指定位置的过程。（AOP）<br><img src="https://img-blog.csdnimg.cn/20200405224252302.png" alt="image.png"><br>在上面这个图中的代码中，业务代码就红框中的那些，其他的代码都是做一些其他的事情，但是这些代码还不得不写，并且这些代码散布在我们系统的各处。我们把这样的的代码叫做横切逻辑，也叫横切关注点；把我们的业务代码叫做核心关注点。但是我们构建系统的目的是为了解决业务问题，现在却要维护多个方面的事情，怎么样才能“专心”做事情？这就是AOP的目标：让我们“专心做事”。</p>
<h3 id="2-1AOP原理-1"><a href="#2-1AOP原理-1" class="headerlink" title="2.1AOP原理"></a>2.1AOP原理</h3><h4 id="第一、将复杂的需求分解出不同的方面，将公共功能集中解决。-1"><a href="#第一、将复杂的需求分解出不同的方面，将公共功能集中解决。-1" class="headerlink" title="第一、将复杂的需求分解出不同的方面，将公共功能集中解决。"></a>第一、将复杂的需求分解出不同的方面，将公共功能集中解决。</h4><p><img src="https://img-blog.csdnimg.cn/20200405224317485.png" alt="在这里插入图片描述"><br>在上图中，中间的是我们的代码，AOP就是将这些分离，包括权限，日志和持久化等等。</p>
<h4 id="第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能-1"><a href="#第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能-1" class="headerlink" title="第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能"></a>第二、采用代理机制组装起来运行，在不改变原程序的基础上对代码段进行增强处理，增加新的功能</h4><p><img src="https://img-blog.csdnimg.cn/20200405224343628.png" alt="image.png"><br>综上、所谓面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术。</p>
<h3 id="2-2AOP相关术语-1"><a href="#2-2AOP相关术语-1" class="headerlink" title="2.2AOP相关术语"></a>2.2AOP相关术语</h3><p><strong>1、增强处理：前置增强、后置增强、环绕增强、异常抛出增强、最终增强等类型<br>2、切入点<br>3、连接点<br>4、切面<br>5、目标对象<br>6、AOP代理<br>7、织入</strong></p>
<h4 id="1、增强处理-1"><a href="#1、增强处理-1" class="headerlink" title="1、增强处理"></a>1、增强处理</h4><p><img src="https://img-blog.csdnimg.cn/20200405224354319.png" alt="image.png"></p>
<h4 id="2、切入点-1"><a href="#2、切入点-1" class="headerlink" title="2、切入点"></a>2、切入点</h4><p>通过一个表达式告诉SpringAOP去哪个地方进行增强。也可以把这个表达式理解为一个查询条件，系统会根据这个查询条件查询到我们要进行增强的代码位置。</p>
<h4 id="3、连接点-1"><a href="#3、连接点-1" class="headerlink" title="3、连接点"></a>3、连接点</h4><p>就是SpringAOP通过告诉它的切入点的位置找的的具体的要增强的代码的位置，这个代码位置就是连接点。</p>
<h4 id="4、切面-1"><a href="#4、切面-1" class="headerlink" title="4、切面"></a>4、切面</h4><p>切面由一组（增强处理和切入点）共同构成。</p>
<h4 id="5、目标对象-1"><a href="#5、目标对象-1" class="headerlink" title="5、目标对象"></a>5、目标对象</h4><p>目标对象就是被增强的目标类。我们也称之为委托类。</p>
<h4 id="6、AOP代理-1"><a href="#6、AOP代理-1" class="headerlink" title="6、AOP代理"></a>6、AOP代理</h4><p><img src="https://img-blog.csdnimg.cn/20200405224405729.png" alt="image.png"></p>
<p>代理类就是AOP代理，里面包含了目标对象以及一些增强处理。系统会用AOP代理类代替委托类去执行功能。</p>
<h4 id="7、织入-1"><a href="#7、织入-1" class="headerlink" title="7、织入"></a>7、织入</h4><p>织入就是将我们的增强处理增强到指定位置的过程。</p>
<p>原文链接：<a href="https://www.jianshu.com/p/469540f13f5f" target="_blank" rel="noopener">https://www.jianshu.com/p/469540f13f5f</a></p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>常用的几个vagrant命令</title>
    <url>/post/2828478489.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vagrant init      <span class="comment"># 初始化</span></span><br><span class="line"></span><br><span class="line">$ vagrant up        <span class="comment"># 启动虚拟机</span></span><br><span class="line">$ vagrant halt      <span class="comment"># 关闭虚拟机</span></span><br><span class="line">$ vagrant reload    <span class="comment"># 重启虚拟机</span></span><br><span class="line">$ vagrant ssh       <span class="comment"># SSH 至虚拟机</span></span><br><span class="line">$ vagrant <span class="built_in">suspend</span>   <span class="comment"># 挂起虚拟机</span></span><br><span class="line">$ vagrant resume    <span class="comment"># 唤醒虚拟机</span></span><br><span class="line">$ vagrant status    <span class="comment"># 查看虚拟机运行状态</span></span><br><span class="line">$ vagrant destroy   <span class="comment"># 销毁当前虚拟机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#box管理命令</span></span><br><span class="line">$ vagrant box list    <span class="comment"># 查看本地box列表</span></span><br><span class="line">$ vagrant box add     <span class="comment"># 添加box到列表</span></span><br><span class="line"></span><br><span class="line">$ vagrant box remove  <span class="comment"># 从box列表移除</span></span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://www.cnblogs.com/think-a-lot/p/7754328.html" target="_blank" rel="noopener">https://www.cnblogs.com/think-a-lot/p/7754328.html</a></p>
]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>go-grpc调试工具grpcui</title>
    <url>/post/2929107307.html</url>
    <content><![CDATA[<p>写Grpc服务端接口的时候有个麻烦的地方就是如何调试的问题，不像http接口直接用Postman进行接口调试，可以借助第三方调试工具grpcui来实现类似的调试效果</p>
<p>github源码地址：<br><a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">https://github.com/fullstorydev/grpcui</a></p>
<h2 id="grpcui-使用"><a href="#grpcui-使用" class="headerlink" title="grpcui 使用"></a>grpcui 使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据官方 README.md 文档安装即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/fullstorydev/grpcui</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br></pre></td></tr></table></figure>

<p>这时，在 $GOPATH/bin 目录下，生成一个 grpcui 可执行文件。</p>
<p>执行个命令，验证下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grpcui -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    grpcui [flags] [address]</span><br><span class="line">    </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>表示安装成功了。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>grpcui -plaintext grpc项目域名/ip+端口号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:50051</span><br></pre></td></tr></table></figure>

<p>例如我本地启动的grpc服务端如下端口为50051<br><img src="http://images.tiance.club/resource/images/pasted-8.png" alt="upload successful"> </p>
<p>直接在window运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:50051</span><br></pre></td></tr></table></figure>
<p><img src="http://images.tiance.club/resource/images/pasted-9.png" alt="upload successful"> </p>
<p>浏览器打开即可看到如下效果<br><img src="http://images.tiance.club/resource/images/pasted-11.png" alt="upload successful"> </p>
<p>因为grpcui给出的ui端口是随机的，我本地是采用vagrant+VirtualBox，端口映射需要启动的时候就指定了，所以我这里服务端的项目依旧在linux下运行，但是grpcui命令我就直接在window（宿主机运行），把编译好的grpcui二进制文件直接放在window的Path环境变量目录即可<br><img src="http://images.tiance.club/resource/images/pasted-10.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>为什么一定要用MQ中间件？</title>
    <url>/post/1626959203.html</url>
    <content><![CDATA[<p>这篇文章我们会把消息中间件这块高频的面试问题来给大家说一下，也会涵盖一些 MQ 中间件常见的技术问题。</p>
<p>假如说面试官看你简历里写了 MQ 中间件的使用经验，很可能会有如下的问题：</p>
<p>你们公司生产环境用的是什么消息中间件?<br>为什么要在系统架构中引入消息中间件?<br>引入消息中间件之后会有什么好处以及坏处?<br>好，下面我们一个个的来分析!</p>
<p><strong>你们公司生产环境用的是什么消息中间件?</strong></p>
<p>这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是 RabbitMQ，然后可以初步给一些你对不同 MQ 中间件技术的选型分析。</p>
<p>举个例子：比如说 ActiveMQ 是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。</p>
<p>但是问题在于没法确认 ActiveMQ 可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用 ActiveMQ 做异步调用和系统解耦。</p>
<p>然后你可以说说 RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。</p>
<p>另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</p>
<p>而且经过调研，国内各大互联网公司落地大规模 RabbitMQ 集群支撑自身业务的 case 较多，国内各种中小型互联网公司使用 RabbitMQ 的实践也比较多。</p>
<p>除此之外，RabbitMQ 的开源社区很活跃，较高频率的迭代版本，来修复发现的 Bug 以及进行各种优化，因此综合考虑过后，公司采取了 RabbitMQ。</p>
<p>但是 RabbitMQ 也有一点缺陷，就是他自身是基于 Erlang 语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的 Erlang 语言功底才可以。</p>
<p>然后可以聊聊 RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。</p>
<p>而且 RocketMQ 是基于 Java 语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</p>
<p>另外就是 Kafka。Kafka 提供的消息中间件的功能明显较少一些，相对上述几款 MQ 中间件要少很多。</p>
<p>但是 Kafka 的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。</p>
<p>因此 Kafka 在大数据领域中配合实时计算技术(比如 Spark Streaming、Storm、Flink)使用的较多。但是在传统的 MQ 中间件使用场景中较少采用。</p>
<p>PS：如果大家对上述一些 MQ 技术还没在自己电脑部署过，没写几个 helloworld 体验一下的话，建议先上各个技术的官网找到 helloworld demo，自己跑一遍玩玩。</p>
<p><strong>为什么在你们系统架构中要引入消息中间件?</strong></p>
<p>回答这个问题，其实就是让你先说说消息中间件的常见使用场景。然后结合你们自身系统对应的使用场景，说一下在你们系统中引入消息中间件解决了什么问题。</p>
<p><font color='red'> <strong>1. 系统解耦</strong></font></p>
<p>假设你有个系统 A，这个系统 A 会产出一个核心数据，现在下游有系统 B 和系统 C 需要这个数据。那简单，系统 A 就是直接调用系统 B 和系统 C 的接口发送数据给他们就好了。</p>
<p>整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321224517720.png" alt="在这里插入图片描述"><br>但是现在要是来了系统 D、系统 E、系统 F、系统 G，等等，十来个其他系统慢慢的都需要这份核心数据呢?如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321224622217.png" alt="在这里插入图片描述"><br>大家可别以为这是开玩笑，一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应 N 多个服务，这些系统与系统之间有着错综复杂的关系网络。</p>
<p>如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。</p>
<p>此时如果你要是采取上面那种模式来设计系统架构，那么绝对你负责系统 A 的同学要被烦死了。</p>
<p>先是来一个人找他要求发送数据给一个新的系统 H，系统 A 的同学要修改代码，然后在那个代码里加入调用新系统 H 的流程。</p>
<p>一会那个系统 B 是个陈旧老系统要下线了，告诉系统 A 的同学：别给我发送数据了，接着系统 A 再次修改代码不再给这个系统 B。</p>
<p>然后如果要是某个下游系统突然宕机了呢?系统 A 的调用代码里是不是会抛异常?</p>
<p>那系统A的同学会收到报警说异常了，结果他还要去 care 是下游哪个系统宕机了。</p>
<p>所以在实际的系统架构设计中，如果全部采取这种系统耦合的方式，在某些场景下绝对是不合适的，系统耦合度太严重。</p>
<p>并且互相耦合起来并不是核心链路的调用，而是一些非核心的场景(比如上述的数据消费)导致了系统耦合，这样会严重的影响上下游系统的开发和维护效率。</p>
<p>因此在上述系统架构中，就可以采用 MQ 中间件来实现系统解耦。系统 A 就把自己的一份核心数据发到 MQ 里，下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200321224649412.png" alt="在这里插入图片描述"></p>
<p><font color='red'> <strong>2. 异步调用</strong></font></p>
<p>假设你有一个系统调用链路，是系统 A 调用系统 B，一般耗时 20ms;系统 B 调用系统 C，一般耗时 200ms;系统 C 调用系统 D，一般耗时 2s，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321224720747.png" alt="面试大杀器：为什么一定要用MQ中间件？"></p>
<p>现在最大的问题就是：用户一个请求过来巨慢无比，因为走完一个链路，需要耗费 20ms + 200ms + 2000ms(2s) = 2220ms，也就是 2 秒多的时间。</p>
<p>但是实际上，链路中的系统 A 调用系统 B，系统 B 调用系统 C，这两个步骤起来也就 220ms。</p>
<p>就因为引入了系统 C 调用系统 D 这个步骤，导致最终链路执行时间是 2 秒多，直接将链路调用性能降低了 10 倍，这就是导致链路执行过慢的罪魁祸首。</p>
<p>那此时我们可以思考一下，是不是可以将系统 D 从链路中抽离出去做成异步调用呢?其实很多的业务场景是可以允许异步调用的。</p>
<p>举个例子，你平时点个外卖，咔嚓一下子下订单然后付款了，此时账户扣款、创建订单、通知商家给你准备菜品。</p>
<p>接着，是不是需要找个骑手给你送餐?那这个找骑手的过程，是需要一套复杂算法来实现调度的，比较耗时。</p>
<p>但是其实稍微晚个几十秒完成骑手的调度都是 ok 的，因为实际并不需要在你支付的一瞬间立马给你找好骑手，也没那个必要。</p>
<p>那么我们是不是就可以把找骑手给你送餐的这个步骤从链路中抽离出去，做成异步化的，哪怕延迟个几十秒，但是只要在一定时间范围内给你找到一个骑手去送餐就可以了。</p>
<p>这样是不是就可以让你下订单点外卖的速度变得超快?支付成功之后，直接创建好订单、账户扣款、通知商家立马给你准备做菜就 ok 了，这个过程可能就几百毫秒。</p>
<p>然后后台异步化的耗费可能几十秒通过调度算法给你找到一个骑手去送餐，但是这个步骤不影响我们快速下订单。</p>
<p>当然我们不是说那些大家熟悉的外卖平台的技术架构就一定是这么实现的，只不过是用一个生活中常见的例子给大家举例说明而已。</p>
<p>所以上面的链路也是同理，如果业务流程支持异步化的话，是不是就可以考虑把系统 C 对系统 D 的调用抽离出去做成异步化的，不要放在链路中同步依次调用。</p>
<p>这样，实现思路就是系统 A→系统 B→系统 C，直接就耗费 220ms 后直接成功了。</p>
<p>然后系统 C 就是发送个消息到 MQ 中间件里，由系统 D 消费到消息之后慢慢的异步来执行这个耗时 2s 的业务处理。通过这种方式直接将核心链路的执行性能提升了 10 倍。</p>
<p>整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200321224745792.png" alt="面试大杀器：为什么一定要用MQ中间件？"></p>
<p><font color='red'> <strong>3. 流量削峰</strong></font></p>
<p>假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在 8 核 16G 的机器的上，正常处理都是 ok 的，每秒几百请求是可以轻松抗住的。</p>
<p>但是如下图所示，在高峰期一下子来了每秒钟几千请求，瞬时出现了流量高峰，此时你的选择是要搞 10 台机器，抗住每秒几千请求的瞬时高峰吗?<br><img src="https://img-blog.csdnimg.cn/20200321224807846.png" alt="面试大杀器：为什么一定要用MQ中间件？"></p>
<p>那如果瞬时高峰每天就那么半个小时，接着直接就降低为了每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗?</p>
<p>大部分时候，每秒几百请求，一台机器就足够了，但是为了抗那每天瞬时的高峰，硬是部署了 10 台机器，每天就那半个小时有用，别的时候都是浪费资源的。<br><img src="https://img-blog.csdnimg.cn/20200321224827571.png" alt="面试大杀器：为什么一定要用MQ中间件？"><br>但是如果你就部署一台机器，那会导致瞬时高峰时，一下子压垮你的系统，因为绝对无法抗住每秒几千的请求高峰。</p>
<p>此时我们就可以用 MQ 中间件来进行流量削峰。所有机器前面部署一层 MQ，平时每秒几百请求大家都可以轻松接收消息。</p>
<p>一旦到了瞬时高峰期，一下涌入每秒几千的请求，就可以积压在 MQ 里面，然后那一台机器慢慢的处理和消费。</p>
<p>等高峰期过了，再消费一段时间，MQ 里积压的数据就消费完毕了。<br><img src="https://img-blog.csdnimg.cn/20200321224845864.png" alt="面试大杀器：为什么一定要用MQ中间件？"></p>
<p>这个就是很典型的一个 MQ 的用法，用有限的机器资源承载高并发请求。</p>
<p>如果业务场景允许异步削峰，高峰期积压一些请求在 MQ 里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。</p>
<p><strong>引入消息中间件之后会有什么好处以及坏处?</strong></p>
<p>如果你在系统架构里引入了消息中间件之后，会有哪些缺点?</p>
<p><font color='red'> <strong>1. 系统可用性降低</strong></font></p>
<p>首先是你的系统整体可用性绝对会降低，给你举个例子，我们就拿之前的一幅图来说明。</p>
<p>比如说一个核心链路里面，系统 A→系统 B→系统 C，然后系统 C 是通过 MQ 异步调用系统 D 的。<br><img src="https://img-blog.csdnimg.cn/20200321224958483.png" alt="在这里插入图片描述"><br>看起来很好，你用这个 MQ 异步化的手段解决了一个核心链路执行性能过差的问题。</p>
<p>但是你有没有考虑另外一个问题，就是万一你依赖的那个 MQ 中间件突然挂掉了怎么办?</p>
<p>这个还真的不是异想天开，MQ、Redis、MySQL 这些组件都有可能会挂掉。一旦你的 MQ 挂了，就导致你的系统的核心业务流程中断了。</p>
<p>本来你要是不引入 MQ 中间件，那其实就是一些系统之间的调用，但是现在你引入了 MQ，就导致你多了一个依赖。一旦多了一个依赖，就会导致你的可用性降低。</p>
<p>因此，一旦引入了 MQ 中间件，你就必须去考虑这个 MQ 是如何部署的，如何保证高可用性。</p>
<p>甚至在复杂的高可用的场景下，你还要考虑如果 MQ 一旦挂了以后，你的系统有没有备用兜底的技术方案，可以保证系统继续运行下去。</p>
<p><font color='red'><strong>2. 系统稳定性降低</strong></font></p>
<p>还是上面那张图，大家再来看一下：<br><img src="https://img-blog.csdnimg.cn/20200321225033424.png" alt="在这里插入图片描述"></p>
<p>不知道大家有没有发现一个问题，这个链路除了 MQ 中间件挂掉这个可能存在的隐患之外，可能还有一些其他的技术问题。</p>
<p>比如说，莫名其妙的，系统 C 发了一个消息到 MQ，结果那个消息因为<font color='red'>网络故障</font>等问题，就丢失了。这就导致系统 D 没有收到那条消息。</p>
<p>这可就惨了，这样会导致系统 D 没完成自己该做的任务，此时可能整个系统会出现业务错乱，数据丢失，严重的 Bug，用户体验很差等各种问题。</p>
<p>这还只是其中之一，万一说系统 C 给 MQ 发送消息，不小心一抽风<font color='red'>重复发了一条一模一样的</font>，导致消息重复了，这个时候该怎么办?</p>
<p>可能会导致系统 D 一下子把一条数据插入了两次，导致数据错误，脏数据的产生，最后一样会导致各种问题。</p>
<p>或者说如果系统 D 突然宕机了几个小时，导致无法消费消息，结果大量的消息在 MQ 中间件里积压了很久，这个时候怎么办?</p>
<p>即使系统 D 恢复了，也需要慢慢的消费数据来进行处理。所以这就是引入 MQ 中间件的第二个大问题，系统稳定性可能会下降，故障会增多，各种各样乱七八糟的问题都可能产生。</p>
<p>而且一旦产生了一个问题，就会导致系统整体出问题。你就需要为了解决各种 MQ 引发的技术问题，采取很多的技术方案。</p>
<p>关于这个，我们后面会用专门的文章聊聊 MQ 中间件的这些问题的解决方案，包括：</p>
<ul>
<li><strong>消息高可靠传递(0 丢失)</strong></li>
<li><strong>消息幂等性传递(绝对不重复)</strong></li>
<li><strong>百万消息积压的线上故障处理</strong></li>
</ul>
<p><font color='red'><strong>3. 分布式一致性问题</strong></font></p>
<p>引入消息中间件，还有分布式一致性的问题。举个例子，比如说系统 C 现在处理自己本地数据库成功了，然后发送了一个消息给 MQ，系统 D 也确实是消费到了。</p>
<p>但是结果不幸的是，系统 D 操作自己本地数据库失败了，那这个时候咋办?</p>
<p>系统 C 成功了，系统 D 失败了，会导致系统整体数据不一致了啊。所以此时又需要使用可靠消息最终一致性的分布式事务方案来保障。</p>
<p>关于这个，可以参考之前的一篇文章：最终一致性分布式事务如何保障实际生产中 99.99% 高可用?</p>
<p>我们在里面详细阐述了系统之间异步调用场景下，如何采用分布式事务方案保证其数据一致性。</p>
<p><strong>总结</strong></p>
<p>最后，我们来做一个简单的小结。在面试中要答好这个问题，首先一定要熟悉 MQ 这个技术的优缺点。了解清楚把他引入系统是为了解决哪些问题的，但是他自身又会带来哪些问题。</p>
<p>此外，对于引入 MQ 以后，是否对他自身可能引发的问题有一些方案的设计，来保证你的系统高可用、高可靠的运行，保证数据的一致性。这个也要做好相应的准备。</p>
<p>原文链接：<a href="https://blog.csdn.net/u011277123/article/details/87803486" target="_blank" rel="noopener">https://blog.csdn.net/u011277123/article/details/87803486</a></p>
]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>yii2简单实现redis消息队列</title>
    <url>/post/1297686480.html</url>
    <content><![CDATA[<h5 id="生产者代码示例"><a href="#生产者代码示例" class="headerlink" title="生产者代码示例"></a>生产者代码示例</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  $data=[]; <span class="comment">//组装要推送队列的业务逻辑数据</span></span><br><span class="line">  $key=<span class="string">'redisKey'</span>;</span><br><span class="line">  $redis=Yii::$app-&gt;redis;  </span><br><span class="line">  $redis-&gt;lpush($key,json_encode($data));  </span><br><span class="line">  $redis-&gt;expire($key, <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="消费者代码示例"><a href="#消费者代码示例" class="headerlink" title="消费者代码示例"></a>消费者代码示例</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $redis=Yii::$app-&gt;redis;</span><br><span class="line">        <span class="comment">//限制本次队列只有一个进程在操作</span></span><br><span class="line">        <span class="keyword">self</span>::lockLimit(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOCK_KEY,<span class="number">2</span>,<span class="number">60</span>*<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//获取当前队列长度</span></span><br><span class="line">        $length = $redis-&gt;llen(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOG_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$length;$i++)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            $record = $redis-&gt;rpop(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOG_KEY);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">empty</span>($record))&#123;</span><br><span class="line">                <span class="comment">//处理业务逻辑</span></span><br><span class="line">                $record_decode=json_decode($record,<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(\Throwable $e)&#123;</span><br><span class="line">            <span class="comment">//判断重试次数，这里设置超过3次重试就不再重试</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">isset</span>($record_decode[<span class="string">'try_count'</span>]))$record_decode[<span class="string">'try_count'</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($record_decode[<span class="string">'try_count'</span>]) &amp;&amp; $record_decode[<span class="string">'try_count'</span>]&lt;<span class="number">3</span> )&#123;</span><br><span class="line">                ++$record_decode[<span class="string">'try_count'</span>];</span><br><span class="line">                $redis-&gt;lpush(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOG_KEY,json_encode($record_decode));</span><br><span class="line">                $redis-&gt;expire(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOG_KEY, <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打个日志记录</span></span><br><span class="line">            CoreHelper::write(json_encode([<span class="string">'handleRecordLogNew'</span>,$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Yii::$app-&gt;redis-&gt;del(<span class="keyword">self</span>::FUEL_LIST_RECORD_LOCK_KEY); <span class="comment">//业务逻辑处理完毕，解锁</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者取数据处理有另一种省性能的方案即Lrange+Lrem，这个具体还没实践过，逻辑上能减少redis连接次数，从而提高程序执行效率，等有空实践再补上。</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现消息队列</title>
    <url>/post/4033908611.html</url>
    <content><![CDATA[<p>队列本身其实是个有序的列表，而Redis是支持list的，可以利用redis的列表(List)来实现简单队列。</p>
<p><strong>一般有两种方式：</strong><br>1、LPUSH(头部插入)和RPOP(尾部弹出)<br>2、RPUSH(尾部插入)和LPOP(头部弹出)<br>两种均可，下面示例使用的是：第一种：LPUSH和RPOP。  </p>
<p><strong>一般开发的时候我们会分为生产者和消费者，生产者生产消息，消费者获取消息进行处理。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Producer: </span><br><span class="line">redis-&gt;lpush(‘joblist’, ‘this is Job-1’); </span><br><span class="line">redis-&gt;lpush(‘joblist’, ‘this is Job-2’); </span><br><span class="line">….</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cosumer: </span><br><span class="line">job = redis-&gt;rpop(‘joblist’);// <span class="built_in">return</span> Job-1 </span><br><span class="line"><span class="keyword">done</span> the job…. </span><br><span class="line">job = redis-&gt;rpop(‘joblist’);// <span class="built_in">return</span> Job-2 </span><br><span class="line"><span class="keyword">done</span> the job…</span><br></pre></td></tr></table></figure>
<p>需要注意的是redis实现的消息队列功能本身存在一些缺陷，这也是redis本身的限制，一个重要的缺陷在于没有类似RabbitMQ那样成熟的<strong>ACK消息确认机制</strong>（虽然redis也可以通过代码层自己封装写个ack消息确认机制，但相对比较繁杂。<strong>一般常见的思路是POP时将pop出的数据放到备份的地方，当有ACK请求（确认消息被消耗）后将备份的信息删除掉；每次在pop前需要检查备份队列中有没有过期的数据没有ack的，如果有则PUSH到list中后再从list中POP出来。</strong>）<br>一般来说如果对数据没有极高要求的又不想搭建其他QM组件的话可以直接用redis的list功能实现，如果对数据幂等性、一致性有要求的话建议使用<strong>RabbitMQ</strong>（目前功能最完善的企业级MQ产品，虽然吞吐量不是最强的，但足以应付绝大多数公司的流量）或者不想自己搭建的话也可以直接使用第三方的消息队列产品，比如阿里云的消息队列，安全性能均有保障。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>php之yii2简单分布式redis锁限制和缓存设置</title>
    <url>/post/2709942805.html</url>
    <content><![CDATA[<p>yii2框架简单加锁锁定本次任务没执行完之前不允许再请求本次方法，注意这只是简单实现能应对几乎所有并发场景。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体业务逻辑代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">business</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $key =<span class="string">'redis_key_name：'</span>.<span class="string">'订单id或其他本次锁的唯一值'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>::lockLimit($key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //这里需要用try catch，防止中途出异常，导致没解锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//具体处理的业务逻辑代码</span></span><br><span class="line">            Yii::$app-&gt;redis-&gt;del($key); <span class="comment">//业务逻辑处理完毕，解锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (\Throwable $e) &#123;</span><br><span class="line">            Yii::$app-&gt;redis-&gt;del($key); <span class="comment">//业务逻辑处理失败，还是解锁</span></span><br><span class="line">            <span class="comment">//日志方法，具体自己实现</span></span><br><span class="line">            CoreHelper::write(json_encode([<span class="string">'eventName'</span>,<span class="string">'order_id'</span>=&gt;$order-&gt;order_id??<span class="string">''</span>,$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis锁限制（设置锁的时间，具体看自己的业务场景，如果是限制手速的一般设置1秒，如果是限制本次情况处理完前不接受其他请求的一般设置120秒（一个接口请求一般不超过120秒））</span></span><br><span class="line"><span class="comment">     * $key 要限制的用户或订单唯一key值 （$key='redis_key_name：'.'订单id或其他本次锁的唯一值';）</span></span><br><span class="line"><span class="comment">     * $scene 场景 1、手速限制 2、处理事务限制</span></span><br><span class="line"><span class="comment">     * $expire 锁有效期，默认是有1和120秒的设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">lockLimit</span><span class="params">($key,$scene=<span class="number">2</span>,$expire=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        $redis=Yii::$app-&gt;redis;</span><br><span class="line">        $lock_result = $redis-&gt;setnx($key,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>($scene==<span class="number">1</span>)$redis-&gt;expire($key, <span class="keyword">empty</span>($expire)?<span class="number">1</span>:$expire);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断不是空直接中断本次操作</span></span><br><span class="line">        <span class="keyword">if</span> (!$lock_result) &#123;</span><br><span class="line">            <span class="comment">//随便你们return或其他友好输出，下面的输出只是个人示例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'-1000'</span>, <span class="string">"亲，太过频繁对身体不好"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($scene==<span class="number">2</span>)$redis-&gt;expire($key, <span class="keyword">empty</span>($expire)?<span class="number">120</span>:$expire);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$key=<span class="string">'redis_key_name'</span>;</span><br><span class="line">      $key_data=Yii::$app-&gt;redis-&gt;get($key);</span><br><span class="line">      <span class="comment">//判断不是空直接中断本次操作</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="keyword">empty</span>($key_data))&#123;</span><br><span class="line">          <span class="comment">//随便你们return或其他友好输出，下面的输出只是个人示例</span></span><br><span class="line">          retrun json_decode($key_data,<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里需要用try catch，防止中途出异常，导致没解锁</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//具体处理的业务逻辑代码</span></span><br><span class="line">            $data=[<span class="string">'内容'</span>];</span><br><span class="line">          <span class="comment">//确定没锁后先赋值redis，锁上先</span></span><br><span class="line">            Yii::$app-&gt;redis-&gt;set($key,json_encode($data));</span><br><span class="line">          Yii::$app-&gt;redis-&gt;expire($key, <span class="number">300</span>); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (\Throwable $e) &#123;</span><br><span class="line">          <span class="comment">//日志方法，具体自己实现</span></span><br><span class="line">          CoreHelper::write(json_encode([<span class="string">'eventName'</span>,<span class="string">'order_id'</span>=&gt;$order-&gt;order_id??<span class="string">''</span>,$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、Throwable为php7及以上版本的万能捕获任何异常，php7以下版本用：Exception<br>2、请确定自己已经在配置文件配置redis配置<br>    找到config/development.php(开发环境)或config/production.php(生产环境)，在’components’ =&gt; []中加入，如:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'components'</span> =&gt; [</span><br><span class="line">	<span class="string">'redis'</span> =&gt; [</span><br><span class="line">        <span class="string">'class'</span> =&gt; <span class="string">'BaseComponents\base\RedisConn'</span>,</span><br><span class="line">        <span class="string">'hostname'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'port'</span>     =&gt; <span class="number">6379</span>,</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>3、Yii如果找不到请在命名空间后加 use Yii;</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>yii2</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS -- 添加开机自启动 命令 脚本</title>
    <url>/post/2362243123.html</url>
    <content><![CDATA[<p>如果只是添加一条开机启动的命令:</p>
<ol>
<li><p>chmod +x /etc/rc.d/rc.local</p>
</li>
<li><p>将命令写到 /etc/rc.d/rc.local 这个文件中</p>
</li>
<li><p>reboot </p>
</li>
</ol>
<p>一、添加开机自启服务</p>
<p>在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> jenkins.service  <span class="comment">#设置jenkins服务为自启动服务</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysstemctl start  jenkins.service   <span class="comment">#启动jenkins服务</span></span><br></pre></td></tr></table></figure>


<p>二、添加开机自启脚本</p>
<p>在centos7中增加脚本有两种常用的方法，以脚本hexo-sever.sh为例（脚本文件）：<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /www/wwwroot/hexo</span><br><span class="line">nohup hexo s &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p>
<p>具体操作范例（添加脚本自启动）：</p>
<p>1、赋予脚本可执行权限（/www/wwwroot/hexo/hexo-sever.sh是你的脚本路径）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x /www/wwwroot/hexo/hexo-sever.sh</span><br></pre></td></tr></table></figure>


<p>2、打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加如下内容<br>su - user -c ‘/www/wwwroot/hexo/hexo-sever.sh’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/rc.local</span><br><span class="line">$ su - user -c <span class="string">'/www/wwwroot/hexo/hexo-sever.sh'</span></span><br></pre></td></tr></table></figure>

<p>3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p>具体参考原文：<a href="https://www.cnblogs.com/mafeng/p/10697303.html" target="_blank" rel="noopener">https://www.cnblogs.com/mafeng/p/10697303.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux修改时区</title>
    <url>/post/95235842.html</url>
    <content><![CDATA[<p>在.bash_profile里面设置 TZ=’Asia/Shanghai’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim .bash_profile</span><br></pre></td></tr></table></figure>

<p>最后date查看时区是否改变了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>php捕获异常方法</title>
    <url>/post/3232863668.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php捕获异常</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//希望被捕获的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (\Throwable $e) &#123;</span><br><span class="line">   <span class="comment">//日志方法，具体自己实现</span></span><br><span class="line">   CoreHelper::write(json_encode([<span class="string">'eventName'</span>,<span class="string">'order_id'</span>=&gt;$order-&gt;order_id??<span class="string">''</span>,$e-&gt;getMessage()], JSON_UNESCAPED_UNICODE)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：Throwable为php7及以上版本的万能捕获任何异常，php7以下版本用：Exception</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>TCP和UDP的区别和优缺点</title>
    <url>/post/3905120281.html</url>
    <content><![CDATA[<h2 id="1、TCP与UDP区别总结："><a href="#1、TCP与UDP区别总结：" class="headerlink" title="1、TCP与UDP区别总结："></a>1、TCP与UDP区别总结：</h2><p>1、TCP<strong>面向连接</strong>（如打电话要先拨号建立连接）;UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，<strong>通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达</strong>;<strong>UDP尽最大努力交付，即不保证可靠交付</strong></p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<p>3、<strong>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</strong>  </p>
<p>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、<strong>TCP对系统资源要求较多，UDP对系统资源要求较少。</strong></p>
<h2 id="2、为什么UDP有时比TCP更有优势"><a href="#2、为什么UDP有时比TCP更有优势" class="headerlink" title="2、为什么UDP有时比TCP更有优势?"></a>2、为什么UDP有时比TCP更有优势?</h2><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<p>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p>
<p>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</p>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<h2 id="3、UDP和TCP编程步骤也有些不同，如下："><a href="#3、UDP和TCP编程步骤也有些不同，如下：" class="headerlink" title="3、UDP和TCP编程步骤也有些不同，如下："></a>3、UDP和TCP编程步骤也有些不同，如下：</h2><p><strong>TCP:</strong><br><strong>TCP编程的服务器端</strong>一般步骤是：<br>　　1、创建一个socket，用函数socket()<br>　　2、设置socket属性，用函数setsockopt(); * 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、开启监听，用函数listen()；<br>　　5、接收客户端上来的连接，用函数accept()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接； closesocket(SocketListen);closesocket(SocketWaiter);<br>　　8、关闭监听；<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的。</p>
<p><strong>TCP编程的客户端</strong>一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；  </p>
<p><strong>UDP:</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：   </p>
<p><strong>UDP编程的服务器端</strong>一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接；   </p>
<p><strong>UDP编程的客户端</strong>一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；  </p>
<p>  原文链接：<a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702" target="_blank" rel="noopener">https://blog.csdn.net/xiaobangkuaipao/article/details/76793702</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>TCP粘包，产生的原因以及解决方案</title>
    <url>/post/144770649.html</url>
    <content><![CDATA[<h2 id="1、粘包的概念"><a href="#1、粘包的概念" class="headerlink" title="1、粘包的概念"></a>1、粘包的概念</h2><p><strong>粘包</strong>：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p><strong>TCP粘包</strong>：指发送方发送的若干数据包在接收方接收时粘成一团，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾</p>
<h2 id="2、出现粘包的原因"><a href="#2、出现粘包的原因" class="headerlink" title="2、出现粘包的原因"></a>2、出现粘包的原因</h2><p>出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。</p>
<p><strong>发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</strong></p>
<p><strong>接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</strong></p>
<h2 id="3、粘包的处理方式："><a href="#3、粘包的处理方式：" class="headerlink" title="3、粘包的处理方式："></a>3、粘包的处理方式：</h2><p>（1）当时短连接的情况下，不用考虑粘包的情况<br>（2）如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包<br>（3）如果双方建立长连接，需要在连接后一段时间内发送不同结构数据</p>
<p>接收方创建预处理线程，对接收到的数据包进行预处理，将粘连的包分开；</p>
<p>分包是指在出现粘包的时候我们的接收方要进行分包处理。（在长连接中都会出现） 数据包的边界发生错位，导致读出错误的数据分包，进而曲解原始数据含义。</p>
<p>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p>
<h2 id="如何处理TCP粘包和TCP拆包问题？"><a href="#如何处理TCP粘包和TCP拆包问题？" class="headerlink" title="如何处理TCP粘包和TCP拆包问题？"></a>如何处理TCP粘包和TCP拆包问题？</h2><p>无论是TCP拆包还是TCP粘包本质问题都在于无法区分包的界限，可以采用以下三种方式来区分包的界限</p>
<p>1.消息数据固定长度，但是浪费存储和网络资源</p>
<p>2.使用分割符来区分包的界限</p>
<p><strong>3.数据包的头部中增加数据包长度字段</strong></p>
<p>参考文章：<br><a href="https://blog.csdn.net/Nice07/article/details/83515660" target="_blank" rel="noopener">https://blog.csdn.net/Nice07/article/details/83515660</a><br><a href="https://www.cnblogs.com/yinbiao/p/11015039.html" target="_blank" rel="noopener">https://www.cnblogs.com/yinbiao/p/11015039.html</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
  </entry>
  <entry>
    <title>Elasticsearch的功能、适用场景以及特点介绍</title>
    <url>/post/3482167954.html</url>
    <content><![CDATA[<p>学习了什么是Elasticsearch之后，针对工程而言，我们更加关心的是Elasticsearch它能干什么？能在什么地方发挥作用？跟其它类似的东西相比它不同的地方在哪里?<br>归纳起来就是Elasticsearch在什么场景下，相比于其他类似的技术而言，它更适合做什么  </p>
<h2 id="1、Elasticsearch的功能"><a href="#1、Elasticsearch的功能" class="headerlink" title="1、Elasticsearch的功能"></a>1、Elasticsearch的功能</h2><h3 id="（1）分布式的搜索引擎和数据分析引擎"><a href="#（1）分布式的搜索引擎和数据分析引擎" class="headerlink" title="（1）分布式的搜索引擎和数据分析引擎"></a>（1）分布式的搜索引擎和数据分析引擎</h3><p>搜索：百度，网站的站内搜索，IT系统的检索<br>数据分析：电商网站，最近7天牙膏这种商品销量排名前十的商家有哪些；  新闻网站，最近一个月访问量排名前3的新闻板块是哪些  </p>
<h3 id="（2）全文检索，结构化检索，数据分析"><a href="#（2）全文检索，结构化检索，数据分析" class="headerlink" title="（2）全文检索，结构化检索，数据分析"></a>（2）全文检索，结构化检索，数据分析</h3><p>全文检索：我想搜索商品名称包含牙膏的商品，select * from products where product_name like “%牙膏%”<br>结构化检索：我想搜索商品分类为日化用品的商品有哪些，select * from products where category_id=”日化用品”<br>数据分析：我们分析每一个商品分类下有多少个商品，select category_id,count(*) from products group by category_id  </p>
<h3 id="（3）对海量数据进行近实时的处理"><a href="#（3）对海量数据进行近实时的处理" class="headerlink" title="（3）对海量数据进行近实时的处理"></a>（3）对海量数据进行近实时的处理</h3><p>分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索<br>海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了<br>近实时：检索个数据要花费1个小时（这就不叫做近实时，叫做离线批处理，batch-processing）;在秒级别对数据进行搜索和分析才叫做近实时</p>
<h2 id="2、Elasticsearch的适用场景"><a href="#2、Elasticsearch的适用场景" class="headerlink" title="2、Elasticsearch的适用场景"></a>2、Elasticsearch的适用场景</h2><p>国外：<br>（1）维基百科 全文检索、高亮、搜索推荐<br>（2）The Guardian(国外新闻网站) 用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他们知道他的文章的公众反馈（好、坏、热门。。。）<br>（3）Stack Overflow(国外程序异常讨论论坛)，全文检索，搜索到相关问题和答案，如果程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案<br>（4）github，搜索上千亿行的代码<br>（5）电商网站，检索商品<br>（6）日志数据的分析 elk技术<br>（7）商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户<br>（8）BI系统，商业智能Business Intelligence。比如有个大型商场集团，BI，分析一下某某地区最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表。  </p>
<p>国内<br>站内搜索（电商、招聘、门户等等）<br>IT系统搜索（OA、CRM、ERP等等）<br>数据分析</p>
<h2 id="3、Elasticsearch的特点"><a href="#3、Elasticsearch的特点" class="headerlink" title="3、Elasticsearch的特点"></a>3、Elasticsearch的特点</h2><p>（1）可以作为大型分布式集群（数百台服务器）技术，处理PB级的数据，服务大公司；也可以运行在单机上服务于小公司<br>（2）Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES：lucene(全文检索)，商用的数据分析软件，分布式数据库<br>（3）对用户而言，是开箱即用的，非常简单，作为中小型应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，此时的场景是数据量不大，操作不是太复杂<br>（4）数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如<strong>全文检索</strong>，<strong>同义词处理</strong>，<strong>相关度排名</strong>，<strong>复杂数据分析</strong>，<strong>海量数据的近实时处理</strong>，Elasticsearch作为传统数据库的一个补充，提供了数据库所不能提供的很多功能  </p>
<p>原文链接：<a href="https://segmentfault.com/a/1190000018876875" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018876875</a></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
  </entry>
  <entry>
    <title>Elasticsearch之curl操作PUT和POST区别</title>
    <url>/post/1704684589.html</url>
    <content><![CDATA[<p>  1.更新：PUT会将新的json值完全替换掉旧的；而POST方式只会更新相同字段的值，其他数据不会改变，新提交的字段若不存在则增加。</p>
<p>  2.PUT和DELETE操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有什么不同，DELETE也是一样。</p>
<p>  3.POST操作不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建了若干的资源。</p>
<p>  4.创建操作可以使用POST，也可以使用PUT，区别就在于POST是作用在一个集合资源(/articles)之上的，而PUT操作是作用在一个具体资源之上的(/articles/123)。</p>
<p>  原文链接：<a href="https://blog.csdn.net/kaaosidao/article/details/77489373" target="_blank" rel="noopener">https://blog.csdn.net/kaaosidao/article/details/77489373</a></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
  </entry>
  <entry>
    <title>win10设置开机自动启动vagrant虚拟机</title>
    <url>/post/3932398064.html</url>
    <content><![CDATA[<h4 id="1、自制bat脚本"><a href="#1、自制bat脚本" class="headerlink" title="1、自制bat脚本"></a>1、自制bat脚本</h4><p>将下面的命令复制到.bat后缀的文件中，如start_vagrant.bat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd /k <span class="string">"cd /d D: &amp;&amp; vagrant up"</span></span><br></pre></td></tr></table></figure>
<p>cmd /k “cd /d (vagrant虚拟机所在目录) &amp;&amp; vagrant up”</p>
<h4 id="2、设置bat脚本开机自动启动"><a href="#2、设置bat脚本开机自动启动" class="headerlink" title="2、设置bat脚本开机自动启动"></a>2、设置bat脚本开机自动启动</h4><p>1、设置bat脚本开机自动启动”窗口+R”打开命令窗口，并且输入命令<strong>Shell:startup</strong>，点击确定按钮运行该命令<br>2、将自制的bat启动脚本快捷方式放入文件夹中<br><img src="https://img-blog.csdnimg.cn/2020040809360539.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>php根据当前定位经纬度排序</title>
    <url>/post/1713014064.html</url>
    <content><![CDATA[<h3 id="php根据当前定位经纬度排序"><a href="#php根据当前定位经纬度排序" class="headerlink" title="php根据当前定位经纬度排序"></a>php根据当前定位经纬度排序</h3><p><strong>直接贴代码</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两组经纬度坐标 之间的距离</span></span><br><span class="line"><span class="comment">     * params ：lat1 纬度1； lng1 经度1； lat2 纬度2； lng2 经度2； len_type （1:m or 2:km);</span></span><br><span class="line"><span class="comment">     * return m or km</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">GetDistance</span><span class="params">($lat1, $lng1, $lat2, $lng2, $len_type = <span class="number">1</span>, $decimal = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defined(<span class="string">'EARTH_RADIUS'</span>) || define(<span class="string">'EARTH_RADIUS'</span>, <span class="number">6378.137</span>); <span class="comment">// 地球半径</span></span><br><span class="line">        defined(<span class="string">'PI'</span>) || define(<span class="string">'PI'</span>, <span class="number">3.1415926</span>);</span><br><span class="line">        $radLat1 = $lat1 * PI / <span class="number">180.0</span>;</span><br><span class="line">        $radLat2 = $lat2 * PI / <span class="number">180.0</span>;</span><br><span class="line">        $a       = $radLat1 - $radLat2;</span><br><span class="line">        $b       = ($lng1 * PI / <span class="number">180.0</span>) - ($lng2 * PI / <span class="number">180.0</span>);</span><br><span class="line">        $s       = <span class="number">2</span> * asin(sqrt(pow(sin($a / <span class="number">2</span>), <span class="number">2</span>) + cos($radLat1) * cos($radLat2) * pow(sin($b / <span class="number">2</span>), <span class="number">2</span>)));</span><br><span class="line">        $s       = $s * EARTH_RADIUS;</span><br><span class="line">        $s       = round($s * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> ($len_type &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            $s /= <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> round($s, $decimal);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两组经纬度对比中间的距离 lat1 纬度1； lng1 经度1为第一组，lat2 纬度2； lng2 经度2为第二组，不管两组顺序怎么调换，结果距离都是一样。<br><strong>另外还有mysql版根据当前定位经纬度排序在我的博客中也有写，文章地址：</strong><br><a href="https://wangzhuanglin.gitee.io/post/2178671104.html" target='_blank'>https://wangzhuanglin.gitee.io/post/2178671104.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>mysql根据当前定位经纬度排序</title>
    <url>/post/2178671104.html</url>
    <content><![CDATA[<p>网上流行的大概有两种sql写法，发现两种计算的结果不一样，也就是有一种不是很准确，试了下百度在线api计算结果，发现第二种和百度在线api计算结果一致，应该是最正确的。这里简单的整理下这种。  </p>
<blockquote>
<p><strong>用户当前定位经纬度  纬度:$lat  (23.100571)  ,经度:$lng  (113.389937)</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">id</span>,</span><br><span class="line">	latitude,</span><br><span class="line">	longitude</span><br><span class="line">	<span class="keyword">round</span>((</span><br><span class="line">			<span class="number">2</span> * <span class="number">6378.137</span> * <span class="keyword">ASIN</span>(</span><br><span class="line">				<span class="keyword">SQRT</span>(</span><br><span class="line">				<span class="keyword">POW</span>( <span class="keyword">SIN</span>( <span class="keyword">PI</span>()*( $lat- latitude )/ <span class="number">360</span> ), <span class="number">2</span> )+ <span class="keyword">COS</span>( <span class="keyword">PI</span>()* $lat / <span class="number">180</span> )* <span class="keyword">COS</span>( latitude * <span class="keyword">PI</span>()/ <span class="number">180</span> )* <span class="keyword">POW</span>( <span class="keyword">SIN</span>( <span class="keyword">PI</span>()*( $lng- longitude )/ <span class="number">360</span> ), <span class="number">2</span> )))) * <span class="number">1000</span> </span><br><span class="line">	) <span class="keyword">AS</span> juli </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	<span class="keyword">table</span>(表名)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="string">`juli`</span></span><br></pre></td></tr></table></figure>

<p>这里的计算结果是米为单位，如果想要km为单位的话直接去掉最后面的 “<em>1000”,这里我是做了四拾伍入，不保留小数点，直接取整数米，如果只是排序的话建议不加round和</em>1000，提高sql执行效率。</p>
<p><strong>另外还有php版的根据当前定位经纬度排序具体文章地址：</strong><br><a href="https://wangzhuanglin.gitee.io/post/1713014064.html" target='_blank'>https://wangzhuanglin.gitee.io/post/1713014064.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PhpStorm配置使用phpunit单元测试</title>
    <url>/post/2488698508.html</url>
    <content><![CDATA[<h4 id="本人的php本地开发环境是vagrant-VirtualBox，php7-0版本-phpunit6-5-3版本"><a href="#本人的php本地开发环境是vagrant-VirtualBox，php7-0版本-phpunit6-5-3版本" class="headerlink" title="本人的php本地开发环境是vagrant+VirtualBox，php7.0版本 phpunit6.5.3版本"></a>本人的php本地开发环境是vagrant+VirtualBox，php7.0版本 phpunit6.5.3版本</h4><p>学会php用单元测试调试对于代码后期调试还是很有帮助的，这里直接简单介绍本人的安装配置过程，不一定适合每个人，但是逻辑都差不多。本人的本地php版本是7.0，所以安装了phpunit6.5.3版本（再高就不支持了），如果php版本高的同学可以安装更高的phpunit版本。</p>
<h3 id="1、安装phpunit"><a href="#1、安装phpunit" class="headerlink" title="1、安装phpunit"></a>1、安装phpunit</h3><p>这里有两种方式，全局安装和局部安装，本人直接用局部安装</p>
<h4 id="1-全局安装phpunit命令脚本"><a href="#1-全局安装phpunit命令脚本" class="headerlink" title="1.全局安装phpunit命令脚本"></a>1.全局安装phpunit命令脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://phar.phpunit.de/phpunit-6.5.3.phar</span><br><span class="line">$ chmod +x phpunit-6.5.3.phar</span><br><span class="line">$ sudo mv phpunit-6.5.3.phar /usr/<span class="built_in">local</span>/bin/phpunit</span><br><span class="line">$ phpunit --version</span><br><span class="line">PHPUnit x.y.z by Sebastian Bergmann and contributors.</span><br></pre></td></tr></table></figure>
<h4 id="2-全局安装安装phpunit代码"><a href="#2-全局安装安装phpunit代码" class="headerlink" title="2.全局安装安装phpunit代码"></a>2.全局安装安装phpunit代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://phar.phpunit.de/phpunit-6.5.3.phar</span><br><span class="line">$ php phpunit-6.5.3.phar --version</span><br><span class="line">PHPUnit x.y.z by Sebastian Bergmann and contributors.</span><br></pre></td></tr></table></figure>

<p>下载phpunit.phar文件包，<br>linux直接下载命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://phar.phpunit.de/phpunit-6.5.3.phar</span><br></pre></td></tr></table></figure>
<p>或者直接简单暴力直接下载<br><img src="https://img-blog.csdnimg.cn/20200313183558963.png" alt="在这里插入图片描述"><br>我直接归类将phpunit6.5.3.phar放在下面的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># cd /home/dev_tool/php/</span></span><br><span class="line">[root@localhost php]<span class="comment"># ls</span></span><br><span class="line">phpunit-6.5.3.phar</span><br></pre></td></tr></table></figure>


<h3 id="2、Phpstorm配置phpunit"><a href="#2、Phpstorm配置phpunit" class="headerlink" title="2、Phpstorm配置phpunit"></a>2、Phpstorm配置phpunit</h3><p>话不多说，直接上截图吧！  </p>
<p><img src="http://images.tiance.club/resource/images/pasted-6.png" alt="upload successful"> </p>
<p><img src="http://images.tiance.club/resource/images/pasted-5.png" alt="upload successful"> </p>
<p><img src="http://images.tiance.club/resource/images/pasted-7.png" alt="upload successful">  </p>
<p>到了这来就配置完毕！</p>
<h3 id="3、phpstrom直接生成单元测试case"><a href="#3、phpstrom直接生成单元测试case" class="headerlink" title="3、phpstrom直接生成单元测试case"></a>3、phpstrom直接生成单元测试case</h3><h4 id="1、直接点击对应要生成的单元测试的方法一键生成"><a href="#1、直接点击对应要生成的单元测试的方法一键生成" class="headerlink" title="1、直接点击对应要生成的单元测试的方法一键生成"></a>1、直接点击对应要生成的单元测试的方法一键生成</h4><p><img src="http://images.tiance.club/20200314222439.png" alt="alt"> </p>
<h4 id="2、这里安装的PHPUnit是6-5版本，所以要选择PHPUint6"><a href="#2、这里安装的PHPUnit是6-5版本，所以要选择PHPUint6" class="headerlink" title="2、这里安装的PHPUnit是6.5版本，所以要选择PHPUint6+"></a>2、这里安装的PHPUnit是6.5版本，所以要选择PHPUint6+</h4><p><img src="http://images.tiance.club/20200314222648.png" alt="alt">   </p>
<h4 id="3、直接对着单元测试方法点击运行即可"><a href="#3、直接对着单元测试方法点击运行即可" class="headerlink" title="3、直接对着单元测试方法点击运行即可"></a>3、直接对着单元测试方法点击运行即可</h4><p><img src="http://images.tiance.club/20200314223714.png" alt="alt"><br>第三点也可以直接在命令行执行，具体命令如下：<br>具体测试命令<br>phpunit –filter methodName ClassName path/to/file.php<br>phpunit –filter 模块名 类名 具体单元测试所在文件<br>phpunit –filter testTwo StackTest TestController.php<br><img src="http://images.tiance.club/20200314224502.png" alt="alt"> </p>
<p><img src="http://images.tiance.club/20200314224732.png" alt="alt"> </p>
]]></content>
      <categories>
        <category>phpStorm</category>
      </categories>
  </entry>
  <entry>
    <title>php计算两个日期相隔多少年，多少月，多少天</title>
    <url>/post/2705668210.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*function：计算两个日期相隔多少年，多少月，多少天</span></span><br><span class="line"><span class="comment">*param string $date1[格式如：2011-11-5]</span></span><br><span class="line"><span class="comment">*param string $date2[格式如：2012-12-01]</span></span><br><span class="line"><span class="comment">*return array array('年','月','日');</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffDate</span><span class="params">($date1,$date2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strtotime($date1)&gt;strtotime($date2))&#123;</span><br><span class="line">        $tmp=$date2;</span><br><span class="line">        $date2=$date1;</span><br><span class="line">        $date1=$tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list</span>($Y1,$m1,$d1)=explode(<span class="string">'-'</span>,$date1);</span><br><span class="line">    <span class="keyword">list</span>($Y2,$m2,$d2)=explode(<span class="string">'-'</span>,$date2);</span><br><span class="line">    $Y=$Y2-$Y1;</span><br><span class="line">    $m=$m2-$m1;</span><br><span class="line">    $d=$d2-$d1;</span><br><span class="line">    <span class="keyword">if</span>($d&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        $d+=(int)date(<span class="string">'t'</span>,strtotime(<span class="string">"-1 month $date2"</span>));</span><br><span class="line">        $m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($m&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        $m+=<span class="number">12</span>;</span><br><span class="line">        $Y--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'year'</span>=&gt;$Y,<span class="string">'month'</span>=&gt;$m,<span class="string">'day'</span>=&gt;$d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print_r(diffDate(&#39;2020-03-02&#39;,&#39;2020-03-10&#39;));exit;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [year] &#x3D;&gt; 0</span><br><span class="line">    [month] &#x3D;&gt; 0</span><br><span class="line">    [day] &#x3D;&gt; 8</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>docker批量删除镜像或容器</title>
    <url>/post/3458257055.html</url>
    <content><![CDATA[<p>docker批量删除容器、镜像</p>
<p>1、删除所有容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>

<p>2、删除所有镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>

<p>3、按条件删除镜像<br>　　没有打标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi `docker images -q | awk <span class="string">'/^&lt;none&gt;/ &#123; print $3 &#125;'</span>`</span><br></pre></td></tr></table></figure>

<p>镜像名包含关键字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi --force `docker images | grep doss-api | awk <span class="string">'&#123;print $3&#125;'</span>`    //其中doss-api为关键字</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://www.cnblogs.com/yanyouqiang/p/8301856.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanyouqiang/p/8301856.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Centos下安装docker</title>
    <url>/post/1001383450.html</url>
    <content><![CDATA[<p><strong>1、卸载旧版本</strong><br>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>


<p><strong>2、安装需要的软件包</strong>， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>

<p><strong>3、设置yum源（设置稳定的仓库）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">阿里云地址</span><br><span class="line">$ sudo yum-config-manager  \</span><br><span class="line">	--add-repo  \ </span><br><span class="line">	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">源地址，不建议使用</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p><strong>4、安装最新版本的 Docker Engine-Community 和 containerd</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p><strong>5、启动并加入开机启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>


<p><strong>6、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure>

<p><img src="http://images.tiance.club/resource/images/pasted-12.png" alt="upload successful"></p>
<p>参考文章：<br><a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a><br><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8370670.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>hexo添加百度统计</title>
    <url>/post/193856365.html</url>
    <content><![CDATA[<p>环境<br>操作系统： win10</p>
<p>前提<br>已经利用hexo3搭建好了个人博客网站。</p>
<p>步骤<br>主题next官网地址</p>
<p>①先在百度统计官网，注册一个账号，并且绑定好域名。</p>
<p>②再复制hm.js后面的字符串如图：<br><img src="http://images.tiance.club/20170501164521205.png" alt="alt"></p>
<p>③编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。<br><img src="http://images.tiance.club/20170501164618159.png" alt="alt"></p>
<p>至此完成。</p>
<p>接下来使用：<br>① hexo clean 清除已经生成的静态文件<br>②hexo g 生成静态文件<br>③hexo d 把静态文件部署到GitHub page</p>
<p>刚开始我以为是我的网站上可以看到百度统计的结果。原本是要到百度统计官网去看。    </p>
<p><img src="http://images.tiance.club/20170501164953147.png" alt="alt"></p>
<p>原文链接：<a href="https://blog.csdn.net/u013066244/article/details/71056834" target="_blank" rel="noopener">https://blog.csdn.net/u013066244/article/details/71056834</a></p>
]]></content>
      <categories>
        <category>hexo折腾</category>
      </categories>
  </entry>
  <entry>
    <title>vagrant package 打包自己的box镜像</title>
    <url>/post/299409888.html</url>
    <content><![CDATA[<p>关于如何在win下使用Vagrant和Virtual Box创建一台CentOS7虚拟机我的博客中有教程介绍：<br><a href="https://wangzhuanglin.gitee.io/post/2370098709.html">https://wangzhuanglin.gitee.io/post/2370098709.html</a>  </p>
<p>   搭建完毕后等虚拟机的细节都调整好后强烈建议打包成自己的镜像，以后需要在其他电脑安装虚拟机环境或者电脑的虚拟机出问题的时候可以直接一键还原，不然要重新搭建有点繁琐。</p>
<h6 id="1、查看虚拟机名称"><a href="#1、查看虚拟机名称" class="headerlink" title="1、查看虚拟机名称"></a>1、查看虚拟机名称</h6><p>去到虚拟机安装目录，执行命令：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vboxmanage list vms</span><br></pre></td></tr></table></figure>
<p>这里有可能提示：’vboxmanage’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。那是因为VirtualBox安装的时候没有将vboxmanage自动放入环境变量中，我们可以直接进入VirtualBox的安装目录执行这句命令，也就是VirtualBox.exe这个文件的同级目录  </p>
<p><img src="http://images.tiance.club/resource/images/pasted-4.png" alt="upload successful"></p>
<p>_default_1583637544209_19565  就是我本地的虚拟机名称，复制下这个名字，后面打包box镜像需要用到。</p>
<h6 id="2、执行打包命令"><a href="#2、执行打包命令" class="headerlink" title="2、执行打包命令"></a>2、执行打包命令</h6><p>vagrant自带打包命令，需要去到你的vagrant目录下，也就是vagrantFile文件目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ vagrant package –-base _default_1583637544209_19565 –-output CentOS20180119.box</span><br></pre></td></tr></table></figure>
<p>vagrant package –-base [虚拟机名称] –-output [打包后的box名称]   </p>
<h6 id="3、部署回自己的box环境"><a href="#3、部署回自己的box环境" class="headerlink" title="3、部署回自己的box环境"></a>3、部署回自己的box环境</h6><p>到上面第二步的时候已经打包完毕了，如果想在其他电脑部署自己的box很简单<br>先把box文件和Vagrantfile文件放到需要部署的磁盘目录下。<br>执行以下操作命令：<br>1、将box安装到vagrant容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant box add -name xuni CentOS20180119.box</span><br></pre></td></tr></table></figure>
<p>  vagrant box add -name [虚拟机名称] [box放置的位置]</p>
<p> 2、然后直接启动即可<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>Vagrant在win7/win10系统下搭建使用</title>
    <url>/post/2370098709.html</url>
    <content><![CDATA[<h5 id="vagrant是什么？"><a href="#vagrant是什么？" class="headerlink" title="vagrant是什么？"></a>vagrant是什么？</h5><p>   vagrant是一个操作虚拟机的工具.<br>   通过命令和配置文件来管理虚拟机,很快就能完成一套开发环境的部署,并可以打包传播,统一了开发环境,也解决了重复配置环境的麻烦.</p>
<h5 id="Vargant的好处"><a href="#Vargant的好处" class="headerlink" title="Vargant的好处"></a>Vargant的好处</h5><p>1.统一开发环境。<br>   一次配置打包，统一分发给团队成员，统一团队开发环境，解决诸如“编码问题”，“缺少模块”，“配置文件不同”带来的问题；</p>
<p>2.避免重复搭建开发环境。<br>   新员工加入，不用浪费时间搭建开发环境，快速加入开发，减少时间成本的浪费；</p>
<p>3.多个相互隔离开发环境。<br>   可以在不用box里跑不同的语言，或者编译安装同一语言不同版本，搭建多个相互隔离的开发环境，卸载清除时也很快捷轻松。</p>
<h5 id="win7-win10系统下使用流程"><a href="#win7-win10系统下使用流程" class="headerlink" title="win7/win10系统下使用流程"></a>win7/win10系统下使用流程</h5><h6 id="1、安装VirtualBox、vagrant两款软件"><a href="#1、安装VirtualBox、vagrant两款软件" class="headerlink" title="1、安装VirtualBox、vagrant两款软件"></a>1、安装VirtualBox、vagrant两款软件</h6><p>   直接到官网下载安装即可官网如下：<br>   <a href="https://www.virtualbox.org" target="_blank" rel="noopener">https://www.virtualbox.org</a><br>    <a href="https://www.vagrantup.com" target="_blank" rel="noopener">https://www.vagrantup.com</a><br>   官网范围速度比较慢，而且这两位软件不同版本可能会造成兼容问题，也就是有可能导致你的vagrant用起来出现一些莫名其妙的问题，所以最好是制定两款的版本安装。<br>   win10版本为：<br>   VirtualBox-5.2.12-122591-Win.exe<br>   vagrant_2.2.7_x86_64.msi  </p>
<h6 id="2、下载一个box镜像文件"><a href="#2、下载一个box镜像文件" class="headerlink" title="2、下载一个box镜像文件"></a>2、下载一个box镜像文件</h6><p>安装后需要下载一个box镜像文件，也就是linux的镜像（其实也可以在vagrant add安装的时候直接指定官方的镜像名称就会自动下载安装，但鉴于国内下载官方的速度太慢了，所以强烈鉴于先用迅雷之类的工具加速下载下来再本地安装）<br>   下载官网地址如下：<br>   <a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a><br>   如果是安装centos的话直接点击下面的链接直达：<br>   <a href="https://app.vagrantup.com/centos/boxes/7" target="_blank" rel="noopener">https://app.vagrantup.com/centos/boxes/7</a>  </p>
<h6 id="3、将镜像加载到vagrant容器中"><a href="#3、将镜像加载到vagrant容器中" class="headerlink" title="3、将镜像加载到vagrant容器中"></a>3、将镜像加载到vagrant容器中</h6><p>   执行如下命令：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   vagrant box add -name [虚拟机名称] [box放置的位置]</span><br></pre></td></tr></table></figure><br>   centos/7是虚拟机名称 最后的box放置位置直接写你下载后返的根目录即可，如果没指定的话，默认会自己从官网下载<br>   如：vagrant box add -name ‘centos/7’ [box放置的位置]</p>
<p>   下面是我自己放置的位置习惯：  </p>
<p><img src="http://images.tiance.club/resource/images/pasted-1.png" alt="upload successful"><br><img src="http://images.tiance.club/resource/images/pasted-0.png" alt="upload successful"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant box add xuni CentOS20200119.box</span><br></pre></td></tr></table></figure>

<h6 id="4、初始化虚拟机"><a href="#4、初始化虚拟机" class="headerlink" title="4、初始化虚拟机"></a>4、初始化虚拟机</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant init xuni</span><br></pre></td></tr></table></figure>
<p>vagrant init命令就是初始话命令<br>xuni 是指box的名称（也就是第三步[虚拟机名称]那个位置）</p>
<h6 id="5、启动虚拟机"><a href="#5、启动虚拟机" class="headerlink" title="5、启动虚拟机"></a>5、启动虚拟机</h6><p>初始话之后，就可以开始启动虚拟机，运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\&gt;vagrant up</span><br><span class="line">Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Importing base box &#39;xuni&#39;...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Matching MAC address for NAT networking...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Setting the name of the VM: _default_1583637544209_19565</span><br><span class="line">Vagrant is currently configured to create VirtualBox synced folders with</span><br><span class="line">the &#96;SharedFoldersEnableSymlinksCreate&#96; option enabled. If the Vagrant</span><br><span class="line">guest is not trusted, you may want to disable this option. For more</span><br><span class="line">information on this option, please refer to the VirtualBox manual:</span><br><span class="line"></span><br><span class="line">  https:&#x2F;&#x2F;www.virtualbox.org&#x2F;manual&#x2F;ch04.html#sharedfolders</span><br><span class="line"></span><br><span class="line">This option can be disabled globally with an environment variable:</span><br><span class="line"></span><br><span class="line">  VAGRANT_DISABLE_VBOXSYMLINKCREATE&#x3D;1</span><br><span class="line"></span><br><span class="line">or on a per folder basis within the Vagrantfile:</span><br><span class="line"></span><br><span class="line">  config.vm.synced_folder &#39;&#x2F;host&#x2F;path&#39;, &#39;&#x2F;guest&#x2F;path&#39;, SharedFoldersEnableSymlinksCreate: false</span><br><span class="line">&#x3D;&#x3D;&gt; default: Vagrant has detected a configuration issue which exposes a</span><br><span class="line">&#x3D;&#x3D;&gt; default: vulnerability with the installed version of VirtualBox. The</span><br><span class="line">&#x3D;&#x3D;&gt; default: current guest is configured to use an E1000 NIC type for a</span><br><span class="line">&#x3D;&#x3D;&gt; default: network adapter which is vulnerable in this version of VirtualBox.</span><br><span class="line">&#x3D;&#x3D;&gt; default: Ensure the guest is trusted to use this configuration or update</span><br><span class="line">&#x3D;&#x3D;&gt; default: the NIC type using one of the methods below:</span><br><span class="line">&#x3D;&#x3D;&gt; default:</span><br><span class="line">&#x3D;&#x3D;&gt; default:   https:&#x2F;&#x2F;www.vagrantup.com&#x2F;docs&#x2F;virtualbox&#x2F;configuration.html#default-nic-type</span><br><span class="line">&#x3D;&#x3D;&gt; default:   https:&#x2F;&#x2F;www.vagrantup.com&#x2F;docs&#x2F;virtualbox&#x2F;networking.html#virtualbox-nic-type</span><br><span class="line">&#x3D;&#x3D;&gt; default: Clearing any previously set network interfaces...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">    default: Adapter 2: hostonly</span><br><span class="line">&#x3D;&#x3D;&gt; default: You are trying to forward to privileged ports (ports &lt;&#x3D; 1024). Most</span><br><span class="line">&#x3D;&#x3D;&gt; default: operating systems restrict this to only privileged process (typically</span><br><span class="line">&#x3D;&#x3D;&gt; default: processes running as an administrative user). This is a warning in case</span><br><span class="line">&#x3D;&#x3D;&gt; default: the port forwarding doesn&#39;t work. If any problems occur, please try a</span><br><span class="line">&#x3D;&#x3D;&gt; default: port higher than 1024.</span><br><span class="line">&#x3D;&#x3D;&gt; default: Forwarding ports...</span><br><span class="line">    default: 22 (guest) &#x3D;&gt; 2222 (host) (adapter 1)</span><br><span class="line">&#x3D;&#x3D;&gt; default: Running &#39;pre-boot&#39; VM customizations...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Booting VM...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Waiting for machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2222</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: password</span><br><span class="line">    default: Warning: Connection reset. Retrying...</span><br><span class="line">    default: Warning: Connection aborted. Retrying...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Machine booted and ready!</span><br><span class="line">&#x3D;&#x3D;&gt; default: Checking for guest additions in VM...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Configuring and enabling network interfaces...</span><br><span class="line">&#x3D;&#x3D;&gt; default: Mounting shared folders...</span><br><span class="line">    default: &#x2F;vagrant &#x3D;&gt; D:&#x2F;</span><br></pre></td></tr></table></figure>
<p>看到这段内容时说明你的虚拟机已经正常安装启动完毕了！</p>
<h6 id="6、连接虚拟机"><a href="#6、连接虚拟机" class="headerlink" title="6、连接虚拟机"></a>6、连接虚拟机</h6><p>如果是使用官方基础镜像的话一开始是连不上的，需要先用ssh命令进入修改配置后才能连接修改配置如下<br>1、修改sshd_config配置<br>进入虚拟机中，登录的账号密码均为：vagrant<br>进入文件夹/etc/ssh，修改配置文件sshd_config<br>cd /etc/ssh<br>vi sshd_config  </p>
<p><img src="http://images.tiance.club/resource/images/pasted-2.png" alt="upload successful"></p>
<p>重启sshd.service服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>

<p>本地使用Xshell连接虚拟机，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh 127.0.0.1 2200</span><br></pre></td></tr></table></figure>
<p>在弹出的窗口，输入用户名和密码就进入了虚拟机。ssh表示连接的命令，127.0.0.1 2200可以从vagrant up的时候的输出命令中找到。</p>
<h6 id="7、使用xshell工具连接虚拟机"><a href="#7、使用xshell工具连接虚拟机" class="headerlink" title="7、使用xshell工具连接虚拟机"></a>7、使用xshell工具连接虚拟机</h6><p>也可以直接用官网的ssh命令直接连接，不过在win用ssh命令连接后还是在cmd窗口，以后开发不太方便，最好是用xshell工具连接。</p>
<p><img src="http://images.tiance.club/resource/images/pasted-3.png" alt="upload successful"><br>账号密码默认直接都是：vagrant 即可，（个人改成账号 root登录，密码还是vagrant）</p>
<p>到此就结束了，之后等镜像调整细节完毕后直接打包成自己的镜像，以后在其他电脑用或者本电脑虚拟机出问题的话，可以直接一键安装（相当于还原）<br>具体打包自己box的方法我博客中也有教程介绍  <a href="http://tiance.club/post/299409888.html" target="_blank" rel="noopener">http://tiance.club/post/299409888.html</a></p>
]]></content>
      <categories>
        <category>vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>PHP动态模式和静态模式区别</title>
    <url>/post/3986490219.html</url>
    <content><![CDATA[<p>php-fpm的进程数可以根据设置分为动态和静态。</p>
<p>静态：直接开启指定数量的php-fpm进程，不再增加或者减少；<br>动态：开始的时候开启一定数量php-fpm进程，当请求变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲进程数到一个下限。<br>这两种不同的执行方式，可以根据服务器实际需求来进行调整。</p>
<p>这里先说一下涉及到这个的几个参数，他们分别是pm\pm.max_children\pm.start_servers\pm.min_spare_servers和pm.max_spare_servers。</p>
<p>pm表示用哪种方式，有两个值可以选择，就是static静态或者dynamic动态。在老一些的版本中，dynamic又被称作apache-like。这个要注意看配置文件给出的说明了。</p>
<p>下面4个参数的意思分别为：</p>
<p>pm.max_children静态方式下开启的php-fpm进程数量；<br>pm.start_servers动态方式下的起始php-fpm进程数量；<br>pm.min_spare_servers动态方式下的最小php-fpm进程数量；<br>pm.max_spare_servers动态方式下的最大php-fpm进程数量。<br>如果将dm设置为static，那么就只有pm.max_children这个参数生效。系统会开启设置的数量个php-fpm进程。</p>
<p>如果将dm设置为dynamic，那么pm.max_children参数会失效，后面3个参数生效。系统会在php-fpm运行开始的时候启动pm.start_servers个php-fpm进程，然后根据系统需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数。</p>
<p>那么，对于我们的服务器，选择哪种执行方式比较好呢？事实和Apache一样，我们运行的PHP程序在执行完成后，或多或少都会有内存泄露的问题。这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20到30M的原因。所以，动态方式因为会结束掉多余进程，可以回收释放一些内存，所以推荐在内存较少的服务器上使用。具体最大数量根据物理内存总大小除以20M得到。比如说512M的VPS，建议pm.max_spare_servers值设置为20。而至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5到10之间。</p>
<p>对比较大内存的服务器来说，设置为静态的话会提高效率。因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量可以根据物理内存总大小除以30M得到。比如说2GB内存的服务器，可以设置为50；4GB内存可以设置为100等。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>Centos防火墙命令</title>
    <url>/post/3949464474.html</url>
    <content><![CDATA[<h3 id="centos7以上版本（firewalld）"><a href="#centos7以上版本（firewalld）" class="headerlink" title="centos7以上版本（firewalld）"></a>centos7以上版本（firewalld）</h3><p>查看防火墙状态：systemctl status firewalld.service<br>关闭防火墙命令：systemctl stop firewalld.service<br>开启防火墙：systemctl start firewalld.service<br>关闭开机自启动：systemctl disable firewalld.service<br>开启开机启动：systemctl enable firewalld.service</p>
<h3 id="centos7以下版本（iptables）"><a href="#centos7以下版本（iptables）" class="headerlink" title="centos7以下版本（iptables）"></a>centos7以下版本（iptables）</h3><p>查看防火墙状态：service iptables status  </p>
<p>停止防火墙：service iptables stop  </p>
<p>启动防火墙：service iptables start  </p>
<p>重启防火墙：service iptables restart  </p>
<p>永久关闭防火墙：chkconfig iptables off  </p>
<p>永久关闭后重启：chkconfig iptables on　　</p>
<p>2、开启80端口</p>
<p>vim /etc/sysconfig/iptables<br>加入如下代码<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>保存退出后重启防火墙</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/post/1563885333.html</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>相比WYSIWYG编辑器<br>优点：<br>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可<br>缺点：<br>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持Markdown编辑模式。  </p>
<p>一、标题<br>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。<br>示例：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><p>效果如下：<br>这是一级标题<br>这是二级标题<br>这是三级标题<br>这是四级标题<br>这是五级标题<br>这是六级标题</p>
<p>二、字体</p>
<p>加粗<br>要加粗的文字左右分别用两个*号包起来</p>
<p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p>
<p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<p>删除线<br>要加删除线的文字左右分别用两个 ~~ 号包起来  </p>
<p>示例：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**  </span><br><span class="line">*这是倾斜的文字*`  </span><br><span class="line">***这是斜体加粗的文字***  </span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del>  </p>
<p>三、引用<br>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用<br>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：  </p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>四、分割线<br>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：  </p>
<hr>
<hr>
<hr>
<hr>
<p>可以看到，显示效果是一样的。</p>
<p>五、图片<br>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">''</span>图片title<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p>
<p>示例：</p>
<p>效果如下：<br>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/" target="_blank" rel="noopener">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p>
<p>上传本地图片直接点击导航栏的图片标志，选择图片即可<br>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。markdown图床  </p>
<p>六、超链接<br>语法：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![超链接名](超链接地址 <span class="string">"超链接title"</span>)</span><br></pre></td></tr></table></figure>
<p>title可加可不加  </p>
<p>示例：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a>  </p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"超链接地址"</span> target=<span class="string">"_blank"</span>&gt;超链接名&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> target=<span class="string">"_blank"</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>七、列表<br>无序列表<br>语法：<br>无序列表用 - + * 任何一种都可以 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure>
<p>注意：- + * 跟内容之间都要有一个空格</p>
<p>效果如下：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<p>有序列表<br>语法：<br>数字加点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure>
<p>注意：序号跟内容之间要有空格</p>
<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<p>效果如下：  </p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<p>八、表格<br>语法：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure>

<p>效果如下：  </p>
<table>
<thead>
<tr>
<th>表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
<tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
</tbody></table>
<p>对齐方式<br>我们可以设置表格的对齐方式：</p>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>


<p>九、代码<br>语法：<br>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>
<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
<p>示例：<br>单行代码  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`create database hero;`</span><br></pre></td></tr></table></figure>

<p>代码块  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>效果如下：<br>单行代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>


<p>借鉴于原文：<a href="https://www.jianshu.com/p/191d1e21f7ed/" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed/</a></p>
]]></content>
      <categories>
        <category>其他编程</category>
      </categories>
  </entry>
  <entry>
    <title>PHP常见数学函数及BC高精度数学函数用法示例</title>
    <url>/post/968766046.html</url>
    <content><![CDATA[<p>本文实例讲述了PHP常见数学函数及BC高精度数学函数用法。分享给大家供大家参考，具体如下：</p>
<ol>
<li>bcadd 任意精度数的相加</li>
<li>bcsub 任意精度数的减法</li>
<li>bcmul 乘法， bcdiv除法 </li>
<li>bcmod 取余数。 （比%功能更强大）</li>
<li>bcpow 幂函数运算</li>
<li>bcsqrt 平方根</li>
<li>sqrt 平方根运算</li>
<li>pow求幂</li>
<li>abs 求绝对值</li>
<li>pi 得到圆周率数值</li>
</ol>
<h6 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h6><p>sin cos tan asin acos atan（用弧度表达）<br>deg2rad 角度转换成弧度<br>rad2deg 弧度转换成角度    </p>
<h6 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h6><p>log 求自然对数， log10 求10位底的对数<br>exp 以e为底的幂</p>
<h6 id="各种数制转换"><a href="#各种数制转换" class="headerlink" title="各种数制转换"></a>各种数制转换</h6><p>base_convert 通用的任意数制转换<br>bindec 二进制转换成十进制<br>decbin 十进制转换成二进制<br>dechex 十进制转换成十六进制<br>decoct 十进制转换成八进制<br>hexdec 十六进制转换成十进制<br>octdec 八进制转换成十进制  </p>
<p>BC高精确度函数用法示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *php BC高精确度函数库</span></span><br><span class="line"><span class="comment"> *php bc math 包含了：相加，比较，相除，相减，求余，相乘，n次方，配置默认小数点数目，求平方</span></span><br><span class="line"><span class="comment"> *这些函数在涉及到有关金钱的计算时比较有用</span></span><br><span class="line"><span class="comment"> ***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数比较</span></span><br><span class="line"><span class="comment"> *工作中遇到一种情况，0.00 ！= 0</span></span><br><span class="line"><span class="comment"> *int bccomp ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$left=$right 返回 0</span></span><br><span class="line"><span class="comment"> *$left&lt;$right 返回 -1</span></span><br><span class="line"><span class="comment"> *$left&gt;$right 返回 1</span></span><br><span class="line"><span class="comment"> *$scale 小数点位数</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line">$a = <span class="number">4.45</span>;</span><br><span class="line">$b = <span class="number">5.54</span>;</span><br><span class="line"><span class="keyword">if</span>(bccomp($a, $b, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">"完全相等"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数相加</span></span><br><span class="line"><span class="comment"> *string bcadd ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale 返回的小数点个数</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line">$a = <span class="number">1.0321456</span>;</span><br><span class="line">$b = <span class="number">0.0123456</span>;</span><br><span class="line">$c = bcadd($a, $b, <span class="number">2</span>);</span><br><span class="line">var_dump($c);</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数相减</span></span><br><span class="line"><span class="comment"> *sstring bcsub ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale 返回的小数点个数</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line">$a = <span class="number">1.0321456</span>;</span><br><span class="line">$b = <span class="number">3.0123456</span>;</span><br><span class="line">$c = bcsub($a, $b, <span class="number">2</span>);</span><br><span class="line">var_dump($c);</span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数求余/取模</span></span><br><span class="line"><span class="comment"> *string bcmod ( string $left_operand , string $modulus )</span></span><br><span class="line"><span class="comment"> *******************************************************/</span></span><br><span class="line">$a = <span class="number">6</span>;</span><br><span class="line">$b = <span class="number">4</span>;</span><br><span class="line">$c = bcmod($a, $b);</span><br><span class="line">var_dump($c);</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数相除</span></span><br><span class="line"><span class="comment"> *string bcdiv ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale小数点位数默认为 0</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line"> $a = <span class="number">6</span>;</span><br><span class="line"> $b = <span class="number">5</span>;</span><br><span class="line"> $c = bcdiv($a, $b, <span class="number">3</span>);</span><br><span class="line"> var_dump($c);</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数相乘</span></span><br><span class="line"><span class="comment"> *string bcmul ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale小数点位数默认为 0</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line">$a = <span class="number">3.1415926</span>;</span><br><span class="line">$b = <span class="number">2.4569874566</span>;</span><br><span class="line">$c = bcmul($a, $b, <span class="number">6</span>);</span><br><span class="line">var_dump($c);</span><br><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment"> *两个高精度数的次方值</span></span><br><span class="line"><span class="comment"> *string bcpow ( string $left_operand , string $right_operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale小数点位数默认为 0</span></span><br><span class="line"><span class="comment"> ***************************************************************************************/</span></span><br><span class="line">$a = <span class="number">3.1415926</span>;</span><br><span class="line">$b = <span class="number">2</span>;</span><br><span class="line">$c = bcpow($a, $b, <span class="number">3</span>);</span><br><span class="line">var_dump($c);</span><br><span class="line"><span class="comment">/**************************************************</span></span><br><span class="line"><span class="comment"> *求高精度数的平方根</span></span><br><span class="line"><span class="comment"> *string bcsqrt ( string $operand [, int $scale ] )</span></span><br><span class="line"><span class="comment"> *$scale小数点位数默认为 0</span></span><br><span class="line"><span class="comment"> ***************************************************/</span></span><br><span class="line">$b = bcsqrt($a, <span class="number">6</span>);</span><br><span class="line">var_dump($b);</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> *设置bc函数的小数点位数</span></span><br><span class="line"><span class="comment"> *bool bcscale ( int $scale )</span></span><br><span class="line"><span class="comment"> *$scale小数点位数默认为 0</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line">bcscale(<span class="number">2</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">string(<span class="number">4</span>) <span class="string">"1.04"</span></span><br><span class="line">string(<span class="number">5</span>) <span class="string">"-1.98"</span></span><br><span class="line">string(<span class="number">1</span>) <span class="string">"2"</span></span><br><span class="line">string(<span class="number">5</span>) <span class="string">"1.200"</span></span><br><span class="line">string(<span class="number">8</span>) <span class="string">"7.718853"</span></span><br><span class="line">string(<span class="number">5</span>) <span class="string">"9.869"</span></span><br><span class="line">string(<span class="number">8</span>) <span class="string">"1.772453"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo | 博客文章链接优化之abbrlink</title>
    <url>/post/4194944743.html</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>hexo的默认永久链接是在_config.yml里的配置permalink: :year/:month/:day/:title/。这种默认配置有个很不能接受的缺点，文件名为中文，会导致url链接里面出现中文。这次我来介绍一个比较方便好用的解决方案hexo-abbrlink插件。</p>
<h5 id="安装hexo-abbrlink插件"><a href="#安装hexo-abbrlink插件" class="headerlink" title="安装hexo-abbrlink插件"></a>安装hexo-abbrlink插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>然后在 Hexo 的根目录的配置文件_config.yml 中修改：</p>
<p>站点配置文件(_config.yml)里:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: post&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>
<p>使用hexo g 会自动在你的文章中加上abbrlink: fbf5310d</p>
]]></content>
      <categories>
        <category>hexo折腾</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 集成 Gitalk 评论系统</title>
    <url>/post/1180153653.html</url>
    <content><![CDATA[<h5 id="什么是-Gitalk"><a href="#什么是-Gitalk" class="headerlink" title="什么是 Gitalk"></a>什么是 Gitalk</h5><p>Gitalk 利用了 GithubAPI 基于 GitHub Issue 和 Preact 开发的评论插件，<br>官方网址： <a href="https://gitalk.github.io" target="_blank" rel="noopener">https://gitalk.github.io</a><br>官方中文文档： <a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">https://github.com/gitalk/gitalk/blob/master/readme-cn.md</a></p>
<h5 id="Gitalk-特性"><a href="#Gitalk-特性" class="headerlink" title="Gitalk 特性"></a>Gitalk 特性</h5><p>1、使用 GitHub 登录<br>2、支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]<br>3、支持个人或组织<br>4、无干扰模式（设置 distractionFreeMode 为 true 开启）<br>5、快捷键提交评论 （cmd|ctrl + enter）</p>
<h5 id="集成流程"><a href="#集成流程" class="headerlink" title="集成流程"></a>集成流程</h5><p>Hexo主题基本都继承Gitalk我们只需在在github上面注册对应的秘钥填入hexo主题的_config.yml配置即可。</p>
<p>*<em>1、在GitHub上注册新应用，链接：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>  *</em></p>
<p><img src="http://images.tiance.club/p22o24md.png" alt="alt"></p>
<p>参数说明：<br>Application name： # 应用名称，随意<br>Homepage URL： # 网站URL，如<a href="https://wangzhuanglin.gitee.io">https://wangzhuanglin.gitee.io</a><br>Application description # 描述，随意<br>Authorization callback URL：# 网站URL，<a href="https://wangzhuanglin.gitee.io">https://wangzhuanglin.gitee.io</a></p>
<p>点击注册后，页面跳转如下，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可：<br><img src="http://images.tiance.club/202003041513071.png" alt="alt"></p>
<p><strong>2、申请一个仓库做评论存储</strong><br><img src="http://images.tiance.club/20200304151938.png" alt="alt"></p>
<p>需要记住的是仓库名，到时需要填入hexo的_config.yml配置中</p>
<p><strong>3、打开对应hexo主题的_config.yml添加如下内容：</strong><br>gitalk:<br>  enable: true<br>  githubID: github帐号  # 例：asdfv1929<br>  repo: 仓库名称   # 例：blog<br>  ClientID: Client ID<br>  ClientSecret: Client Secret<br>  adminUser: github帐号 #指定可初始化评论账户<br>  distractionFreeMode: true</p>
]]></content>
      <categories>
        <category>hexo折腾</category>
      </categories>
  </entry>
  <entry>
    <title>linux压缩和解压缩命令</title>
    <url>/post/3363811620.html</url>
    <content><![CDATA[<p>tar  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解包：tar zxvf filename.tar  </span><br><span class="line">打包：tar czvf filename.tar dirname</span><br></pre></td></tr></table></figure>
<p>gz命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压1：gunzip filename.gz  </span><br><span class="line">解压2：gzip -d filename.gz  </span><br><span class="line">压缩：gzip filename</span><br></pre></td></tr></table></figure>

<p> .tar.gz 和  .tgz </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：tar zxvf filename.tar.gz  </span><br><span class="line">压缩：tar zcvf filename.tar.gz dirname  </span><br><span class="line">压缩多个文件：tar zcvf filename.tar.gz dirname1 dirname2   dirname3.....</span><br></pre></td></tr></table></figure>
<p>bz2命令  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压1：bzip2 -d filename.bz2  </span><br><span class="line">解压2：bunzip2 filename.bz2  </span><br><span class="line">压缩：bzip2 -z filename</span><br></pre></td></tr></table></figure>
<p>.tar.bz2 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：tar jxvf filename.tar.bz2  </span><br><span class="line">压缩：tar jcvf filename.tar.bz2 dirname</span><br></pre></td></tr></table></figure>
<p>bz命令  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压1：bzip2 -d filename.bz  </span><br><span class="line">解压2：bunzip2 filename.bz</span><br></pre></td></tr></table></figure>
<p>.tar.bz  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：tar jxvf filename.tar.bz</span><br></pre></td></tr></table></figure>
<p>z命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：uncompress filename.z  </span><br><span class="line">压缩：compress filename</span><br></pre></td></tr></table></figure>
<p>.tar.z  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：tar zxvf filename.tar.z  </span><br><span class="line">压缩：tar zcvf filename.tar.z dirname</span><br></pre></td></tr></table></figure>
<p>zip命令  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压：unzip filename.zip  </span><br><span class="line">    压缩：zip -r filename.zip dirname</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>在linux终端下快速删除输错的命令小技巧</title>
    <url>/post/2329327795.html</url>
    <content><![CDATA[<p>有时候在linux终端中执行某个命令时，往往会输错命令，想删除掉重敲可以按backspace键，但这样较慢，一种简便技巧是，按住esc键同时按backspace键会较快删除【esc+backspace】组合键。或者【ctrl+u】组合键</p>
<p>当然，直接回车更直接，但可能会产生一堆的错误提示。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux对一个目录及其子目录所有文件添加权限</title>
    <url>/post/1952161873.html</url>
    <content><![CDATA[<p>chmod -R 修改成的权限 要修改哪个文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod -R 777 /home/linux</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 单例模式</title>
    <url>/post/1062235890.html</url>
    <content><![CDATA[<p>单例模式也称单态，是23种设计模式中最简单的一种，从他的名字就可以知道他的核心思想，单例模式就是系统中只有一个这样的对象，对象只有一个，在Java或者C#中，单例模式一般有两种，分别是懒汉式、饿汉式，但是在PHP中常用的就是懒汉式，由于PHP是单线程的，懒汉式也不存在双重验证。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: LYL</span></span><br><span class="line"><span class="comment"> * Date: 2015/4/21</span></span><br><span class="line"><span class="comment"> * Time: 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**懒汉式</span></span><br><span class="line"><span class="comment"> * Class Singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//创建静态对象变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance=<span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> $age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数私有化，防止外部调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//克隆函数私有化，防止外部克隆对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//实例化对象变量方法，供外部调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>::$instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: wuzz</span></span><br><span class="line"><span class="comment"> * Date: 2018/12/24</span></span><br><span class="line"><span class="comment"> * Time: 4:10 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">"../Singleton/Singleton.php"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$single1=Singleton::getInstance();</span><br><span class="line">$single1-&gt;age=<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">$single2=Singleton::getInstance();</span><br><span class="line"></span><br><span class="line">$single2-&gt;age=<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"变量1的age:&#123;$single1-&gt;age&#125;&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"变量2的age:&#123;$single2-&gt;age&#125;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">结果两个<span class="keyword">echo</span>输出都是：<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，变量single2的age都是24，说明变量single2是一个变量，类Singleton是单例的。</p>
<p>通过以上代码，我可以整理编写单例模式的三个步骤：</p>
<p>1.创建一个类静态变量</p>
<p>2.私有化构造函数与克隆函数，防止外部调用</p>
<p>3.提供一个外部可以调用的静态方法，实例化第一步创建的静态变量</p>
<p>很明显，单例模式的适用场景就是系统中的对象只需要一个就可以的时候，例如，Java中Spring的Bean工厂，PHP中的数据库连接等等，只要有这种需求就首先单例模式。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 状态模式</title>
    <url>/post/1157327802.html</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>在软件开发过程中，应用程序可能会根据不同的情况作出不同的处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到。然后使用if… ellse语句来做状态判断来进行不同情况的处理。但是对复杂状态的判断就显得“力不从心了”。随着增加新的状态或者修改一个状体（if else(或switch case)语句的增多或者修改）可能会引起很大的修改，而程序的可读性，扩展性也会变得很弱。维护也会很麻烦。那么我就考虑只修改自身状态的模式。  </p>
<p>例子1：按钮来控制一个电梯的状态，一个电梯开们，关门，停，运行。每一种状态改变，都有可能要根据其他状态来更新处理。例如，开门状体，你不能在运行的时候开门，而是在电梯定下后才能开门。  </p>
<p>例子2：我们给一部手机打电话，就可能出现这几种情况：用户开机，用户关机，用户欠费停机，用户消户等。 所以当我们拨打这个号码的时候：系统就要判断，该用户是否在开机且不忙状态，又或者是关机，欠费等状态。但不管是那种状态我们都应给出对应的处理操作。  </p>
<h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h3><p>对象如何在每一种状态下表现出不同的行为？  </p>
<h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><p>状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。  </p>
<p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<h3 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4.适用性"></a>4.适用性</h3><p>在下面的两种情况下均可使用State模式:<br>if else(或switch case)语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</p>
<h3 id="5-结构"><a href="#5-结构" class="headerlink" title="5.结构"></a>5.结构</h3><p><img src="https://img-blog.csdnimg.cn/20200504213728865.png" alt="在这里插入图片描述"></p>
<h3 id="6-模式的组成"><a href="#6-模式的组成" class="headerlink" title="6.模式的组成"></a>6.模式的组成</h3><p>环境类（Context）:  定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。<br>抽象状态类（State）:  定义一个接口以封装与Context的一个特定状态相关的行为。<br>具体状态类（ConcreteState）:  每一子类实现一个与Context的一个状态相关的行为。</p>
<h3 id="7-效果"><a href="#7-效果" class="headerlink" title="7.效果"></a>7.效果</h3><p>State模式有下面一些效果:<br>状态模式的优点：<br>1 、 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来: State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中, 所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让 Context操作来显式地检查这些数据。但这样将会使整个Context的实现中遍布看起来很相似的条件if else语句或switch case语句。增加一个新的状态可能需要改变若干个操作, 这就使得维护变得复杂了。State模式避免了这个问题, 但可能会引入另一个问题, 因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些, 否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。它们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。 State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的 i f或s w i t c h语句中, 而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。<br>2、它使得状态转换显式化: 当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且, State对象可保证Context不会发生内部状态不一致的情况，因为从 Context的角度看，状态转换是原子的—只需重新绑定一个变量(即Context的State对象变量)，而无需为多个变量赋值</p>
<p>3、 State对象可被共享 如果State对象没有实例变量—即它们表示的状态完全以它们的类型来编码—那么各Context对象可以共享一个State对象。当状态以这种方式被共享时, 它们必然是没有内部状态, 只有行为的轻量级对象。</p>
<p><strong>状态模式的缺点:</strong>  </p>
<p>1) 状态模式的使用必然会增加系统类和对象的个数。<br>2) 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</p>
<h3 id="8-实现"><a href="#8-实现" class="headerlink" title="8.实现"></a>8.实现</h3><p>我们用电梯的例子来说明：</p>
<p>简单地实现代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ILift</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//电梯的四个状态  </span></span><br><span class="line">    <span class="keyword">const</span> OPENING_STATE = <span class="number">1</span>;  <span class="comment">//门敞状态  </span></span><br><span class="line">    <span class="keyword">const</span> CLOSING_STATE = <span class="number">2</span>;  <span class="comment">//门闭状态  </span></span><br><span class="line">    <span class="keyword">const</span> RUNNING_STATE = <span class="number">3</span>;  <span class="comment">//运行状态  </span></span><br><span class="line">    <span class="keyword">const</span> STOPPING_STATE = <span class="number">4</span>; <span class="comment">//停止状态；  </span></span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//设置电梯的状态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">setState</span><span class="params">($state)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//首先电梯门开启动作  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 电梯的实现类  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">extends</span>  <span class="title">ILift</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> $state;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setState</span><span class="params">($state)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;state = $state;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//电梯门关闭  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//电梯在什么状态下才能关闭  </span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">$this</span>-&gt;state)&#123;  </span><br><span class="line">            <span class="keyword">case</span> ILift::OPENING_STATE:  <span class="comment">//如果是则可以关门，同时修改电梯状态  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::CLOSING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::CLOSING_STATE:  <span class="comment">//如果电梯就是关门状态，则什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::RUNNING_STATE: <span class="comment">//如果是正在运行，门本来就是关闭的，也说明都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::STOPPING_STATE:  <span class="comment">//如果是停止状态，本也是关闭的，什么也不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">'Lift colse &lt;br&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门开启  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//电梯在什么状态才能开启  </span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">$this</span>-&gt;state)&#123;  </span><br><span class="line">            <span class="keyword">case</span> ILift::OPENING_STATE: <span class="comment">//如果已经在门敞状态，则什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以开启  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::OPENING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::RUNNING_STATE: <span class="comment">//正在运行状态，则不能开门，什么都不做  </span></span><br><span class="line">            <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::STOPPING_STATE: <span class="comment">//停止状态，淡然要开门了  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::OPENING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Lift open &lt;br&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">///电梯开始跑起来  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">$this</span>-&gt;state)&#123;  </span><br><span class="line">            <span class="keyword">case</span> ILift::OPENING_STATE: <span class="comment">//如果已经在门敞状态，则不你能运行，什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以运行  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::RUNNING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::RUNNING_STATE: <span class="comment">//正在运行状态，则什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::STOPPING_STATE: <span class="comment">//停止状态，可以运行  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::RUNNING_STATE);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Lift run &lt;br&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯停止  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">$this</span>-&gt;state)&#123;  </span><br><span class="line">            <span class="keyword">case</span> ILift::OPENING_STATE: <span class="comment">//如果已经在门敞状态，那肯定要先停下来的，什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则当然可以停止了  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::CLOSING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::RUNNING_STATE: <span class="comment">//正在运行状态，有运行当然那也就有停止了  </span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;setState(ILift::CLOSING_STATE);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ILift::STOPPING_STATE: <span class="comment">//停止状态，什么都不做  </span></span><br><span class="line">                <span class="comment">//do nothing;  </span></span><br><span class="line">                <span class="keyword">return</span> ;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Lift stop &lt;br&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">$lift = <span class="keyword">new</span> Lift();   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//电梯的初始条件应该是停止状态   </span></span><br><span class="line">$lift-&gt;setState(ILift::STOPPING_STATE);   </span><br><span class="line"><span class="comment">//首先是电梯门开启，人进去   </span></span><br><span class="line">$lift-&gt;open();   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//然后电梯门关闭   </span></span><br><span class="line">$lift-&gt;close();   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//再然后，电梯跑起来，向上或者向下   </span></span><br><span class="line">$lift-&gt;run();      </span><br><span class="line"> <span class="comment">//最后到达目的地，电梯挺下来   </span></span><br><span class="line">$lift-&gt;stop();</span><br></pre></td></tr></table></figure>
<p>显然我们已经完成了我们的基本业务操作，但是，我们在程序中使用了大量的switch…case这样的判断（if…else也是一样),首先是程序的可阅读性很差，其次扩展非常不方便。一旦我们有新的状态加入的话，例如新加通电和断点状态。我们势必要在每个业务方法里边增加相应的case语句。也就是四个函数open，close，run，stop都需要修改相应case语句。</p>
<p>状态模式：把不同状态的操作分散到不同的状态对象里去完成。看看状态类的uml类图：</p>
<p>代码实现：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 定义一个电梯的接口  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变换引起的功能变化  </span></span><br><span class="line">    <span class="keyword">protected</span>  $_context;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setContext</span><span class="params">(Context $context)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context = $context;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//首先电梯门开启动作  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 环境类:定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。 </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//定义出所有的电梯状态  </span></span><br><span class="line">    <span class="keyword">static</span>  $openningState = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span>  $closeingState = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span>  $runningState  = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span>  $stoppingState = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">self</span>::$openningState = <span class="keyword">new</span> OpenningState();  </span><br><span class="line">        <span class="keyword">self</span>::$closeingState = <span class="keyword">new</span> ClosingState();  </span><br><span class="line">        <span class="keyword">self</span>::$runningState =  <span class="keyword">new</span> RunningState();  </span><br><span class="line">        <span class="keyword">self</span>::$stoppingState = <span class="keyword">new</span> StoppingState();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//定一个当前电梯状态  </span></span><br><span class="line">    <span class="keyword">private</span>  $_liftState;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLiftState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_liftState;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLiftState</span><span class="params">($liftState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState = $liftState;  </span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState-&gt;setContext(<span class="keyword">$this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState-&gt;open();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState-&gt;close();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState-&gt;run();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_liftState-&gt;stop();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在电梯门开启的状态下能做什么事情  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 开启当然可以关闭了，我就想测试一下电梯门开关功能 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//状态修改  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$closeingState);  </span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;close();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//打开电梯门  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'lift open...'</span>, <span class="string">'&lt;br/&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//门开着电梯就想跑，这电梯，吓死你！  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//do nothing;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开门还不停止？  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//do nothing;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 电梯门关闭以后，电梯可以做哪些事情  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'lift close...'</span>, <span class="string">'&lt;br/&gt;'</span>;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$openningState);  <span class="comment">//置为门敞状态  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;open();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$runningState); <span class="comment">//设置为运行状态；  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;run();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$stoppingState);  <span class="comment">//设置为停止状态；  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;stop();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 电梯在运行状态下能做哪些动作  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//do nothing  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//do nothing  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'lift run...'</span>, <span class="string">'&lt;br/&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$stoppingState); <span class="comment">//环境设置为停止状态；  </span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;stop();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在停止状态下能做什么事情  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//停止状态关门？电梯门本来就是关着的！  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//do nothing;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$openningState);  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;open();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;setLiftState(Context::$runningState);  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;_context-&gt;getLiftState()-&gt;run();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'lift stop...'</span>, <span class="string">'&lt;br/&gt;'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模拟电梯的动作  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        $context = <span class="keyword">new</span> Context();  </span><br><span class="line">        $context-&gt;setLiftState(<span class="keyword">new</span> ClosingState());  </span><br><span class="line">  </span><br><span class="line">        $context-&gt;open();  </span><br><span class="line">        $context-&gt;close();  </span><br><span class="line">        $context-&gt;run();  </span><br><span class="line">        $context-&gt;stop();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">Client::main();</span><br></pre></td></tr></table></figure>


<p>参考文章：<a href="https://www.cnblogs.com/nnn123/p/6723729.html" target="_blank" rel="noopener">https://www.cnblogs.com/nnn123/p/6723729.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 工厂模式</title>
    <url>/post/2588474815.html</url>
    <content><![CDATA[<h4 id="一、什么是工厂模式？"><a href="#一、什么是工厂模式？" class="headerlink" title="一、什么是工厂模式？"></a>一、什么是工厂模式？</h4><p>　　一个类通过本身的静态方法来，实例化一个类并返回一个实例对象；</p>
<h4 id="二、工厂模式特点？"><a href="#二、工厂模式特点？" class="headerlink" title="二、工厂模式特点？"></a>二、工厂模式特点？</h4><p>　　类命名特点：nameFactory  eg:  class mysqlFactory{}  【这是为了规范，当然也去起其他任意名字】</p>
<p>　　静态方法名称：static public function  factory($class_name){} 【静态方法是类与外界的接口， 返回的是一个对象】</p>
<h4 id="三、优点？"><a href="#三、优点？" class="headerlink" title="三、优点？"></a>三、优点？</h4><p>　　如果已经使用的类内部发生改变，哪不需要在所有的地方都改变，只需要在类工厂类里改变既可，</p>
<p>　　　比如：连接数据库，可以使用mysql 、mysqli、pdo，根据不同参数配置使用不同的数据库操作类</p>
<h4 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h4><p>做支付接口的时候，未来可能对应不同的支付网关：支付宝、财付通、网银在线等。<br>方便未来扩展,设计成工厂模式。定一个专门生产网关接口的工厂，抽象出来,<br>做成接口形式，让所有的子类都要实现它的接口。<br>以后加一个支付方式，要使用哪一种支付方式，改变一下参数即可。</p>
<p>在为用户注册的时候，分为很多种角色的用户。<br>比如注册用户，匿名用户、管理员用户等。完全使用可以使用工厂的思想来实现,<br>代码也容易维护,为每种角色可以生成操作的类等等。</p>
<p>系统对接多个不同类型的数据库，mysql，oracle，sqlserver</p>
<h4 id="五、具体示例代码"><a href="#五、具体示例代码" class="headerlink" title="五、具体示例代码"></a>五、具体示例代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建接口定义</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">mysql</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysqli2</span>  <span class="keyword">implements</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'mysqli'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pdo2</span> <span class="keyword">implements</span> <span class="title">mysql</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'pdo'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体调用代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $factory=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>($factory)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:$class=<span class="keyword">new</span> mysqli2();<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:$class=<span class="keyword">new</span> pdo2();<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'-1'</span>,<span class="string">'查无此构建类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $class-&gt;connect();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考文章：<a href="https://www.cnblogs.com/jxkshu/p/9473710.html" target="_blank" rel="noopener">https://www.cnblogs.com/jxkshu/p/9473710.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 建造者模式</title>
    <url>/post/1575233550.html</url>
    <content><![CDATA[<p>建造者模式和抽象工厂模式很像，总体上，建造者模式仅仅只比抽象工厂模式多了一个“导演类”的角色。与抽象工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类 —— 导演类。也就是说，抽像工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将完整建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>指挥者角色（Director）:</strong>构建一个使用Builder接口的对象<br><strong>抽象建造者角色（Builder）：</strong>为创建一个Product对象的各个部件指定的抽象接口<br><strong>具体建造者角色（ConcreteBuilder）：</strong>实现Builder接口，构造和装配各个部件<br><strong>产品角色（Product）</strong></p>
<h4 id="1、基础抽象类（指挥者）"><a href="#1、基础抽象类（指挥者）" class="headerlink" title="1、基础抽象类（指挥者）"></a>1、基础抽象类（指挥者）</h4><p>定义一个基础抽象类，规定所有实现者都必须实现规定的方法，比如想实现车辆的建造，首先必须规定好车辆有哪些零件，所有造车厂商都必须实现所有规定好的零件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">carModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里存储所有组装车需要的零件</span></span><br><span class="line">    <span class="keyword">public</span> $spareParts = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//车的名字</span></span><br><span class="line">    <span class="keyword">public</span> $carName = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加轮子部件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">addLunzi</span><span class="params">($xinghao)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加外壳部件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">addWaike</span><span class="params">($xinghao)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加发动机部件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">addFadongji</span><span class="params">($xinghao)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取车，并给车取名字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCar</span><span class="params">($carName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;spareParts) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;carName = $carName;</span><br><span class="line">            <span class="comment">//$k 代表部件名字</span></span><br><span class="line">            <span class="comment">//$v 代表型号</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;spareParts <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">                $actionName = <span class="string">"add"</span> . $k;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;$actionName($v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"没有汽车部件"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、具体实现类（产品类）"><a href="#2、具体实现类（产品类）" class="headerlink" title="2、具体实现类（产品类）"></a>2、具体实现类（产品类）</h4><p>即实现对应车辆根据对应的<strong>统一基础抽象类</strong>去统一实现，</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义具体的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bmwCarModel</span> <span class="keyword">extends</span> <span class="title">carModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $spareParts = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> $carName = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addLunzi</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"宝马"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的轮子，型号是"</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addWaike</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"宝马"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的外壳，型号是"</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFadongji</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"宝马"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的发动机,型号是 "</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义具体的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">benziCarModel</span> <span class="keyword">extends</span> <span class="title">carModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $spareParts = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> $carName = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addLunzi</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"奔驰"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的轮子，型号是"</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addWaike</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"奔驰"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的外壳，型号是"</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFadongji</span><span class="params">($xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"奔驰"</span> . <span class="keyword">$this</span>-&gt;carName . <span class="string">"的发动机,型号是 "</span> . $xinghao . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3、抽象建造者"><a href="#3、抽象建造者" class="headerlink" title="3、抽象建造者"></a>3、抽象建造者</h4><p>规范产品的组建，一般是由子类实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义建造者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">carBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">setSpareParts</span><span class="params">($partsName, $xinghao)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">getCarModel</span><span class="params">($name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、具体建造者"><a href="#4、具体建造者" class="headerlink" title="4、具体建造者"></a>4、具体建造者</h4><p>实现抽象类定义的所有方法，并且返回一个组件好的对象。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bmwBuilder</span> <span class="keyword">extends</span> <span class="title">carBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $bmwModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bmwModel = <span class="keyword">new</span> bmwCarModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSpareParts</span><span class="params">($partsName, $xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bmwModel-&gt;spareParts[$partsName] = $xinghao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCarModel</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bmwModel-&gt;getCar($name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">benziBuilder</span> <span class="keyword">extends</span> <span class="title">carBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $benziModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;benziModel = <span class="keyword">new</span> benziCarModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSpareParts</span><span class="params">($partsName, $xinghao)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bmwModel-&gt;spareParts[$partsName] = $xinghao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCarModel</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bmwModel-&gt;getCar($name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体调用代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//模拟客户端调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一辆宝马车，取名字为宝马x1</span></span><br><span class="line"></span><br><span class="line">        $bmwBuilder = <span class="keyword">new</span> bmwBuilder();</span><br><span class="line">        $bmwBuilder-&gt;setSpareParts(<span class="string">'Lunzi'</span>, <span class="string">'牛逼轮子1号'</span>);</span><br><span class="line">        $bmwBuilder-&gt;setSpareParts(<span class="string">'Waike'</span>, <span class="string">'牛逼外壳1号'</span>);</span><br><span class="line">        $bmwBuilder-&gt;setSpareParts(<span class="string">'Fadongji'</span>, <span class="string">'牛逼发动机1号'</span>);</span><br><span class="line">        $bmwBuilder-&gt;getCarModel(<span class="string">"宝马x1"</span>);</span><br><span class="line">        $bmwBuilder-&gt;getCarModel(<span class="string">"宝马x1"</span>);  <span class="comment">//连续创建两个宝马x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个宝马 没有外壳 取名为 宝马s5</span></span><br><span class="line">        $bmwBuilder = <span class="keyword">new</span> bmwBuilder();</span><br><span class="line">        $bmwBuilder-&gt;setSpareParts(<span class="string">'Lunzi'</span>, <span class="string">'牛逼轮子2号'</span>);</span><br><span class="line">        $bmwBuilder-&gt;setSpareParts(<span class="string">'Fadongji'</span>, <span class="string">'牛逼发动机2号'</span>);</span><br><span class="line">        $bmwBuilder-&gt;getCarModel(<span class="string">"宝马s5"</span>);</span><br><span class="line">        $bmwBuilder-&gt;getCarModel(<span class="string">"宝马s5"</span>);  <span class="comment">//连续创建两个宝马x1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1、客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。用户使用不同的具体建造者即可得到不同的产品对象，新增具体建造者符合“开闭原则”。<br>2、可以更精细地控制产品的创建过程。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1、不适用于内部变化复杂的产品。如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>建造者模式，适用于创建有复杂内部结构的对象，对象属性之间相互依赖，且又可能要使用到一些其他不易得到的对象。</p>
<p>参考链接：<a href="https://www.cnblogs.com/mingmingcome/p/9637343.html" target="_blank" rel="noopener">https://www.cnblogs.com/mingmingcome/p/9637343.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP abstract 抽象类定义与用法示例</title>
    <url>/post/137974761.html</url>
    <content><![CDATA[<h3 id="PHP抽象类应用要点："><a href="#PHP抽象类应用要点：" class="headerlink" title="PHP抽象类应用要点："></a>PHP抽象类应用要点：</h3><p>1.定义一些方法，子类必须完全实现这个抽象中所有的方法<br>2.不能从抽象类创建对象，它的意义在于被扩展<br>3.抽象类通常具有抽象方法，方法中没有大括号  </p>
<h3 id="PHP抽象类应用重点："><a href="#PHP抽象类应用重点：" class="headerlink" title="PHP抽象类应用重点："></a>PHP抽象类应用重点：</h3><p>1.抽象方法不必实现具体的功能，由子类来完成<br>2.在子类实现抽象类的方法时，其子类的可见性必须大于或等于抽象方法的定义<br>3.抽象类的方法可以有参数，也可以为空<br>4.如果抽象方法有参数，那么子类的实现也必须有相同的参数个数  </p>
<p>示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：抽象类不实现具体方法，具体方法由子类完成。</span></span><br><span class="line"><span class="comment">//定义抽象类 abstract</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="comment">//abstract 定义抽象类的方法，这里没有花括号。子类必须实现这个抽象方法。</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//抽象类可以有参数</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">($argument)</span></span>;</span><br><span class="line">  <span class="comment">//在抽象类中可以定义普通的方法。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'这是run方法'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="comment">//子类必须实现父类的抽象方法，否则是致命的错误。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'这是say方法,实现了抽象方法'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">($argument)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'抽象类可以有参数 ，输出参数：'</span>.$argument;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体调用代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$b =<span class="keyword">new</span> B;</span><br><span class="line">$b-&gt;say();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">$b-&gt;eat(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">$b-&gt;run();</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://www.jb51.net/article/141084.html" target="_blank" rel="noopener">https://www.jb51.net/article/141084.html</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 注册树模式</title>
    <url>/post/2975869525.html</url>
    <content><![CDATA[<h3 id="注册树模式介绍"><a href="#注册树模式介绍" class="headerlink" title="注册树模式介绍"></a>注册树模式介绍</h3><p>概念：将已经创建好的对象注册到某个容器里，在需要使用的时候直接从容器获取即可。<br>优势：解决全局共享和交换对象，将对象注册到全局的树上任何地方直接去访问。</p>
<h4 id="具体注册树和被注册类代码示例"><a href="#具体注册树和被注册类代码示例" class="headerlink" title="具体注册树和被注册类代码示例"></a><strong>具体注册树和被注册类代码示例</strong></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> $objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($alias, $object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$objects[$alias] = $object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($alias)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$objects[$alias];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">_unset</span><span class="params">($alias)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">self</span>::$objects[$alias]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class demo 演示类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'看这里看这里&lt;br&gt;&lt;br&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体示例调用代码"><a href="#具体示例调用代码" class="headerlink" title="具体示例调用代码"></a><strong>具体示例调用代码</strong></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">   $action=(<span class="keyword">new</span> Register());</span><br><span class="line">   $action::set(<span class="string">"demo"</span>,<span class="keyword">new</span> demo());</span><br><span class="line">   $action::get(<span class="string">"demo"</span>)-&gt;test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>PHP 观察者模式</title>
    <url>/post/960570916.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。</span></span><br><span class="line"><span class="comment"> * 比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</span></span><br><span class="line"><span class="comment"> * 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>一般来说有两个接口类，用以框定观察者模式： </p>
<ul>
<li>一个<strong>被观察者接口类</strong>（一般申明有三个必须方法：1.添加观察者对象的方法，2.删除观察者对象的方法 ，3.通知观察者进行  相应执行的方法）</li>
<li>一个<strong>观察者接口类</strong>（一般只有一个必须方法，就是执行）</li>
<li></li>
</ul>
<h3 id="具体代码实现范例"><a href="#具体代码实现范例" class="headerlink" title="具体代码实现范例"></a>具体代码实现范例</h3><h4 id="1、标题添加观察者接口和被观察者接口"><a href="#1、标题添加观察者接口和被观察者接口" class="headerlink" title="1、标题添加观察者接口和被观察者接口"></a>1、标题添加观察者接口和被观察者接口</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(Observer $observer)</span></span>;  <span class="comment">//添加（注册）观察者对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span></span>;    <span class="comment">//删除观察者对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span>;                      <span class="comment">//通知观察者执行相应功能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span><span class="params">()</span></span>;   <span class="comment">//观察者要执行的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、被观察者继承类"><a href="#2、被观察者继承类" class="headerlink" title="2、被观察者继承类"></a>2、被观察者继承类</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被观察者继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $_observers=<span class="keyword">array</span>(); <span class="comment">//用于存储观察者对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于添加（注册）观察者对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(Observer $observer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_observers[]=$observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于删除观察者对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        $index = array_search($observer, <span class="keyword">$this</span>-&gt;_observers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($index === <span class="keyword">FALSE</span> || ! array_key_exists($index, <span class="keyword">$this</span>-&gt;_observers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;_observers[$index]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知各观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//****重点，其实就是循环中执行各观察这对象的watch方法，不同功能方法内容不同但方法名相同</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_observers <span class="keyword">as</span> $observer) &#123;</span><br><span class="line">            $observer-&gt;watch();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、观察者继承类"><a href="#3、观察者继承类" class="headerlink" title="3、观察者继承类"></a>3、观察者继承类</h4><p>这也是具体的业务逻辑实现代码，如注册完之后给用户发邮件短信之类的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cat观察者继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Cat watches TV&lt;hr/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dog观察者继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Dog watches TV&lt;hr/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//people观察者继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"People watches TV&lt;hr/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4、具体实例化调用代码"><a href="#4、具体实例化调用代码" class="headerlink" title="4、具体实例化调用代码"></a>4、具体实例化调用代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $action=(<span class="keyword">new</span> Action());</span><br><span class="line">    $action-&gt;register(<span class="keyword">new</span> Cat());</span><br><span class="line">    $action-&gt;register(<span class="keyword">new</span> Dog());</span><br><span class="line">    $action-&gt;notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体的应用场景如用户注册完后给用户发邮件和短信，这里可以通过观察者模式给通过将邮件和短信这两个<strong>观察者</strong>注册到<strong>被观察者</strong>中,判断注册完毕后直接调用<strong>notify()</strong> 方法直接通知各观察者。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>php定义方法属性类比普通传值的优点</title>
    <url>/post/2520600556.html</url>
    <content><![CDATA[<p>普通传值：是指直接将参数从一个方法传到另一个方法，最简单暴力的方式。<br>方法属性类：将需要传递的所有值以方法属性类的方式定义出来，需要用时直接取出即可。</p>
<h3 id="两者的代码实现方式"><a href="#两者的代码实现方式" class="headerlink" title="两者的代码实现方式"></a>两者的代码实现方式</h3><h4 id="1、普通传值方式"><a href="#1、普通传值方式" class="headerlink" title="1、普通传值方式"></a>1、普通传值方式</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetail(<span class="string">'小李'</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetail</span><span class="params">($name,$age)</span></span>&#123;</span><br><span class="line">    print_r([$name,$age]);<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、方法属性类方式"><a href="#2、方法属性类方式" class="headerlink" title="2、方法属性类方式"></a>2、方法属性类方式</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $data=(<span class="keyword">new</span> HumanDetail());</span><br><span class="line">    $data-&gt;setName(<span class="string">'小李'</span>);</span><br><span class="line">    $data-&gt;setAge(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetail($data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetail</span><span class="params">(HumanDetail $data)</span></span>&#123;</span><br><span class="line">    print_r([$data-&gt;getName(),$data-&gt;getAge()]);<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HumanDreail类文件</strong>  </p>
<p><img src="/resource/images/pasted2-0.png" alt="upload successful"><br>从上面两者的实现代码可以看出<strong>普通传值</strong>方式简单简洁，<strong>方法属性类传值</strong>代码实现相对繁琐，还要多写一个类文件。既然这样的话为什么还要有<strong>方法属性类传值</strong>的方式呢？</p>
<p>试想一下，当参数还少的时候没什么问题，但是当参数多的时候，这样传递代码很难看，也有人说可以直接把所有参数放到一个数组里面，然后直接传递那个数组参数即可，但是这里又有一个问题，就是你传递的数组里面有什么值其他人是无法一眼看出的，而且数组也可以传递所需参数外的其他参数，这样很不利于其他人维护。  </p>
<h3 id="方法属性类方式比普通传值的优点"><a href="#方法属性类方式比普通传值的优点" class="headerlink" title="方法属性类方式比普通传值的优点"></a>方法属性类方式比普通传值的优点</h3><p>例如下面的案例：</p>
<h4 id="1、普通传值"><a href="#1、普通传值" class="headerlink" title="1、普通传值"></a>1、普通传值</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $name=<span class="string">'小李'</span>;</span><br><span class="line">    $age=<span class="number">10</span>;</span><br><span class="line">    $sex=<span class="string">'男'</span>;</span><br><span class="line">    $type=<span class="number">1</span>;</span><br><span class="line">    $a=<span class="string">'a'</span>;</span><br><span class="line">    $b=<span class="string">'b'</span>;</span><br><span class="line">    $c=<span class="string">'c'</span>;</span><br><span class="line">    $d=<span class="string">'d'</span>;</span><br><span class="line">    $e=<span class="string">'e'</span>;</span><br><span class="line">    $f=<span class="string">'f'</span>;</span><br><span class="line">    $g=<span class="string">'g'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetailA($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetailB($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetailA</span><span class="params">($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g)</span></span>&#123;</span><br><span class="line">    print_r([$name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetailB</span><span class="params">($name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g)</span></span>&#123;</span><br><span class="line">    print_r([$name,$age,$sex,$type,$a,$b,$c,$d,$e,$f,$g]);<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、方法属性类方式-1"><a href="#2、方法属性类方式-1" class="headerlink" title="2、方法属性类方式"></a>2、方法属性类方式</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $data=(<span class="keyword">new</span> HumanDetail());</span><br><span class="line">    $data-&gt;setName(<span class="string">'小李'</span>);</span><br><span class="line">    $data-&gt;setAge(<span class="number">10</span>);</span><br><span class="line">    $data-&gt;setSex(<span class="string">'男'</span>);</span><br><span class="line">    $data-&gt;setType(<span class="number">1</span>);</span><br><span class="line">    $data-&gt;setA(<span class="string">'a'</span>);</span><br><span class="line">    $data-&gt;setB(<span class="string">'b'</span>);</span><br><span class="line">    $data-&gt;setC(<span class="string">'c'</span>);</span><br><span class="line">    $data-&gt;setD(<span class="string">'d'</span>);</span><br><span class="line">    $data-&gt;setE(<span class="string">'e'</span>);</span><br><span class="line">    $data-&gt;setF(<span class="string">'f'</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetailA($data);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;returnDetailB($data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetailA</span><span class="params">(HumanDetail $data)</span></span>&#123;</span><br><span class="line">    print_r([$data-&gt;getName(),$data-&gt;getAge(),$data-&gt;getSex(),$data-&gt;getA(),$data-&gt;getB(),$data-&gt;getC(),</span><br><span class="line">        $data-&gt;getD(),$data-&gt;getE(),$data-&gt;getF()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">returnDetailB</span><span class="params">(HumanDetail $data)</span></span>&#123;</span><br><span class="line">    print_r([$data-&gt;getName(),$data-&gt;getAge(),$data-&gt;getSex(),$data-&gt;getA(),$data-&gt;getB(),$data-&gt;getC(),</span><br><span class="line">        $data-&gt;getD(),$data-&gt;getE(),$data-&gt;getF()]);<span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HumanDreail类文件</strong></p>
<p><img src="/resource/images/pasted2-1.png" alt="upload successful"></p>
<p><strong>并且上面的方法属性类传值方式还可以进一步优化</strong><br>优化如下：<br><strong>HumanDreail类文件</strong>  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">components</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanDetail</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $name=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $age=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> $sex=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $type=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> $a=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $b=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $c=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $d=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $e=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $f=<span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method,$args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        $perfix=strtolower(substr($method,<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        $property=strtolower(substr($method,<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>($perfix) || <span class="keyword">empty</span>($property)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>($perfix==<span class="string">"get"</span> &amp;&amp; <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$property)) <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$property;</span><br><span class="line">        <span class="keyword">if</span>($perfix==<span class="string">"set"</span>)<span class="keyword">$this</span>-&gt;$property=$args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if($perfix=="set")&#123;</span></span><br><span class="line">              <span class="comment">//开启强类型判断，对于php这种弱类型语言来说开启后对线上稳定会造成隐患</span></span><br><span class="line"><span class="comment">//            if(gettype($this-&gt;$property) == gettype($args[0]) )&#123;</span></span><br><span class="line"><span class="comment">//                $this-&gt;$property=$args[0];</span></span><br><span class="line"><span class="comment">//            &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                throw new \BaseComponents\base\Exception(['-1',$property." is wrong type, &#123;$property&#125; is ".gettype</span></span><br><span class="line"><span class="comment">//                    ($this-&gt;$property)." and args is ".gettype($args[0])]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，当传参参数变多了且当有多个接收方的时候，代码可维护性就变高了，接收方只需要从对应的类文件中需要自己需要的参数即可，不用这样多参数的传递，而且这还只是一层传递方式而已，如果是多层传递的话，那代码看上去就相对冗余难以维护。</p>
<h3 id="总结：两者的优缺点"><a href="#总结：两者的优缺点" class="headerlink" title="总结：两者的优缺点"></a>总结：两者的优缺点</h3><h4 id="普通传值"><a href="#普通传值" class="headerlink" title="普通传值"></a>普通传值</h4><p>优点：<br>1、传值参数少，业务场景简单时，简洁明了。<br>缺点：<br>1、传值参数多，业务场景复杂时，代码可读性差，拓展性差。<br>2、传递层次多时，代码可读性和拓展性差的缺点会更加明显。</p>
<h4 id="方法属性类"><a href="#方法属性类" class="headerlink" title="方法属性类"></a>方法属性类</h4><p>优点：<br>1、传值参数多，业务场景复杂时，代码可读性高，便于团队开发，拓展性强。<br>2、传递层次多时，代码可读性和拓展性强的优势会更加明显。<br>缺点：<br>1、传值参数少，业务场景简单时，代码量相对于普通传值方式更多。</p>
<p>一般来说一个业务的未来变化情况是可以预测到的，正确的选择对应的传值方式，有利于代码的可维护性和拓展性，更加有利于代码的健壮性。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>php 接口类与抽象类的实际作用</title>
    <url>/post/4065656781.html</url>
    <content><![CDATA[<h4 id="实际作用总结"><a href="#实际作用总结" class="headerlink" title="实际作用总结:"></a>实际作用总结:</h4><p><strong>1、定义规范，方便大型项目多人开发。</strong><br>当有很多人一起开发一个项目时，可能都会去调用别人写的一些类，那你就会问，我怎么知道他的某个功能的实现方法是怎么命名的呢，这个时候php接口类就起到作用了，当我们定义了一个接口类时，它里面的方式是下面的子类必须实现的。</p>
<h4 id="1-php-接口类-interface"><a href="#1-php-接口类-interface" class="headerlink" title="1.php 接口类:interface"></a>1.php 接口类:interface</h4><p>其实他们的作用很简单，当有很多人一起开发一个项目时，可能都会去调用别人写的一些类，那你就会问，我怎么知道他的某个功能的实现方法是怎么命名的呢，这个时候php接口类就起到作用了，当我们定义了一个接口类时，它里面的方式是下面的子类必须实现的，比如 : </p>
<p>代码如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shop</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">($gid)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sell</span><span class="params">($gid)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view</span><span class="params">($gid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我声明一个shop接口类，定义了三个方法：买(buy),卖(sell),看(view),那么继承此类的所有子类都必须实现这3个方法少一个都不行，如果子类没有实现这些话，就无法运行。实际上接口类说白了，就是一个类的模板，一个类的规定，如果你属于这类，你就必须遵循我的规定，少一个都不行，但是具体你怎么去做，我不管，那是你的事，如：<br>代码如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseShop</span> <span class="keyword">implements</span> <span class="title">Shop</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你购买了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sell</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你卖了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你查看了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你想想，在一个多人合作的大项目里面，有了接口类是多么的方便，这样你就不用去问别人，你的某某功能的方法名是什么了，当然如果你们喜欢这样我也没有办法。<br>结论 ： 接口类就是一个类的领导者，指明方向，子类必须完成它指定方法。</p>
<h4 id="2-php-抽象类-abstract"><a href="#2-php-抽象类-abstract" class="headerlink" title="2.php 抽象类 : abstract"></a>2.php 抽象类 : abstract</h4><p>其实抽象类和接口类有一部分很像，记得在哪里看见这样一句话，抽象类就把类像的部分抽出来，这句看上去很搞笑，其实它说出了抽象类的真理，抽象类的作用是，当你发现你的很多类里面用很多方法你不断的在重复写，那你就可以考虑使用抽象类了，你可能会说“我不是可以重写一个类每个公共类我个实例化一个这个公共类，调用相同的方法就可以了”，这里是可以，实际上抽象类做的工作也就是这个，不过他省去了你实例化的这个步骤，让你就像直接调用本类方法一样方便，而且你还可以重载这个方法。如：<br>代码如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseShop</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你购买了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sell</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你卖了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view</span><span class="params">($gid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">'你查看了ID为 :'</span>.$gid.<span class="string">'的商品'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BallShop</span> <span class="keyword">extends</span> <span class="title">BaseShop</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $itme_id = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;itme_id = <span class="number">2314</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sell(<span class="keyword">$this</span>-&gt;itme_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是一个例子，想上面一样我定义了一个商店类，抽出了它所有像的部分，买(buy),卖(sell),看(view),并且抽象类里都实现了这些方法，那么继承它的子类就自动获得了这些方法，子类就做它自己独特的东西，介绍代码的重复，提高复用性。<br>结论： 抽象类就是一个类的服务提供商，拥有众多服务，你不用必须用，当需要的时候你来用就可以，如果你觉得不提供服务不满意，你还可以自己来做。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>php中的implements 使用详解</title>
    <url>/post/3630165851.html</url>
    <content><![CDATA[<p>php类中接口的应用关键字是interface、implements了，接口是一种成员属性全部为抽象或常量的特殊抽象类,implements主要是对类名，类所拥有的方法，以及所传参数起约束和规范做用，有点像 abstract 抽象类。</p>
<h4 id="类中接口的应用"><a href="#类中接口的应用" class="headerlink" title="类中接口的应用"></a>类中接口的应用</h4><p>1.关键字：interface</p>
<p>2.关键字：implements</p>
<h4 id="接口的介绍与规则"><a href="#接口的介绍与规则" class="headerlink" title="接口的介绍与规则"></a>接口的介绍与规则</h4><p>接口：一种成员属性全部为抽象或常量的特殊抽象类。</p>
<p><strong>规则：</strong>  </p>
<p><strong>1.类中全部为抽象方法。</strong><br><strong>2.抽象方法前不用加abstract。</strong><br><strong>3.接口抽象方法属性为public。</strong><br><strong>4.成员属性必须为常量。</strong>  </p>
<p>格式代码如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">"常量对象属性"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myfun1</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myfun2</span><span class="params">()</span></span>; <span class="comment">//抽象方法,不用具体写入逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一，接口的定义和调用"><a href="#一，接口的定义和调用" class="headerlink" title="一，接口的定义和调用"></a>一，接口的定义和调用</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> film = <span class="string">'加勒比海盗'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"影院 接口开放了&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$face = <span class="keyword">new</span> Order();</span><br><span class="line"><span class="keyword">echo</span> $face-&gt;show();       </span><br><span class="line"><span class="keyword">echo</span> Cinema::film;</span><br></pre></td></tr></table></figure>

<p>说明：上面的例子要注意一点，接口的方法名是show，继承接口的类中必须有show这个方法，不然就会报错。也就是说接口的方法是假的，真正起作用的是在继承的类中的方法，这里接口和php的抽象类是不是有点像了?</p>
<h4 id="二，对参数约束比较严"><a href="#二，对参数约束比较严" class="headerlink" title="二，对参数约束比较严"></a>二，对参数约束比较严</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(Order $show,$num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示正常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $number=<span class="string">'0011排'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(Order $show,$num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> $show-&gt;number.$num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$face= <span class="keyword">new</span> Order();</span><br><span class="line"></span><br><span class="line">$face-&gt;show(<span class="keyword">new</span> Order,$num=<span class="string">'3人'</span>);<span class="comment">//输出 0011排3人</span></span><br></pre></td></tr></table></figure>

<p>说明：上面的这个例子继承接口类中，调用接口的方法时，所传参数要和接口中的参数名要一至。不然就会报错。</p>
<h4 id="三，接口间的继承和调用接口传递参数"><a href="#三，接口间的继承和调用接口传递参数" class="headerlink" title="三，接口间的继承和调用接口传递参数"></a>三，接口间的继承和调用接口传递参数</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cinema1</span> <span class="keyword">extends</span> <span class="title">Cinema</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show1</span><span class="params">(Order1 $object,$num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Cinema1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"准备就绪&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show1</span><span class="params">(Order1 $object,$num)</span> //注意:<span class="title">show1</span><span class="params">(Order1 $object,$num)</span>中的<span class="title">Order1</span>必须根继承类的名子要一样<span class="title">class</span> <span class="title">Order1</span>。如果不一样，会报<span class="title">fatal</span>错误</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//var_dump($object);</span></span><br><span class="line">        <span class="keyword">echo</span> $object-&gt;number.<span class="string">"$num&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $number=<span class="string">"0012排"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">' ================='</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$show = <span class="keyword">new</span> Order1;</span><br><span class="line">$show-&gt;fun();          </span><br><span class="line">$test = <span class="keyword">new</span> Order();</span><br><span class="line">$test-&gt;show();           </span><br><span class="line">$test-&gt;show1($show,$num=<span class="string">'6人'</span>);</span><br><span class="line"><span class="comment">// 输出 ===============准备就绪0012排6人</span></span><br></pre></td></tr></table></figure>

<p>说明：上面的例子可以看到，接口Cinemal1继承了接口Cinemal，类Order继承了接口Cinemal1。不知道你发现没有，class类Order当中包括有二个方法，一个是show，一个show1，并且一个也不能少，如果少一个，报fatal错误。show1(Order1 $object,$num)中的Order1必须根继承类的名子要一样class Order1。如果不一样，也会报fatal错误。那如果一个接口被多个类继承，并且类名又不一样，怎么办呢？那就要用self了，下面会提到：(这是官网手册的一个示例,鉴于类名的Sting与关键词冲突，我这里改成了Strings,大家可自行更改，不冲突即可)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(self $compare)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strings</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;string = $string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(self $compare)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;string == $compare-&gt;string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $integer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($int)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;integer = $int;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(self $compare)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;integer == $compare-&gt;integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$first_int = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line">$second_int = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line">$first_string = <span class="keyword">new</span> Strings(<span class="string">"慕容博"</span>);</span><br><span class="line">$second_string = <span class="keyword">new</span> Strings(<span class="string">"慕容复"</span>);</span><br><span class="line"></span><br><span class="line">var_dump($first_int-&gt;compare($second_int)); <span class="comment">// bool(true)</span></span><br><span class="line">var_dump($first_string-&gt;compare($second_string)); <span class="comment">// bool(false)</span></span><br></pre></td></tr></table></figure>

<p>按照官网手册的意思：可以使用“self”强制对象暗示实现类的方法，但是，我们发现无论是PHP5+那个版本，都报了fatal error:</p>
<p>大致意思是继承类和接口方法变量兼容问题。</p>
<p>正确做法：去掉 self 即可或者把self 替换成 接口的Comparable名。如：function compare(Comparable $compare)</p>
<h4 id="四，一个接口多个继承"><a href="#四，一个接口多个继承" class="headerlink" title="四，一个接口多个继承"></a>四，一个接口多个继承</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">"电影名称"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> TEST = <span class="string">"这里是测试Test"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> <span class="keyword">implements</span> <span class="title">demo</span>, <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"你好"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"----------"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"我也好&lt;br /&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"大家都好&lt;br /&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourDemo</span> <span class="keyword">extends</span> <span class="title">MyDemo</span> <span class="keyword">implements</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"继承类后引用接口"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$p = <span class="keyword">new</span> YourDemo;</span><br><span class="line">$p-&gt;fun1();</span><br><span class="line">$p-&gt;fun2();</span><br><span class="line">$p-&gt;fun3();</span><br><span class="line">$p-&gt;fun4();</span><br><span class="line">$p-&gt;fun5();</span><br></pre></td></tr></table></figure>

<p>以上输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">你好----------我也好</span><br><span class="line">大家都好</span><br><span class="line">继承类后引用接口</span><br></pre></td></tr></table></figure>

<p>上面的例子中我们可以看到接口都使用关键字 interface 来定义，并使用关键字 implements 来实现接口中的方法，再举个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDiscount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUserType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123; <span class="comment">//VIP用户 接口实现</span></span><br><span class="line">    <span class="keyword">private</span> $discount = <span class="number">0.8</span>;    <span class="comment">// VIP 用户折扣系数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;discount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUserType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"VIP用户"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $price = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">var</span> $vc;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(User $vc)</span></span>&#123;     <span class="comment">//定义 User 接口类型参数，这时并不知道是什么用户</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;vc = $vc;</span><br><span class="line">        $discount = <span class="keyword">$this</span>-&gt;vc-&gt;getDiscount();</span><br><span class="line">        $usertype = <span class="keyword">$this</span>-&gt;vc-&gt;getUserType();</span><br><span class="line">        <span class="keyword">echo</span> $usertype.<span class="string">"商品价格："</span>.<span class="keyword">$this</span>-&gt;price*$discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$display = <span class="keyword">new</span> Goods();</span><br><span class="line">$display -&gt;run(<span class="keyword">new</span> VipUser); <span class="comment">//VIP用户商品价格：70.4</span></span><br></pre></td></tr></table></figure>

<p>这个例子演示了一个 PHP 接口的简单应用。该例子中，User 接口实现用户的折扣，而在 VipUser 类里面实现了具体的折扣系数。最后商品类 Goods 根据 User 接口来实现不同的用户报价.</p>
<p>最后总结下：</p>
<p><strong>抽象类和接口的区别</strong></p>
<p>接口是特殊的抽象类，也可以看做是一个模型的规范。接口与抽象类大致区别如下：</p>
<p>1.一个子类如果 implements 一个接口，就必须实现接口中的所有方法（不管是否需要）；如果是继承一个抽象类，只需要实现需要的方法即可。</p>
<p>2.如果一个接口中定义的方法名改变了，那么所有实现此接口的子类需要同步更新方法名；而抽象类中如果方法名改变了，其子类对应的方法名将不受影响，只是变成了一个新的方法而已（相对老的方法实现）。</p>
<p>3.抽象类只能单继承，当一个子类需要实现的功能需要继承自多个父类时，就必须使用接口。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>linux安装php扩展大全</title>
    <url>/post/784803616.html</url>
    <content><![CDATA[<p>centos7安装php扩展大全<br>&nbsp;&nbsp;&nbsp;有一个小想法，整理一篇linux下安装php拓展大全文章，方便自己或其它人开箱即用，目前就自己遇到哪些需要安装的拓展安装后就顺便更新到这篇博客文章。</p>
<h3 id="1、Yaconf"><a href="#1、Yaconf" class="headerlink" title="1、Yaconf"></a>1、Yaconf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/laruence/yaconf &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> yaconf/  &amp;&amp; \</span><br><span class="line">phpize  &amp;&amp; \</span><br><span class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/php/etc/php.ini</span><br><span class="line">[Yaconf]</span><br><span class="line">extension=yaconf.so <span class="comment">#扩展引用</span></span><br><span class="line">yaconf.directory=/home/www/conf <span class="comment">#conf文件所在目录</span></span><br><span class="line">yaconf.check_delay=0 <span class="comment">#心跳检查时间，若为0则不检查，但如果有修改，需重启PHP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">读取值：</span><br><span class="line"><span class="keyword">echo</span> Yaconf::get(<span class="string">"web_env.MYSQL_ETC1_MASTER_HOST"</span>); <span class="comment">//test是配置文件名字</span></span><br><span class="line"></span><br><span class="line">判断是否有该项设置</span><br><span class="line"><span class="keyword">echo</span> Yaconf::has(<span class="string">"web_env.MYSQL_ETC1_MASTER_HOST"</span>); <span class="comment">//test是配置文件名字</span></span><br></pre></td></tr></table></figure>
<h3 id="2、xdebug"><a href="#2、xdebug" class="headerlink" title="2、xdebug"></a>2、xdebug</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://xdebug.org/files/xdebug-2.8.1.tgz &amp;&amp; \</span><br><span class="line">tar zxvf xdebug-2.8.1.tgz &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> xdebug-2.8.1 &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">./configure --<span class="built_in">enable</span>-xdebug --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Xdebug]</span><br><span class="line">zend_extension=xdebug.so </span><br><span class="line">xdebug.idekey = PHPSTROM</span><br><span class="line">xdebug.default_enable = 1 </span><br><span class="line">xdebug.remote_connect_back = 1 </span><br><span class="line">xdebug.remote_port = 9000 </span><br><span class="line">xdebug.remote_enable = 1 </span><br><span class="line">xdebug.remote_autostart = 1 </span><br><span class="line">xdebug.remote_handler=<span class="string">"dbgp"</span></span><br><span class="line">xdebug.remote_host=192.168.33.10</span><br></pre></td></tr></table></figure>

<h3 id="3、protobuf"><a href="#3、protobuf" class="headerlink" title="3、protobuf"></a>3、protobuf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/allegro/php-protobuf/archive/master.zip &amp;&amp; \</span><br><span class="line">unzip master.zip &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> php-protobuf-master/ &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">然后在php.ini里面加一下extension = protobuf.so，再重启php</span><br></pre></td></tr></table></figure>

<h3 id="4、mongodb"><a href="#4、mongodb" class="headerlink" title="4、mongodb"></a>4、mongodb</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://pecl.php.net/get/mongodb-1.7.4.tgz &amp;&amp; \</span><br><span class="line">tar -zxvf mongodb-1.7.4.tgz &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> mongodb-1.7.4/ &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; make &amp;&amp; make install &amp;&amp; \</span><br><span class="line"></span><br><span class="line">然后在php.ini里面加一下extension = mongodb.so，再重启php</span><br></pre></td></tr></table></figure>

<h3 id="5、swoole"><a href="#5、swoole" class="headerlink" title="5、swoole"></a>5、swoole</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/swoole/swoole-src/archive/v4.4.16.tar.gz &amp;&amp; \</span><br><span class="line">tar zxvf v4.4.16.tar.gz &amp;&amp;  \</span><br><span class="line"><span class="built_in">cd</span> swoole-src-4.4.16 &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">./configure --<span class="built_in">enable</span>-openssl --<span class="built_in">enable</span>-http2 --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[swoole]</span><br><span class="line">extension=swoole</span><br><span class="line">swoole.use_shortname = Off</span><br></pre></td></tr></table></figure>

<h3 id="6、xlswriter"><a href="#6、xlswriter" class="headerlink" title="6、xlswriter"></a>6、xlswriter</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget  https://pecl.php.net/get/xlswriter-1.3.5.tgz &amp;&amp; \</span><br><span class="line">tar zxvf xlswriter-1.3.5.tgz &amp;&amp;  \</span><br><span class="line"><span class="built_in">cd</span> xlswriter-1.3.5 &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; ./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config --<span class="built_in">enable</span>-reader &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">然后在php.ini里面加一下extension = xlswriter.so，再重启php</span><br></pre></td></tr></table></figure>


<h3 id="7、redis"><a href="#7、redis" class="headerlink" title="7、redis"></a>7、redis</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pecl.php.net/get/redis-5.3.4.tgz &amp;&amp; \</span><br><span class="line">tar zxvf redis-5.3.4.tgz &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> redis-5.3.4 &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">然后在php.ini里面加一下extension = redis.so，再重启php</span><br></pre></td></tr></table></figure>


<h3 id="8、kafka"><a href="#8、kafka" class="headerlink" title="8、kafka"></a>8、kafka</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注：php操作kafka需要安装rdkafka扩展，而rdkafka又依赖librdkafka库，因此在安装rdkafka之前，需要先安装librdkafka</span><br><span class="line"><span class="comment">##1、安装 librdkafka 库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/edenhill/librdkafka.git &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> librdkafka/ &amp;&amp; \</span><br><span class="line">./configure &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment">##2、安装 php-kafka（rdkafka） 扩展</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/arnaud-lb/php-rdkafka.git &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> php-rdkafka/ &amp;&amp; \</span><br><span class="line">/usr/<span class="built_in">local</span>/php/bin/phpize &amp;&amp; \</span><br><span class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config &amp;&amp; \</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"> </span><br><span class="line">然后在php.ini里面加一下extension = rdkafka.so，再重启php</span><br><span class="line"></span><br><span class="line"><span class="comment"># （安装 php-kafka（rdkafka） 扩展方法二）安装好了librdkafka库之后，就可以使用pecl的方式一键安装rdkafka扩展了</span></span><br><span class="line">pecl install rdkafka  <span class="comment"># 安装rdkafka扩展</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>悲观锁、乐观锁的区别及使用场景</title>
    <url>/post/1011394230.html</url>
    <content><![CDATA[<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，<font color='red'> <strong>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</strong></font></p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，<font color='red'> <strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</strong></font><strong>乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</strong></p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h3 id="乐观锁一般来说有以下2种方式："><a href="#乐观锁一般来说有以下2种方式：" class="headerlink" title="乐观锁一般来说有以下2种方式："></a>乐观锁一般来说有以下2种方式：</h3><ol>
<li><strong>使用数据版本（Version）记录机制实现</strong>，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。 </li>
<li><strong>使用时间戳（timestamp）</strong>。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p>Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。</p>
<p>MySQL隐式和显示锁定<br>MySQL InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。</p>
<p>在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。</p>
<p>前面描述的锁定都是隐式锁定，InnoDB会根据事务隔离级别在需要的时候自动加锁。</p>
<p><strong>另外，InnoDB也支持通过特定的语句进行显示锁定，这些语句不属于SQL规范：</strong> </p>
<ul>
<li>SELECT … LOCK IN SHARE MODE </li>
<li>SELECT … FOR UPDATE</li>
</ul>
<p>实战<br>接下来，我们通过一个具体案例来进行分析：考虑电商系统中的下单流程，商品的库存量是固定的，如何保证商品数量不超卖？ 其实需要保证数据一致性：某个人点击秒杀后系统中查出来的库存量和实际扣减库存时库存量的一致性就可以。</p>
<p>假设，MySQL数据库中商品库存表tb_product_stock 结构定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_product_stock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增ID'</span>,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">INT</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'库存数量'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`modify_time`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`index_pid`</span> (<span class="string">`product_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'商品库存表'</span>;</span><br></pre></td></tr></table></figure>

<p>对应的POJO类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductStock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long productId; <span class="comment">//商品id</span></span><br><span class="line">    <span class="keyword">private</span> Integer number; <span class="comment">//库存量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getProductId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductId</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不考虑并发的情况下，更新库存代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 更新库存(不考虑并发)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStockRaw</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">      ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">      <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;"</span>, productId, product.getNumber());</span><br><span class="line">          <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>多线程并发情况下，会存在超卖的可能。</p>
<p><strong>悲观锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新库存(使用悲观锁)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先锁定商品库存记录</span></span><br><span class="line">        ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125; FOR UPDATE"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">            <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>乐观锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下单减库存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> updateCnt = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (updateCnt == <span class="number">0</span>) &#123;</span><br><span class="line">         ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">         <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;"</span>, productId, product.getNumber());</span><br><span class="line">             <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;    <span class="comment">//卖完啦</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。</strong></p>
<p><strong>乐观锁与悲观锁的区别</strong><br><font color='red'> <strong>乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断</strong></font>，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。</p>
<p>悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁<font color='red'> <strong>（SELECT … FOR UPDATE）</strong></font>，然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。</p>
<p><font color='red'> <strong>什么场景需要使用锁，什么场景不需要使用锁？</strong></font></p>
<p>从中我们也可以知道只要更新数据是依赖读取的数据作为基础条件的，就会有并发更新问题，需要乐观锁或者悲观锁取解决，特别实在计数表现明显。</p>
<p>又比如在更新数据不依赖查询的数据的就不会有问题，例如修改用户的名称，多人同时修改，结果并不依赖于之前的用户名字，这就不会有并发更新问题。</p>
<p>小结<br>这里我们通过 MySQL 乐观锁与悲观锁 解决并发更新库存的问题，当然还有其它解决方案，例如使用 分布式锁。目前常见分布式锁实现有两种：基于Redis和基于Zookeeper，基于这两种 业界也有开源的解决方案，例如 Redisson Distributed locks 、 Apache Curator Shared Lock ，这里就不细说，网上Google 一下就有很多资料。</p>
<p>最后个人小小总结下：<font color='red'> <strong>尽量少使用悲观锁和乐观锁，建议直接使用redis的分布式锁（即setnx命令），因为悲观锁会锁定数据库造成数据库的负担，乐观锁也要多建一个字段不太划算。</strong></font></p>
<p>原文链接：<a href="https://www.cnblogs.com/shoshana-kong/p/10736797.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoshana-kong/p/10736797.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 时间矫正命令</title>
    <url>/post/1199720014.html</url>
    <content><![CDATA[<h6 id="Linux-时间矫正"><a href="#Linux-时间矫正" class="headerlink" title="Linux 时间矫正"></a>Linux 时间矫正</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ntpdate -u ntp.api.bz</span><br></pre></td></tr></table></figure>
<p> 第一使用可能提示ntpdate没安装，用以下命令安装即可  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ntpdate</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux查看进程命令</title>
    <url>/post/2516578616.html</url>
    <content><![CDATA[<h2 id="linux查看进程命令"><a href="#linux查看进程命令" class="headerlink" title="linux查看进程命令"></a>linux查看进程命令</h2><p>查看进程命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -a</span><br></pre></td></tr></table></figure>


<p>杀掉进程命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> 进程id</span><br></pre></td></tr></table></figure>


<p>监听端口命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat  -anp  | grep  4000</span><br></pre></td></tr></table></figure>

<p>查看指定进程命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep redis</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>php判断变量是否为正整数</title>
    <url>/post/934001781.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$data[<span class="string">'recharge_price'</span>]=str_replace(<span class="string">'.00'</span>,<span class="string">''</span>,$data[<span class="string">'recharge_price'</span>]);</span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">"/^[1-9][0-9]*$/"</span> ,$data[<span class="string">'recharge_price'</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"是正整数"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"不是正整数"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>php函数trim中文编码问题解决</title>
    <url>/post/2735926554.html</url>
    <content><![CDATA[<h3 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mb_internal_encoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">$encoding = mb_internal_encoding();</span><br><span class="line">$endData=<span class="keyword">self</span>::mb_rtrim(<span class="string">"广州市"</span>, <span class="string">"市"</span>,$encoding);</span><br><span class="line">print_r($endData);<span class="keyword">exit</span>;    </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"><span class="comment">### 封装方法</span></span><br><span class="line">```php</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">mb_rtrim</span><span class="params">($string, $trim, $encoding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$mask = [];</span><br><span class="line">	$trimLength = mb_strlen($trim, $encoding);</span><br><span class="line">	<span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $trimLength; $i++) &#123;</span><br><span class="line">		$item = mb_substr($trim, $i, <span class="number">1</span>, $encoding);</span><br><span class="line">		$mask[] = $item;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	$len = mb_strlen($string, $encoding);</span><br><span class="line">	<span class="keyword">if</span> ($len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		$i = $len - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			$item = mb_substr($string, $i, <span class="number">1</span>, $encoding);</span><br><span class="line">			<span class="keyword">if</span> (in_array($item, $mask)) &#123;</span><br><span class="line">				$len--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> ($i-- != <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mb_substr($string, <span class="number">0</span>, $len, $encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
</search>
